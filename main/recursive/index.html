<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust has a problematic relationship with recursive functions, because functions that recurse deeply can overflow the stack, crashing your program. This crate makes it easy to remedy this problem by marking (indirectly) recursive functions as such:"><title>recursive - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="recursive" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (842bd5be2 2026-01-29)" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate recursive</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../recursive/index.html">recursive</a><span class="version">0.1.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#what-are-the-downsides" title="What are the downsides?">What are the downsides?</a></li><li><a href="#which-functions-should-i-mark-as-recursive" title="Which functions should I mark as `#[recursive]`?">Which functions should I mark as <code>#[recursive]</code>?</a></li></ul><h3><a href="#functions">Crate Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1>Crate <span>recursive</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/recursive/lib.rs.html#1-90">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust has a problematic relationship with recursive functions, because functions that recurse
deeply can overflow the stack, crashing your program. This crate makes it easy to remedy
this problem by marking (indirectly) recursive functions as such:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>recursive::recursive;

<span class="attr">#[recursive]
</span><span class="kw">fn </span>sum(nums: <span class="kw-2">&amp;</span>[u64]) -&gt; u64 {
    <span class="kw">if let </span><span class="prelude-val">Some</span>((head, tail)) = nums.split_first() {
        head + sum(tail)
    } <span class="kw">else </span>{
        <span class="number">0
    </span>}
}</code></pre></div>
<p>The way this prevents stack overflows is by checking the size of the remaining stack at the
start of each call to your function. If this size is under a boundary set by
<a href="fn.set_minimum_stack_size.html" title="fn recursive::set_minimum_stack_size"><code>set_minimum_stack_size</code></a> (by default 128 KiB), a new stack is allocated and execution
continues on that stack. This new stack’s size is set using <a href="fn.set_stack_allocation_size.html" title="fn recursive::set_stack_allocation_size"><code>set_stack_allocation_size</code></a>, which
is 2 MiB by default.</p>
<p>This crate works by wrapping your function body in a call to <a href="../stacker/fn.maybe_grow.html" title="fn stacker::maybe_grow"><code>stacker::maybe_grow</code></a>. If this
crate is not flexible enough for your needs consider using <a href="../stacker/index.html" title="mod stacker"><code>stacker</code></a> directly yourself.</p>
<h3 id="what-are-the-downsides"><a class="doc-anchor" href="#what-are-the-downsides">§</a>What are the downsides?</h3>
<p>This crate is <strong>not</strong> zero cost, but it is also not limited to simple tail recursion or direct
recursion. However, in most cases the stack size test is very fast and almost always succeeds
without needing to allocate. If your recursive algorithm is very performance-sensitive I would
suggest rewriting it to an iterative version regardless.</p>
<p>This crate only supports those platforms that <a href="../stacker/index.html" title="mod stacker"><code>stacker</code></a> supports. The Rust compiler itself
uses <a href="../stacker/index.html" title="mod stacker"><code>stacker</code></a>, so the platform you’re compiling on should always be fine, but for more
obscure targets see its documentation.</p>
<h3 id="which-functions-should-i-mark-as-recursive"><a class="doc-anchor" href="#which-functions-should-i-mark-as-recursive">§</a>Which functions should I mark as <code>#[recursive]</code>?</h3>
<p>Any function that directly calls itself should be marked as <code>#[recursive]</code>, unless you know for
certain that the stack is sufficiently large for any inputs that function will be called with.
If you are feeding untrusted input into a recursive function you should always mark it as
<code>#[recursive]</code>.</p>
<p>It is not necessary to mark every single function that can indirectly recurse as <code>#[recursive]</code>.
As long as every possible cycle of function calls includes at least one function marked
<code>#[recursive]</code> you will be protected against stack overflows due to recursion.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.get_minimum_stack_size.html" title="fn recursive::get_minimum_stack_size">get_<wbr>minimum_<wbr>stack_<wbr>size</a></dt><dd>Returns the value set by <a href="fn.set_minimum_stack_size.html" title="fn recursive::set_minimum_stack_size"><code>set_minimum_stack_size</code></a>.</dd><dt><a class="fn" href="fn.get_stack_allocation_size.html" title="fn recursive::get_stack_allocation_size">get_<wbr>stack_<wbr>allocation_<wbr>size</a></dt><dd>Returns the value set by <a href="fn.set_stack_allocation_size.html" title="fn recursive::set_stack_allocation_size"><code>set_stack_allocation_size</code></a>.</dd><dt><a class="fn" href="fn.set_minimum_stack_size.html" title="fn recursive::set_minimum_stack_size">set_<wbr>minimum_<wbr>stack_<wbr>size</a></dt><dd>This sets the minimum stack size that <a href="attr.recursive.html" title="attr recursive::recursive"><code>recursive</code></a> requires.</dd><dt><a class="fn" href="fn.set_stack_allocation_size.html" title="fn recursive::set_stack_allocation_size">set_<wbr>stack_<wbr>allocation_<wbr>size</a></dt><dd>When a new stack gets allocated it will get allocated with this size.</dd></dl><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><dl class="item-table"><dt><a class="attr" href="attr.recursive.html" title="attr recursive::recursive">recursive</a></dt><dd>Marks a function to use an automatically growing segmented stack.</dd></dl></section></div></main></body></html>