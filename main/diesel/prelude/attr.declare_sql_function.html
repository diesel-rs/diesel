<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Declare a sql function for use in your code."><title>declare_sql_function in diesel::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="diesel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (842bd5be2 2026-01-29)" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc attr"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">declare_sql_function</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../diesel/index.html">diesel</a><span class="version">2.3.6</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">declare_<wbr>sql_<wbr>function</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#adding-doc-comments" title="Adding Doc Comments">Adding Doc Comments</a></li><li><a href="#special-attributes" title="Special Attributes">Special Attributes</a></li><li><a href="#sql-functions-without-arguments" title="SQL Functions without Arguments">SQL Functions without Arguments</a></li><li><a href="#use-with-sqlite" title="Use with SQLite">Use with SQLite</a><ul><li><a href="#panics" title="Panics">Panics</a></li><li><a href="#custom-aggregate-functions" title="Custom Aggregate Functions">Custom Aggregate Functions</a></li><li><a href="#variadic-functions" title="Variadic functions">Variadic functions</a></li><li><a href="#helper-types-generation" title="Helper types generation">Helper types generation</a></li></ul></li><li><a href="#expanded-code" title="Expanded Code">Expanded Code</a><ul><li><a href="#input" title="Input">Input</a></li><li><a href="#expanded-code-1" title="Expanded Code">Expanded Code</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In diesel::<wbr>prelude</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">diesel</a>::<wbr><a href="index.html">prelude</a></div><h1>Attribute Macro <span class="attr">declare_<wbr>sql_<wbr>function</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/diesel_derives/lib.rs.html#2564-2567">Source</a> </span></div><pre class="rust item-decl"><code>#[declare_sql_function]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Declare a sql function for use in your code.</p>
<p>Diesel only provides support for a very small number of SQL functions.
This macro enables you to add additional functions from the SQL standard,
as well as any custom functions your application might have.</p>
<p>The syntax for this attribute macro is designed to be applied to <code>extern "SQL"</code> blocks
with function definitions. These function typically use types
from <a href="../diesel/sql_types/index.html"><code>diesel::sql_types</code></a> as arguments and return types.
You can use such definitions to declare bindings to unsupported SQL functions.</p>
<p>For each function in this <code>extern</code> block the macro will generate two items.
A function with the name that you’ve given, and a module with a helper type
representing the return type of your function. For example, this invocation:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="kw">fn </span>lower(x: Text) -&gt; Text
}</code></pre></div>
<p>will generate this code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>lower&lt;X&gt;(x: X) -&gt; lower&lt;X&gt; {
    ...
}

<span class="kw">pub type </span>lower&lt;X&gt; = ...;</code></pre></div>
<p>Most attributes given to this macro will be put on the generated function
(including doc comments).</p>
<p>If the <code>generate_return_type_helpers</code> attribute is specified, an additional module named
<code>return_type_helpers</code> will be generated, containing all return type helpers. For more
information, refer to the <code>Helper types generation</code> section.</p>
<h2 id="adding-doc-comments"><a class="doc-anchor" href="#adding-doc-comments">§</a>Adding Doc Comments</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::sql_types::Text;

<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="doccomment">/// Represents the `canon_crate_name` SQL function, created in
    /// migration ....
    </span><span class="kw">fn </span>canon_crate_name(a: Text) -&gt; Text;
}

<span class="kw">let </span>target_name = <span class="string">"diesel"</span>;
crates.filter(canon_crate_name(name).eq(canon_crate_name(target_name)));
<span class="comment">// This will generate the following SQL
// SELECT * FROM crates WHERE canon_crate_name(crates.name) = canon_crate_name($1)</span></code></pre></div><h2 id="special-attributes"><a class="doc-anchor" href="#special-attributes">§</a>Special Attributes</h2>
<p>There are a handful of special attributes that Diesel will recognize. They
are:</p>
<ul>
<li><code>#[aggregate]</code>
<ul>
<li>Indicates that this is an aggregate function, and that <code>NonAggregate</code>
shouldn’t be implemented.</li>
</ul>
</li>
<li><code>#[sql_name = "name"]</code>
<ul>
<li>The SQL to be generated is different from the Rust name of the function.
This can be used to represent functions which can take many argument
types, or to capitalize function names.</li>
</ul>
</li>
<li><code>#[variadic(argument_count)]</code>
<ul>
<li>Indicates that this is a variadic function, where <code>argument_count</code> is a
nonnegative integer representing the number of variadic arguments the
function accepts.</li>
</ul>
</li>
</ul>
<p>Functions can also be generic. Take the definition of <code>sum</code>, for example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::sql_types::Foldable;

<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[aggregate]
    #[sql_name = <span class="string">"SUM"</span>]
    </span><span class="kw">fn </span>sum&lt;ST: Foldable&gt;(expr: ST) -&gt; ST::Sum;
}

crates.select(sum(id));</code></pre></div><h2 id="sql-functions-without-arguments"><a class="doc-anchor" href="#sql-functions-without-arguments">§</a>SQL Functions without Arguments</h2>
<p>A common example is ordering a query using the <code>RANDOM()</code> sql function,
which can be implemented using <code>define_sql_function!</code> like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="kw">fn </span>random() -&gt; Text;
}

crates.order(random());</code></pre></div><h2 id="use-with-sqlite"><a class="doc-anchor" href="#use-with-sqlite">§</a>Use with SQLite</h2>
<p>On most backends, the implementation of the function is defined in a
migration using <code>CREATE FUNCTION</code>. On SQLite, the function is implemented in
Rust instead. You must call <code>register_impl</code> or
<code>register_nondeterministic_impl</code> (in the generated function’s <code>_internals</code>
module) with every connection before you can use the function.</p>
<p>These functions will only be generated if the <code>sqlite</code> feature is enabled,
and the function is not generic.
SQLite doesn’t support generic functions and variadic functions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::sql_types::{Double, Integer};

<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="kw">fn </span>add_mul(x: Integer, y: Integer, z: Double) -&gt; Double;
}

<span class="kw">let </span>connection = <span class="kw-2">&amp;mut </span>SqliteConnection::establish(<span class="string">":memory:"</span>)<span class="question-mark">?</span>;

add_mul_utils::register_impl(connection, |x: i32, y: i32, z: f64| (x + y) <span class="kw">as </span>f64 * z)<span class="question-mark">?</span>;

<span class="kw">let </span>result = select(add_mul(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1.5</span>)).get_result::&lt;f64&gt;(connection)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">4.5</span>, result);</code></pre></div><h3 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h3>
<p>If an implementation of the custom function panics and unwinding is enabled, the panic is
caught and the function returns to libsqlite with an error. It can’t propagate the panics due
to the FFI boundary.</p>
<p>This is the same for <a href="#custom-aggregate-functions">custom aggregate functions</a>.</p>
<h3 id="custom-aggregate-functions"><a class="doc-anchor" href="#custom-aggregate-functions">§</a>Custom Aggregate Functions</h3>
<p>Custom aggregate functions can be created in SQLite by adding an <code>#[aggregate]</code>
attribute inside <code>define_sql_function</code>. <code>register_impl</code> (in the generated function’s <code>_utils</code>
module) needs to be called with a type implementing the
<a href="../diesel/sqlite/trait.SqliteAggregateFunction.html">SqliteAggregateFunction</a>
trait as a type parameter as shown in the examples below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::sql_types::Integer;
<span class="kw">use </span>diesel::sqlite::SqliteAggregateFunction;

<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[aggregate]
    </span><span class="kw">fn </span>my_sum(x: Integer) -&gt; Integer;
}

<span class="attr">#[derive(Default)]
</span><span class="kw">struct </span>MySum { sum: i32 }

<span class="kw">impl </span>SqliteAggregateFunction&lt;i32&gt; <span class="kw">for </span>MySum {
    <span class="kw">type </span>Output = i32;

    <span class="kw">fn </span>step(<span class="kw-2">&amp;mut </span><span class="self">self</span>, expr: i32) {
        <span class="self">self</span>.sum += expr;
    }

    <span class="kw">fn </span>finalize(aggregator: <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>&gt;) -&gt; <span class="self">Self</span>::Output {
        aggregator.map(|a| a.sum).unwrap_or_default()
    }
}

<span class="kw">fn </span>run() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>(::std::error::Error)&gt;&gt; {
    <span class="kw">let </span>connection = <span class="kw-2">&amp;mut </span>SqliteConnection::establish(<span class="string">":memory:"</span>)<span class="question-mark">?</span>;

    my_sum_utils::register_impl::&lt;MySum, <span class="kw">_</span>&gt;(connection)<span class="question-mark">?</span>;

    <span class="kw">let </span>total_score = players.select(my_sum(score))
        .get_result::&lt;i32&gt;(connection)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">"The total score of all the players is: {}"</span>, total_score);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>With multiple function arguments, the arguments are passed as a tuple to <code>SqliteAggregateFunction</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::sql_types::{Float, Nullable};
<span class="kw">use </span>diesel::sqlite::SqliteAggregateFunction;

<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[aggregate]
    </span><span class="kw">fn </span>range_max(x0: Float, x1: Float) -&gt; Nullable&lt;Float&gt;;
}

<span class="attr">#[derive(Default)]
</span><span class="kw">struct </span>RangeMax&lt;T&gt; { max_value: <span class="prelude-ty">Option</span>&lt;T&gt; }

<span class="kw">impl</span>&lt;T: Default + PartialOrd + Copy + Clone&gt; SqliteAggregateFunction&lt;(T, T)&gt; <span class="kw">for </span>RangeMax&lt;T&gt; {
    <span class="kw">type </span>Output = <span class="prelude-ty">Option</span>&lt;T&gt;;

    <span class="kw">fn </span>step(<span class="kw-2">&amp;mut </span><span class="self">self</span>, (x0, x1): (T, T)) {
        <span class="comment">// Compare self.max_value to x0 and x1
    </span>}

    <span class="kw">fn </span>finalize(aggregator: <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>&gt;) -&gt; <span class="self">Self</span>::Output {
        aggregator<span class="question-mark">?</span>.max_value
    }
}

<span class="kw">fn </span>run() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>(::std::error::Error)&gt;&gt; {
    <span class="kw">let </span>connection = <span class="kw-2">&amp;mut </span>SqliteConnection::establish(<span class="string">":memory:"</span>)<span class="question-mark">?</span>;

    range_max_utils::register_impl::&lt;RangeMax&lt;f32&gt;, <span class="kw">_</span>, <span class="kw">_</span>&gt;(connection)<span class="question-mark">?</span>;

    <span class="kw">let </span>result = student_avgs.select(range_max(s1_avg, s2_avg))
        .get_result::&lt;<span class="prelude-ty">Option</span>&lt;f32&gt;&gt;(connection)<span class="question-mark">?</span>;

    <span class="kw">if let </span><span class="prelude-val">Some</span>(max_semester_avg) = result {
        <span class="macro">println!</span>(<span class="string">"The largest semester average is: {}"</span>, max_semester_avg);
    }

    <span class="prelude-val">Ok</span>(())
}</code></pre></div><h3 id="variadic-functions"><a class="doc-anchor" href="#variadic-functions">§</a>Variadic functions</h3>
<p>Since Rust does not support variadic functions, the SQL variadic functions are
handled differently. For example, consider the variadic function <code>json_array</code>.
To add support for it, you can use the <code>#[variadic]</code> attribute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[variadic(<span class="number">1</span>)]
    </span><span class="kw">fn </span>json_array&lt;V: SqlType + SingleValue&gt;(value: V) -&gt; Json;
}</code></pre></div>
<p>This will generate multiple implementations, one for each possible argument
count (up to a predefined limit). For instance, it will generate functions like
<code>json_array_0</code>, <code>json_array_1</code>, and so on, which are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[sql_name = <span class="string">"json_array"</span>]
    </span><span class="kw">fn </span>json_array_0() -&gt; Json;

    <span class="attr">#[sql_name = <span class="string">"json_array"</span>]
    </span><span class="kw">fn </span>json_array_1&lt;V1: SqlType + SingleValue&gt;(value_1: V1) -&gt; Json;

    <span class="attr">#[sql_name = <span class="string">"json_array"</span>]
    </span><span class="kw">fn </span>json_array_2&lt;V1: SqlType + SingleValue, V2: SqlType + SingleValue&gt;(
        value_1: V1,
        value_2: V2,
    ) -&gt; Json;

    <span class="comment">// ...
</span>}</code></pre></div>
<p>The argument to the <code>variadic</code> attribute specifies the number of trailing arguments to repeat.
For example, if you have a variadic function <code>foo(a: A, b: B, c: C)</code> and want <code>b: B</code> and <code>c: C</code>
to repeat, you would write:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[variadic(<span class="number">2</span>)]
    </span><span class="kw">fn </span>foo&lt;A, B, C&gt;(a: A, b: B, c: C) -&gt; Text;
}</code></pre></div>
<p>Which will be equivalent to</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[sql_name = <span class="string">"foo"</span>]
    </span><span class="kw">fn </span>foo_0&lt;A&gt;(a: A) -&gt; Text;

    <span class="attr">#[sql_name = <span class="string">"foo"</span>]
    </span><span class="kw">fn </span>foo_1&lt;A, B1, C1&gt;(a: A, b_1: B1, c_1: C1) -&gt; Text;

    <span class="attr">#[sql_name = <span class="string">"foo"</span>]
    </span><span class="kw">fn </span>foo_2&lt;A, B1, C1, B2, C2&gt;(a: A, b_1: B1, c_1: C1, b_2: B2, c_2: C2) -&gt; Text;

    ...
}</code></pre></div>
<p>Optionally, a second named boolean argument <code>skip_zero_argument_variant</code> can be provided to
control whether the 0-argument variant is generated. By default, (omitted or <code>false</code>),
the 0-argument variant is included. Set it to <code>true</code> to skip generating the 0-argument
variant for functions that require at least one variadic argument. If you specify the boolean
argument, the first argument has to be named <code>last_arguments</code> for clarity.</p>
<p>Example:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[variadic(last_arguments = <span class="number">2</span>, skip_zero_argument_variant = <span class="bool-val">true</span>)]
    </span><span class="kw">fn </span>foo&lt;A, B, C&gt;(a: A, b: B, c: C) -&gt; Text;
}</code></pre></div>
<p>Which will be equivalent to</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[sql_name = <span class="string">"foo"</span>]
    </span><span class="kw">fn </span>foo_1&lt;A, B1, C1&gt;(a: A, b_1: B1, c_1: C1) -&gt; Text;

    <span class="attr">#[sql_name = <span class="string">"foo"</span>]
    </span><span class="kw">fn </span>foo_2&lt;A, B1, C1, B2, C2&gt;(a: A, b_1: B1, c_1: C1, b_2: B2, c_2: C2) -&gt; Text;

    ...
}</code></pre></div><h4 id="controlling-the-generation-of-variadic-function-variants"><a class="doc-anchor" href="#controlling-the-generation-of-variadic-function-variants">§</a>Controlling the generation of variadic function variants</h4>
<p>By default, only variants with 0, 1, and 2 repetitions of variadic arguments are generated. To
generate more variants, set the <code>DIESEL_VARIADIC_FUNCTION_ARGS</code> environment variable to the
desired number of variants.</p>
<p>• The boolean only affects whether the 0 variant is generated; the total number of variants
(e.g., up to N) still follows DIESEL_VARIADIC_FUNCTION_ARGS or the default.</p>
<p>For a greater convenience this environment variable can also be set in a <code>.cargo/config.toml</code>
file as described in the <a href="https://doc.rust-lang.org/cargo/reference/config.html#env">cargo documentation</a>.</p>
<h3 id="helper-types-generation"><a class="doc-anchor" href="#helper-types-generation">§</a>Helper types generation</h3>
<p>When the <code>generate_return_type_helpers</code> attribute is specified, for each function defined inside
an <code>extern "SQL"</code> block, a return type alias with the same name as the function is created and
placed in the <code>return_type_helpers</code> module:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function(generate_return_type_helpers = <span class="bool-val">true</span>)]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="kw">fn </span>f&lt;V: SqlType + SingleValue&gt;(arg: V);
}

<span class="kw">type </span>return_type_helper_for_f&lt;V&gt; = return_type_helpers::f&lt;V&gt;;</code></pre></div>
<p>If you want to skip generating a type alias for a specific function, you can use the
<code>#[skip_return_type_helper]</code> attribute, like this:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[declare_sql_function(generate_return_type_helpers = <span class="bool-val">true</span>)]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="attr">#[skip_return_type_helper]
    </span><span class="kw">fn </span>f();
}
</code></pre></div><h2 id="expanded-code"><a class="doc-anchor" href="#expanded-code">§</a>Expanded Code</h2><details>
<summary> Expanded Code </summary>
<h5 id="input"><a class="doc-anchor" href="#input">§</a>Input</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[diesel::declare_sql_function]
</span><span class="kw">extern </span><span class="string">"SQL" </span>{
    <span class="kw">fn </span>lower(input: Text) -&gt; Text;
}</code></pre></div><h5 id="expanded-code-1"><a class="doc-anchor" href="#expanded-code-1">§</a>Expanded Code</h5><div class="warning">Expanded code might use diesel internal API's and is only shown for educational purpose</div>
<p>The macro expands the input to the following Rust code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[allow(non_camel_case_types)]
</span><span class="kw">pub fn </span>lower&lt;input&gt;(input: input) -&gt; lower&lt;input&gt;
<span class="kw">where
    </span>input: diesel::expression::AsExpression&lt;Text&gt;,
{
    lower_utils::lower {
        input: input.as_expression(),
    }
}
<span class="attr">#[allow(non_camel_case_types, non_snake_case)]
</span><span class="doccomment">///The return type of [`lower()`](fn@lower)
</span><span class="kw">pub type </span>lower&lt;input&gt; = lower_utils::lower&lt;
    &lt;input <span class="kw">as </span>diesel::expression::AsExpression&lt;Text&gt;&gt;::Expression,
&gt;;
<span class="attr">#[doc(hidden)]
#[allow(non_camel_case_types, non_snake_case, unused_imports)]
</span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">mod </span>lower_utils {
    <span class="kw">use </span>diesel::{<span class="self">self</span>, QueryResult};
    <span class="kw">use </span>diesel::expression::{
        AsExpression, Expression, SelectableExpression, AppearsOnTable, ValidGrouping,
    };
    <span class="kw">use </span>diesel::query_builder::{QueryFragment, AstPass};
    <span class="kw">use </span>diesel::sql_types::<span class="kw-2">*</span>;
    <span class="kw">use </span>diesel::internal::sql_functions::<span class="kw-2">*</span>;
    <span class="kw">use </span>super::<span class="kw-2">*</span>;
    <span class="attr">#[derive(Debug, Clone, Copy, diesel::query_builder::QueryId)]
    #[derive(diesel::sql_types::DieselNumericOps)]
    </span><span class="kw">pub struct </span>lower&lt;input&gt; {
        <span class="kw">pub</span>(<span class="kw">super</span>) input: input,
    }
    <span class="doccomment">///The return type of [`lower()`](fn@lower)
    </span><span class="kw">pub type </span>HelperType&lt;input&gt; = lower&lt;&lt;input <span class="kw">as </span>AsExpression&lt;Text&gt;&gt;::Expression&gt;;
    <span class="kw">impl</span>&lt;input&gt; Expression <span class="kw">for </span>lower&lt;input&gt;
    <span class="kw">where
        </span>(input): Expression,
    {
        <span class="kw">type </span>SqlType = Text;
    }
    <span class="kw">impl</span>&lt;input, __DieselInternal&gt; SelectableExpression&lt;__DieselInternal&gt; <span class="kw">for </span>lower&lt;input&gt;
    <span class="kw">where
        </span>input: SelectableExpression&lt;__DieselInternal&gt;,
        <span class="self">Self</span>: AppearsOnTable&lt;__DieselInternal&gt;,
    {}
    <span class="kw">impl</span>&lt;input, __DieselInternal&gt; AppearsOnTable&lt;__DieselInternal&gt; <span class="kw">for </span>lower&lt;input&gt;
    <span class="kw">where
        </span>input: AppearsOnTable&lt;__DieselInternal&gt;,
        <span class="self">Self</span>: Expression,
    {}
    <span class="kw">impl</span>&lt;input, __DieselInternal&gt; FunctionFragment&lt;__DieselInternal&gt; <span class="kw">for </span>lower&lt;input&gt;
    <span class="kw">where
        </span>__DieselInternal: diesel::backend::Backend,
        input: QueryFragment&lt;__DieselInternal&gt;,
    {
        <span class="kw">const </span>FUNCTION_NAME: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">"lower"</span>;
        <span class="attr">#[allow(unused_assignments)]
        </span><span class="kw">fn </span>walk_arguments&lt;<span class="lifetime">'__b</span>&gt;(
            <span class="kw-2">&amp;</span><span class="lifetime">'__b </span><span class="self">self</span>,
            <span class="kw-2">mut </span>out: AstPass&lt;<span class="lifetime">'_</span>, <span class="lifetime">'__b</span>, __DieselInternal&gt;,
        ) -&gt; QueryResult&lt;()&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>needs_comma = <span class="bool-val">false</span>;
            <span class="kw">if </span>!<span class="self">self</span>.input.is_noop(out.backend())<span class="question-mark">? </span>{
                <span class="kw">if </span>needs_comma {
                    out.push_sql(<span class="string">", "</span>);
                }
                <span class="self">self</span>.input.walk_ast(out.reborrow())<span class="question-mark">?</span>;
                needs_comma = <span class="bool-val">true</span>;
            }
            <span class="prelude-val">Ok</span>(())
        }
    }
    <span class="kw">impl</span>&lt;input, __DieselInternal&gt; QueryFragment&lt;__DieselInternal&gt; <span class="kw">for </span>lower&lt;input&gt;
    <span class="kw">where
        </span>__DieselInternal: diesel::backend::Backend,
        input: QueryFragment&lt;__DieselInternal&gt;,
    {
        <span class="kw">fn </span>walk_ast&lt;<span class="lifetime">'__b</span>&gt;(
            <span class="kw-2">&amp;</span><span class="lifetime">'__b </span><span class="self">self</span>,
            <span class="kw-2">mut </span>out: AstPass&lt;<span class="lifetime">'_</span>, <span class="lifetime">'__b</span>, __DieselInternal&gt;,
        ) -&gt; QueryResult&lt;()&gt; {
            out.push_sql(&lt;<span class="self">Self </span><span class="kw">as </span>FunctionFragment&lt;__DieselInternal&gt;&gt;::FUNCTION_NAME);
            out.push_sql(<span class="string">"("</span>);
            <span class="self">self</span>.walk_arguments(out.reborrow())<span class="question-mark">?</span>;
            out.push_sql(<span class="string">")"</span>);
            <span class="prelude-val">Ok</span>(())
        }
    }
    <span class="attr">#[derive(ValidGrouping)]
    </span><span class="kw">pub struct </span>__Derived&lt;input&gt;(input);
    <span class="kw">impl</span>&lt;input, __DieselInternal&gt; ValidGrouping&lt;__DieselInternal&gt; <span class="kw">for </span>lower&lt;input&gt;
    <span class="kw">where
        </span>__Derived&lt;input&gt;: ValidGrouping&lt;__DieselInternal&gt;,
    {
        <span class="kw">type </span>IsAggregate = &lt;__Derived&lt;
            input,
        &gt; <span class="kw">as </span>ValidGrouping&lt;__DieselInternal&gt;&gt;::IsAggregate;
    }
    <span class="kw">use </span>diesel::sqlite::{Sqlite, SqliteConnection};
    <span class="kw">use </span>diesel::serialize::ToSql;
    <span class="kw">use </span>diesel::deserialize::{FromSqlRow, StaticallySizedRow};
    <span class="attr">#[allow(dead_code)]
    </span><span class="doccomment">/// Registers an implementation for this function on the given connection
    ///
    /// This function must be called for every `SqliteConnection` before
    /// this SQL function can be used on SQLite. The implementation must be
    /// deterministic (returns the same result given the same arguments). If
    /// the function is nondeterministic, call
    /// `register_nondeterministic_impl` instead.
    </span><span class="kw">pub fn </span>register_impl&lt;F, Ret, input&gt;(
        conn: <span class="kw-2">&amp;mut </span>SqliteConnection,
        f: F,
    ) -&gt; QueryResult&lt;()&gt;
    <span class="kw">where
        </span>F: Fn(input) -&gt; Ret + ::core::panic::UnwindSafe + Send + <span class="lifetime">'static</span>,
        (input,): FromSqlRow&lt;(Text,), Sqlite&gt; + StaticallySizedRow&lt;(Text,), Sqlite&gt;,
        Ret: ToSql&lt;Text, Sqlite&gt;,
    {
        conn.register_sql_function::&lt;
                (Text,),
                Text,
                <span class="kw">_</span>,
                <span class="kw">_</span>,
                <span class="kw">_</span>,
            &gt;(<span class="string">"lower"</span>, <span class="bool-val">true</span>, <span class="kw">move </span>|(input,)| f(input))
    }
    <span class="attr">#[allow(dead_code)]
    </span><span class="doccomment">/// Registers an implementation for this function on the given connection
    ///
    /// This function must be called for every `SqliteConnection` before
    /// this SQL function can be used on SQLite.
    /// `register_nondeterministic_impl` should only be used if your
    /// function can return different results with the same arguments (e.g.
    /// `random`). If your function is deterministic, you should call
    /// `register_impl` instead.
    </span><span class="kw">pub fn </span>register_nondeterministic_impl&lt;F, Ret, input&gt;(
        conn: <span class="kw-2">&amp;mut </span>SqliteConnection,
        <span class="kw-2">mut </span>f: F,
    ) -&gt; QueryResult&lt;()&gt;
    <span class="kw">where
        </span>F: FnMut(input) -&gt; Ret + ::core::panic::UnwindSafe + Send + <span class="lifetime">'static</span>,
        (input,): FromSqlRow&lt;(Text,), Sqlite&gt; + StaticallySizedRow&lt;(Text,), Sqlite&gt;,
        Ret: ToSql&lt;Text, Sqlite&gt;,
    {
        conn.register_sql_function::&lt;
                (Text,),
                Text,
                <span class="kw">_</span>,
                <span class="kw">_</span>,
                <span class="kw">_</span>,
            &gt;(<span class="string">"lower"</span>, <span class="bool-val">false</span>, <span class="kw">move </span>|(input,)| f(input))
    }
}</code></pre></div></details></div></details></section></div></main></body></html>