<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a native implementation of regular expressions that is heavily based on RE2 both in syntax and in implementation. Notably, backreferences and arbitrary lookahead&#x2F;lookbehind assertions are not provided. In return, regular expression searching provided by this package has excellent worst-case performance. The specific syntax supported is documented further down."><meta name="keywords" content="rust, rustlang, rust-lang, regex"><title>regex - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="https:&#x2F;&#x2F;www.rust-lang.org&#x2F;favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../regex/index.html'><div class='logo-container rust-logo'><img src='https:&#x2F;&#x2F;www.rust-lang.org&#x2F;logos&#x2F;rust-logo-128x128-blk-v2.png' alt='logo'></div></a><h2 class="location">Crate regex</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.1.80</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all regex's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="regex" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">regex</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/regex/lib.rs.html#11-606" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a native implementation of regular expressions that is
heavily based on RE2 both in syntax and in implementation. Notably,
backreferences and arbitrary lookahead/lookbehind assertions are not
provided. In return, regular expression searching provided by this package
has excellent worst-case performance. The specific syntax supported is
documented further down.</p>
<p>This crate’s documentation provides some simple examples, describes Unicode
support and exhaustively lists the supported syntax. For more specific
details on the API, please see the documentation for the
<a href="struct.Regex.html"><code>Regex</code></a> type.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>This crate is <a href="https://crates.io/crates/regex">on crates.io</a> and can be
used by adding <code>regex</code> to your dependencies in your project’s <code>Cargo.toml</code>.</p>
<div class="example-wrap"><pre class="language-toml">[dependencies]
regex = &quot;0.1&quot;</pre></div>
<p>and this to your crate root:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">regex</span>;</pre></div>
<h1 id="example-find-a-date" class="section-header"><a href="#example-find-a-date">Example: find a date</a></h1>
<p>General use of regular expressions in this package involves compiling an
expression and then using it to search, split or replace text. For example,
to confirm that some text resembles a date:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">regex::Regex</span>;
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;^\d{4}-\d{2}-\d{2}$&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert!</span>(<span class="ident">re</span>.<span class="ident">is_match</span>(<span class="string">&quot;2014-01-01&quot;</span>));</pre></div>
<p>Notice the use of the <code>^</code> and <code>$</code> anchors. In this crate, every expression
is executed with an implicit <code>.*?</code> at the beginning and end, which allows
it to match anywhere in the text. Anchors can be used to ensure that the
full text matches an expression.</p>
<p>This example also demonstrates the utility of
<a href="https://doc.rust-lang.org/stable/reference.html#raw-string-literals">raw strings</a>
in Rust, which
are just like regular strings except they are prefixed with an <code>r</code> and do
not process any escape sequences. For example, <code>&quot;\\d&quot;</code> is the same
expression as <code>r&quot;\d&quot;</code>.</p>
<h1 id="example-avoid-compiling-the-same-regex-in-a-loop" class="section-header"><a href="#example-avoid-compiling-the-same-regex-in-a-loop">Example: Avoid compiling the same regex in a loop</a></h1>
<p>It is an anti-pattern to compile the same regular expression in a loop
since compilation is typically expensive. (It takes anywhere from a few
microseconds to a few <strong>milliseconds</strong> depending on the size of the
regex.) Not only is compilation itself expensive, but this also prevents
optimizations that reuse allocations internally to the matching engines.</p>
<p>In Rust, it can sometimes be a pain to pass regular expressions around if
they’re used from inside a helper function. Instead, we recommend using the
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> crate to ensure that
regular expressions are compiled exactly once.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span> <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">lazy_static</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">regex</span>;

<span class="kw">use</span> <span class="ident">regex::Regex</span>;

<span class="kw">fn</span> <span class="ident">some_helper_function</span>(<span class="ident">text</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
    <span class="macro">lazy_static!</span> {
        <span class="kw">static</span> <span class="kw-2">ref</span> <span class="ident">RE</span>: <span class="ident">Regex</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">&quot;...&quot;</span>).<span class="ident">unwrap</span>();
    }
    <span class="ident">RE</span>.<span class="ident">is_match</span>(<span class="ident">text</span>)
}

<span class="kw">fn</span> <span class="ident">main</span>() {}</pre></div>
<p>Specifically, in this example, the regex will be compiled when it is used for
the first time. On subsequent uses, it will reuse the previous compilation.</p>
<h1 id="example-iterating-over-capture-groups" class="section-header"><a href="#example-iterating-over-capture-groups">Example: iterating over capture groups</a></h1>
<p>This crate provides convenient iterators for matching an expression
repeatedly against a search string to find successive non-overlapping
matches. For example, to find all dates in a string and be able to access
them by their component pieces:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(\d{4})-(\d{2})-(\d{2})&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;</span>;
<span class="kw">for</span> <span class="ident">cap</span> <span class="kw">in</span> <span class="ident">re</span>.<span class="ident">captures_iter</span>(<span class="ident">text</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Month: {} Day: {} Year: {}&quot;</span>,
             <span class="ident">cap</span>.<span class="ident">at</span>(<span class="number">2</span>).<span class="ident">unwrap_or</span>(<span class="string">&quot;&quot;</span>), <span class="ident">cap</span>.<span class="ident">at</span>(<span class="number">3</span>).<span class="ident">unwrap_or</span>(<span class="string">&quot;&quot;</span>),
             <span class="ident">cap</span>.<span class="ident">at</span>(<span class="number">1</span>).<span class="ident">unwrap_or</span>(<span class="string">&quot;&quot;</span>));
}
<span class="comment">// Output:</span>
<span class="comment">// Month: 03 Day: 14 Year: 2012</span>
<span class="comment">// Month: 01 Day: 01 Year: 2013</span>
<span class="comment">// Month: 07 Day: 05 Year: 2014</span></pre></div>
<p>Notice that the year is in the capture group indexed at <code>1</code>. This is
because the <em>entire match</em> is stored in the capture group at index <code>0</code>.</p>
<h1 id="example-replacement-with-named-capture-groups" class="section-header"><a href="#example-replacement-with-named-capture-groups">Example: replacement with named capture groups</a></h1>
<p>Building on the previous example, perhaps we’d like to rearrange the date
formats. This can be done with text replacement. But to make the code
clearer, we can <em>name</em>  our capture groups and use those names as variables
in our replacement text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?P&lt;y&gt;\d{4})-(?P&lt;m&gt;\d{2})-(?P&lt;d&gt;\d{2})&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">before</span> <span class="op">=</span> <span class="string">&quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;</span>;
<span class="kw">let</span> <span class="ident">after</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">replace_all</span>(<span class="ident">before</span>, <span class="string">&quot;$m/$d/$y&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">after</span>, <span class="string">&quot;03/14/2012, 01/01/2013 and 07/05/2014&quot;</span>);</pre></div>
<p>The <code>replace</code> methods are actually polymorphic in the replacement, which
provides more flexibility than is seen here. (See the documentation for
<code>Regex::replace</code> for more details.)</p>
<p>Note that if your regex gets complicated, you can use the <code>x</code> flag to
enable insigificant whitespace mode, which also lets you write comments:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?x)
  (?P&lt;y&gt;\d{4}) # the year
  -
  (?P&lt;m&gt;\d{2}) # the month
  -
  (?P&lt;d&gt;\d{2}) # the day
&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">before</span> <span class="op">=</span> <span class="string">&quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;</span>;
<span class="kw">let</span> <span class="ident">after</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">replace_all</span>(<span class="ident">before</span>, <span class="string">&quot;$m/$d/$y&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">after</span>, <span class="string">&quot;03/14/2012, 01/01/2013 and 07/05/2014&quot;</span>);</pre></div>
<h1 id="example-match-multiple-regular-expressions-simultaneously" class="section-header"><a href="#example-match-multiple-regular-expressions-simultaneously">Example: match multiple regular expressions simultaneously</a></h1>
<p>This demonstrates how to use a <code>RegexSet</code> to match multiple (possibly
overlapping) regular expressions in a single scan of the search text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">regex::RegexSet</span>;

<span class="kw">let</span> <span class="ident">set</span> <span class="op">=</span> <span class="ident">RegexSet::new</span>(<span class="kw-2">&amp;</span>[
    <span class="string">r&quot;\w+&quot;</span>,
    <span class="string">r&quot;\d+&quot;</span>,
    <span class="string">r&quot;\pL+&quot;</span>,
    <span class="string">r&quot;foo&quot;</span>,
    <span class="string">r&quot;bar&quot;</span>,
    <span class="string">r&quot;barfoo&quot;</span>,
    <span class="string">r&quot;foobar&quot;</span>,
]).<span class="ident">unwrap</span>();

<span class="comment">// Iterate over and collect all of the matches.</span>
<span class="kw">let</span> <span class="ident">matches</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">set</span>.<span class="ident">matches</span>(<span class="string">&quot;foobar&quot;</span>).<span class="ident">into_iter</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">matches</span>, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]);

<span class="comment">// You can also test whether a particular regex matched:</span>
<span class="kw">let</span> <span class="ident">matches</span> <span class="op">=</span> <span class="ident">set</span>.<span class="ident">matches</span>(<span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">matches</span>.<span class="ident">matched</span>(<span class="number">5</span>));
<span class="macro">assert!</span>(<span class="ident">matches</span>.<span class="ident">matched</span>(<span class="number">6</span>));</pre></div>
<h1 id="pay-for-what-you-use" class="section-header"><a href="#pay-for-what-you-use">Pay for what you use</a></h1>
<p>With respect to searching text with a regular expression, there are three
questions that can be asked:</p>
<ol>
<li>Does the text match this expression?</li>
<li>If so, where does it match?</li>
<li>Where are the submatches?</li>
</ol>
<p>Generally speaking, this crate could provide a function to answer only #3,
which would subsume #1 and #2 automatically. However, it can be
significantly more expensive to compute the location of submatches, so it’s
best not to do it if you don’t need to.</p>
<p>Therefore, only use what you need. For example, don’t use <code>find</code> if you
only need to test if an expression matches a string. (Use <code>is_match</code>
instead.)</p>
<h1 id="unicode" class="section-header"><a href="#unicode">Unicode</a></h1>
<p>This implementation executes regular expressions <strong>only</strong> on valid UTF-8
while exposing match locations as byte indices into the search string.</p>
<p>Only simple case folding is supported. Namely, when matching
case-insensitively, the characters are first mapped using the <a href="ftp://ftp.unicode.org/Public/UNIDATA/CaseFolding.txt">simple case
folding</a> mapping
before matching.</p>
<p>Regular expressions themselves are <strong>only</strong> interpreted as a sequence of
Unicode scalar values. This means you can use Unicode characters directly
in your expression:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?i)Δ+&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">re</span>.<span class="ident">find</span>(<span class="string">&quot;ΔδΔ&quot;</span>), <span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="number">6</span>)));</pre></div>
<p>Finally, Unicode general categories and scripts are available as character
classes. For example, you can match a sequence of numerals, Greek or
Cherokee letters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;[\pN\p{Greek}\p{Cherokee}]+&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">re</span>.<span class="ident">find</span>(<span class="string">&quot;abcΔᎠβⅠᏴγδⅡxyz&quot;</span>), <span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="number">23</span>)));</pre></div>
<h1 id="opt-out-of-unicode-support" class="section-header"><a href="#opt-out-of-unicode-support">Opt out of Unicode support</a></h1>
<p>The <code>bytes</code> sub-module provides a <code>Regex</code> type that can be used to match
on <code>&amp;[u8]</code>. By default, text is interpreted as ASCII compatible text with
all Unicode support disabled (e.g., <code>.</code> matches any byte instead of any
Unicode codepoint). Unicode support can be selectively enabled with the
<code>u</code> flag. See the <code>bytes</code> module documentation for more details.</p>
<p>Unicode support can also be selectively <em>disabled</em> with the main <code>Regex</code>
type that matches on <code>&amp;str</code>. For example, <code>(?-u:\b)</code> will match an ASCII
word boundary. Note though that invalid UTF-8 is not allowed to be matched
even when the <code>u</code> flag is disabled. For example, <code>(?-u:.)</code> will return an
error, since <code>.</code> matches <em>any byte</em> when Unicode support is disabled.</p>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>The syntax supported in this crate is almost in an exact correspondence
with the syntax supported by RE2. It is documented below.</p>
<p>Note that the regular expression parser and abstract syntax are exposed in
a separate crate, <a href="../regex_syntax/index.html"><code>regex-syntax</code></a>.</p>
<h2 id="matching-one-character" class="section-header"><a href="#matching-one-character">Matching one character</a></h2><pre class="rust">
.           any character except new line (includes new line with s flag)
[xyz]       A character class matching either x, y or z.
[^xyz]      A character class matching any character except x, y and z.
[a-z]       A character class matching any character in range a-z.
\d          digit (\p{Nd})
\D          not digit
[:alpha:]   ASCII character class ([A-Za-z])
[:^alpha:]  Negated ASCII character class ([^A-Za-z])
\pN         One-letter name Unicode character class
\p{Greek}   Unicode character class (general category or script)
\PN         Negated one-letter name Unicode character class
\P{Greek}   negated Unicode character class (general category or script)
</pre>
<p>Any named character class may appear inside a bracketed <code>[...]</code> character
class. For example, <code>[\p{Greek}\pN]</code> matches any Greek or numeral
character.</p>
<h2 id="composites" class="section-header"><a href="#composites">Composites</a></h2><pre class="rust">
xy    concatenation (x followed by y)
x|y   alternation (x or y, prefer x)
</pre>
<h2 id="repetitions" class="section-header"><a href="#repetitions">Repetitions</a></h2><pre class="rust">
x*        zero or more of x (greedy)
x+        one or more of x (greedy)
x?        zero or one of x (greedy)
x*?       zero or more of x (ungreedy/lazy)
x+?       one or more of x (ungreedy/lazy)
x??       zero or one of x (ungreedy/lazy)
x{n,m}    at least n x and at most m x (greedy)
x{n,}     at least n x (greedy)
x{n}      exactly n x
x{n,m}?   at least n x and at most m x (ungreedy/lazy)
x{n,}?    at least n x (ungreedy/lazy)
x{n}?     exactly n x
</pre>
<h2 id="empty-matches" class="section-header"><a href="#empty-matches">Empty matches</a></h2><pre class="rust">
^     the beginning of text (or start-of-line with multi-line mode)
$     the end of text (or end-of-line with multi-line mode)
\A    only the beginning of text (even with multi-line mode enabled)
\z    only the end of text (even with multi-line mode enabled)
\b    a Unicode word boundary (\w on one side and \W, \A, or \z on other)
\B    not a Unicode word boundary
</pre>
<h2 id="grouping-and-flags" class="section-header"><a href="#grouping-and-flags">Grouping and flags</a></h2><pre class="rust">
(exp)          numbered capture group (indexed by opening parenthesis)
(?P&lt;name&gt;exp)  named (also numbered) capture group (allowed chars: [_0-9a-zA-Z])
(?:exp)        non-capturing group
(?flags)       set flags within current group
(?flags:exp)   set flags for exp (non-capturing)
</pre>
<p>Flags are each a single character. For example, <code>(?x)</code> sets the flag <code>x</code>
and <code>(?-x)</code> clears the flag <code>x</code>. Multiple flags can be set or cleared at
the same time: <code>(?xy)</code> sets both the <code>x</code> and <code>y</code> flags and <code>(?x-y)</code> sets
the <code>x</code> flag and clears the <code>y</code> flag.</p>
<p>All flags are by default disabled unless stated otherwise. They are:</p>
<pre class="rust">
i     case-insensitive
m     multi-line mode: ^ and $ match begin/end of line
s     allow . to match \n
U     swap the meaning of x* and x*?
u     Unicode support (enabled by default)
x     ignore whitespace and allow line comments (starting with `#`)
</pre>
<p>Here’s an example that matches case-insensitively for only part of the
expression:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?i)a+(?-i)b+&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">cap</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">captures</span>(<span class="string">&quot;AaAaAbbBBBb&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">cap</span>.<span class="ident">at</span>(<span class="number">0</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;AaAaAbb&quot;</span>));</pre></div>
<p>Notice that the <code>a+</code> matches either <code>a</code> or <code>A</code>, but the <code>b+</code> only matches
<code>b</code>.</p>
<p>Here is an example that uses an ASCII word boundary instead of a Unicode
word boundary:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">re</span> <span class="op">=</span> <span class="ident">Regex::new</span>(<span class="string">r&quot;(?-u:\b).+(?-u:\b)&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">cap</span> <span class="op">=</span> <span class="ident">re</span>.<span class="ident">captures</span>(<span class="string">&quot;$$abc$$&quot;</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">cap</span>.<span class="ident">at</span>(<span class="number">0</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;abc&quot;</span>));</pre></div>
<h2 id="escape-sequences" class="section-header"><a href="#escape-sequences">Escape sequences</a></h2><pre class="rust">
\*         literal *, works for any punctuation character: \.+*?()|[]{}^$
\a         bell (\x07)
\f         form feed (\x0C)
\t         horizontal tab
\n         new line
\r         carriage return
\v         vertical tab (\x0B)
\123       octal character code (up to three digits)
\x7F       hex character code (exactly two digits)
\x{10FFFF} any hex character code corresponding to a Unicode code point
</pre>
<h2 id="perl-character-classes-unicode-friendly" class="section-header"><a href="#perl-character-classes-unicode-friendly">Perl character classes (Unicode friendly)</a></h2>
<p>These classes are based on the definitions provided in
<a href="http://www.unicode.org/reports/tr18/#Compatibility_Properties">UTS#18</a>:</p>
<pre class="rust">
\d     digit (\p{Nd})
\D     not digit
\s     whitespace (\p{White_Space})
\S     not whitespace
\w     word character (\p{Alphabetic} + \p{M} + \d + \p{Pc} + \p{Join_Control})
\W     not word character
</pre>
<h2 id="ascii-character-classes" class="section-header"><a href="#ascii-character-classes">ASCII character classes</a></h2><pre class="rust">
[:alnum:]    alphanumeric ([0-9A-Za-z])
[:alpha:]    alphabetic ([A-Za-z])
[:ascii:]    ASCII ([\x00-\x7F])
[:blank:]    blank ([\t ])
[:cntrl:]    control ([\x00-\x1F\x7F])
[:digit:]    digits ([0-9])
[:graph:]    graphical ([!-~])
[:lower:]    lower case ([a-z])
[:print:]    printable ([ -~])
[:punct:]    punctuation ([!-/:-@[-`{-~])
[:space:]    whitespace ([\t\n\v\f\r ])
[:upper:]    upper case ([A-Z])
[:word:]     word characters ([0-9A-Za-z_])
[:xdigit:]   hex digit ([0-9A-Fa-f])
</pre>
<h1 id="untrusted-input" class="section-header"><a href="#untrusted-input">Untrusted input</a></h1>
<p>This crate can handle both untrusted regular expressions and untrusted
search text.</p>
<p>Untrusted regular expressions are handled by capping the size of a compiled
regular expression. (See <code>Regex::with_size_limit</code>.) Without this, it would
be trivial for an attacker to exhaust your system’s memory with expressions
like <code>a{100}{100}{100}</code>.</p>
<p>Untrusted search text is allowed because the matching engine(s) in this
crate have time complexity <code>O(mn)</code> (with <code>m ~ regex</code> and <code>n ~ search text</code>), which means there’s no way to cause exponential blow-up like with
some other regular expression engines. (We pay for this by disallowing
features like arbitrary look-ahead and backreferences.)</p>
<p>When a DFA is used, pathological cases with exponential state blow up are
avoided by constructing the DFA lazily or in an “online” manner. Therefore,
at most one new state can be created for each byte of input. This satisfies
our time complexity guarantees, but can lead to unbounded memory growth
proportional to the size of the input. As a stopgap, the DFA is only
allowed to store a fixed number of states. (When the limit is reached, its
states are wiped and continues on, possibly duplicating previous work. If
the limit is reached too frequently, it gives up and hands control off to
another matching engine with fixed memory requirements.)</p>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="bytes/index.html" title="regex::bytes mod">bytes</a></div><div class="item-right docblock-short"><p>Match regular expressions on arbitrary bytes.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.CaptureNames.html" title="regex::CaptureNames struct">CaptureNames</a></div><div class="item-right docblock-short"><p>An iterator over the names of all possible captures.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Captures.html" title="regex::Captures struct">Captures</a></div><div class="item-right docblock-short"><p>Captures represents a group of captured strings for a single match.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.FindCaptures.html" title="regex::FindCaptures struct">FindCaptures</a></div><div class="item-right docblock-short"><p>An iterator that yields all non-overlapping capture groups matching a
particular regular expression.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.FindMatches.html" title="regex::FindMatches struct">FindMatches</a></div><div class="item-right docblock-short"><p>An iterator over all non-overlapping matches for a particular string.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.NoExpand.html" title="regex::NoExpand struct">NoExpand</a></div><div class="item-right docblock-short"><p>NoExpand indicates literal string replacement.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.Regex.html" title="regex::Regex struct">Regex</a></div><div class="item-right docblock-short"><p>A compiled regular expression for matching Unicode strings.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.RegexBuilder.html" title="regex::RegexBuilder struct">RegexBuilder</a></div><div class="item-right docblock-short"><p>A configurable builder for a regular expression.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.RegexSet.html" title="regex::RegexSet struct">RegexSet</a></div><div class="item-right docblock-short"><p>Match multiple (possibly overlapping) regular expressions in a single scan.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.RegexSplits.html" title="regex::RegexSplits struct">RegexSplits</a></div><div class="item-right docblock-short"><p>Yields all substrings delimited by a regular expression match.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.RegexSplitsN.html" title="regex::RegexSplitsN struct">RegexSplitsN</a></div><div class="item-right docblock-short"><p>Yields at most <code>N</code> substrings delimited by a regular expression match.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SetMatches.html" title="regex::SetMatches struct">SetMatches</a></div><div class="item-right docblock-short"><p>A set of matches returned by a regex set.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SetMatchesIntoIter.html" title="regex::SetMatchesIntoIter struct">SetMatchesIntoIter</a></div><div class="item-right docblock-short"><p>An owned iterator over the set of matches from a regex set.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SetMatchesIter.html" title="regex::SetMatchesIter struct">SetMatchesIter</a></div><div class="item-right docblock-short"><p>A borrowed iterator over the set of matches from a regex set.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SubCaptures.html" title="regex::SubCaptures struct">SubCaptures</a></div><div class="item-right docblock-short"><p>An iterator over capture groups for a particular match of a regular
expression.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SubCapturesNamed.html" title="regex::SubCapturesNamed struct">SubCapturesNamed</a></div><div class="item-right docblock-short"><p>An Iterator over named capture groups as a tuple with the group
name and the value.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.SubCapturesPos.html" title="regex::SubCapturesPos struct">SubCapturesPos</a></div><div class="item-right docblock-short"><p>An iterator over capture group positions for a particular match of a
regular expression.</p>
</div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="regex::Error enum">Error</a></div><div class="item-right docblock-short"><p>An error that occurred during parsing or compiling a regular expression.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.Replacer.html" title="regex::Replacer trait">Replacer</a></div><div class="item-right docblock-short"><p>Replacer describes types that can be used to replace matches in a string.</p>
</div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="fn" href="fn.is_match.html" title="regex::is_match fn">is_match</a></div><div class="item-right docblock-short"><p>Tests if the given regular expression matches somewhere in the text given.</p>
</div><div class="item-left module-item"><a class="fn" href="fn.quote.html" title="regex::quote fn">quote</a></div><div class="item-right docblock-short"><p>Escapes all regular expression meta characters in <code>text</code>.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="regex" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>