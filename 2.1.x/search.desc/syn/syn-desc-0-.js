searchState.loadedDescShard("syn", 0, "github crates-io docs-rs\nThe binary interface of a function: <code>extern &quot;C&quot;</code>.\nThe <code>+</code> operator (addition)\nThe <code>+=</code> operator\nThe <code>&amp;&amp;</code> operator (logical and)\nThe <code>&lt;&#39;a, T&gt;</code> in <code>std::slice::iter&lt;&#39;a, T&gt;</code>.\nAngle bracketed arguments of a path segment: the <code>&lt;K, V&gt;</code> in …\nOne arm of a <code>match</code> expression: <code>0..=10 =&gt; { return true; }</code>.\nA slice literal expression: <code>[a, b, c, d]</code>.\nA fixed size array type: <code>[T; n]</code>.\nAn assignment expression: <code>a = compute()</code>.\nAn equality constraint on an associated constant: the …\nAn equality constraint on an associated constant: the …\nA binding (equality constraint) on an associated type: the …\nA binding (equality constraint) on an associated type: the …\nAn async block: <code>async { ... }</code>.\nDistinguishes between attributes that decorate an item and …\nAn attribute, like <code>#[repr(transparent)]</code>.\nAn await expression: <code>fut.await</code>.\nA bare function type: <code>fn(usize) -&gt; bool</code>.\nAn argument in a function type: the <code>usize</code> in …\nThe variadic argument of a function pointer like …\nA binary operator: <code>+</code>, <code>+=</code>, <code>&amp;</code>.\nA binary operation: <code>a + b</code>, <code>a += b</code>.\nThe <code>&amp;</code> operator (bitwise and)\nThe <code>&amp;=</code> operator\nThe <code>|</code> operator (bitwise or)\nThe <code>|=</code> operator\nThe <code>^</code> operator (bitwise xor)\nThe <code>^=</code> operator\nA braced block containing Rust statements.\nA blocked scope: <code>{ ... }</code>.\nA boolean literal: <code>true</code> or <code>false</code>.\nA set of bound lifetimes: <code>for&lt;&#39;a, &#39;b, &#39;c&gt;</code>.\nA <code>break</code>, with an optional label to break and an optional …\nA byte literal: <code>b&#39;f&#39;</code>.\nA byte string literal: <code>b&quot;foo&quot;</code>.\nA nul-terminated C-string literal: <code>c&quot;foo&quot;</code>.\nA function call expression: <code>invoke(a, b)</code>.\nA cast expression: <code>foo as f64</code>.\nA character literal: <code>&#39;a&#39;</code>.\nInclusive at the beginning and end.\nA closure expression: <code>|a, b| a + b</code>.\nA const block: <code>const { ... }</code>.\nA const generic parameter: <code>const LENGTH: usize</code>.\nA constant item: <code>const MAX: u16 = 65535</code>.\nAn associated constant within the definition of a trait.\nAn associated constant within an impl block.\nA const block: <code>const { ... }</code>.\nA const expression. Must be inside of a block.\nA const generic parameter: <code>const LENGTH: usize</code>.\nAn associated type bound: <code>Iterator&lt;Item: Display&gt;</code>.\nAn associated type bound: <code>Iterator&lt;Item: Display&gt;</code>.\nA <code>continue</code>, with an optional label.\nThe storage of a struct, enum or union data structure.\nAn enum input to a <code>proc_macro_derive</code> macro.\nA struct input to a <code>proc_macro_derive</code> macro.\nAn untagged union input to a <code>proc_macro_derive</code> macro.\nReturn type is not specified.\nThe <code>*</code> operator for dereferencing\nData structure sent to a <code>proc_macro_derive</code> macro.\nThe <code>/</code> operator (division)\nThe <code>/=</code> operator\nAn enum definition: <code>enum Foo&lt;A, B&gt; { A(A), B(B) }</code>.\nThe <code>==</code> operator (equality)\nContains the error value\nError returned when a Syn parser cannot parse the input …\nA Rust expression.\nExpression, with or without trailing semicolon.\nA slice literal expression: <code>[a, b, c, d]</code>.\nAn assignment expression: <code>a = compute()</code>.\nAn async block: <code>async { ... }</code>.\nAn await expression: <code>fut.await</code>.\nA binary operation: <code>a + b</code>, <code>a += b</code>.\nA blocked scope: <code>{ ... }</code>.\nA <code>break</code>, with an optional label to break and an optional …\nA function call expression: <code>invoke(a, b)</code>.\nA cast expression: <code>foo as f64</code>.\nA closure expression: <code>|a, b| a + b</code>.\nA const block: <code>const { ... }</code>.\nA <code>continue</code>, with an optional label.\nAccess of a named struct field (<code>obj.k</code>) or unnamed tuple …\nA for loop: <code>for pat in expr { ... }</code>.\nAn expression contained within invisible delimiters.\nAn <code>if</code> expression with an optional <code>else</code> block: …\nA square bracketed indexing expression: <code>vector[2]</code>.\nThe inferred value of a const generic argument, denoted <code>_</code>.\nA <code>let</code> guard: <code>let Some(x) = opt</code>.\nA literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.\nConditionless loop: <code>loop { ... }</code>.\nA macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.\nA <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.\nA method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.\nA parenthesized expression: <code>(a + b)</code>.\nA path like <code>std::mem::replace</code> possibly containing generic …\nA range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.\nA referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.\nAn array literal constructed from one repeated element: …\nA <code>return</code>, with an optional value to be returned.\nA struct literal expression: <code>Point { x: 1, y: 1 }</code>.\nA try-expression: <code>expr?</code>.\nA try block: <code>try { ... }</code>.\nA tuple expression: <code>(a, b, c, d)</code>.\nA unary operation: <code>!x</code>, <code>*x</code>.\nAn unsafe block: <code>unsafe { ... }</code>.\nA while loop: <code>while expr { ... }</code>.\nA yield expression: <code>yield expr</code>.\nAn <code>extern crate</code> item: <code>extern crate serde</code>.\nA field of a struct or enum variant.\nAccess of a named struct field (<code>obj.k</code>) or unnamed tuple …\nUnused, but reserved for RFC 3323 restrictions.\nA single field in a struct pattern.\nA field-value pair in a struct literal.\nData stored within an enum variant or struct.\nNamed fields of a struct or struct variant such as …\nUnnamed fields of a tuple struct or tuple variant such as …\nA complete file of Rust source code.\nA floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.\nA free-standing function: …\nA foreign function in an <code>extern</code> block.\nAn associated function within the definition of a trait.\nAn associated function within an impl block.\nAn argument in a function signature: the <code>n: usize</code> in …\nA for loop: <code>for pat in expr { ... }</code>.\nAn item within an <code>extern</code> block.\nA foreign function in an <code>extern</code> block.\nA macro invocation within an extern block.\nA foreign static item in an <code>extern</code> block: <code>static ext: u8</code>.\nA foreign type in an <code>extern</code> block: <code>type void</code>.\nA block of foreign items: <code>extern &quot;C&quot; { ... }</code>.\nThe <code>&gt;=</code> operator (greater than or equal to)\nAn individual generic argument, like <code>&#39;a</code>, <code>T</code>, or <code>Item = T</code>.\nA generic type parameter, lifetime, or const generic: …\nLifetimes and type parameters attached to a declaration of …\nA glob import in a <code>use</code> item: <code>*</code>.\nAn expression contained within invisible delimiters.\nA braced group of imports in a <code>use</code> item: <code>{A, B, C}</code>.\nA type contained within invisible delimiters.\nThe <code>&gt;</code> operator (greater than)\nInclusive at the beginning, exclusive at the end.\nA word of Rust code, which may be a keyword or legal …\nA pattern that binds a new variable: …\nAn <code>if</code> expression with an optional <code>else</code> block: …\nAn impl block providing trait or associated items: …\nReturned by <code>Generics::split_for_impl</code>.\nAn item within an impl block.\nAn associated constant within an impl block.\nAn associated function within an impl block.\nA macro invocation within an impl block.\nAn associated type within an impl block.\nUnused, but reserved for RFC 3323 restrictions.\nAn <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a …\nThe index of an unnamed tuple struct field.\nA square bracketed indexing expression: <code>vector[2]</code>.\nThe inferred value of a const generic argument, denoted <code>_</code>.\nIndication that a type should be inferred by the compiler: …\nAn inherited visibility, which usually means private.\nAn integer literal: <code>1</code> or <code>1u16</code>.\nThings that can appear directly inside of a module or …\nAn item definition.\nA constant item: <code>const MAX: u16 = 65535</code>.\nAn enum definition: <code>enum Foo&lt;A, B&gt; { A(A), B(B) }</code>.\nAn <code>extern crate</code> item: <code>extern crate serde</code>.\nA free-standing function: …\nA block of foreign items: <code>extern &quot;C&quot; { ... }</code>.\nAn impl block providing trait or associated items: …\nA macro invocation, which includes <code>macro_rules!</code> …\nA module or module declaration: <code>mod m</code> or <code>mod m { ... }</code>.\nA static item: <code>static BIKE: Shed = Shed(42)</code>.\nA struct definition: <code>struct Foo&lt;A&gt; { x: A }</code>.\nA trait definition: <code>pub trait Iterator { ... }</code>.\nA trait alias: <code>pub trait SharableIterator = Iterator + Sync</code>…\nA type alias: …\nA union definition: <code>union Foo&lt;A, B&gt; { x: A, y: B }</code>.\nA use declaration: <code>use std::collections::HashMap</code>.\nA lifetime labeling a <code>for</code>, <code>while</code>, or <code>loop</code>.\nThe <code>&lt;=</code> operator (less than or equal to)\nA <code>let</code> guard: <code>let Some(x) = opt</code>.\nA Rust lifetime: <code>&#39;a</code>.\nA lifetime parameter: <code>&#39;a: &#39;b + &#39;c + &#39;d</code>.\nA lifetime predicate in a <code>where</code> clause: <code>&#39;a: &#39;b + &#39;c</code>.\nA lifetime argument.\nA lifetime definition: <code>&#39;a: &#39;b + &#39;c + &#39;d</code>.\nA structured list within an attribute, like …\nA Rust literal such as a string or integer or boolean.\nA literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.\nA literal pattern: <code>0</code>.\nA boolean literal: <code>true</code> or <code>false</code>.\nA byte literal: <code>b&#39;f&#39;</code>.\nA byte string literal: <code>b&quot;foo&quot;</code>.\nA nul-terminated C-string literal: <code>c&quot;foo&quot;</code>.\nA character literal: <code>&#39;a&#39;</code>.\nA floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.\nAn integer literal: <code>1</code> or <code>1u16</code>.\nA UTF-8 string literal: <code>&quot;foo&quot;</code>.\nA local <code>let</code> binding: <code>let x: u64 = s.parse()?</code>.\nA local (let) binding.\nThe expression assigned in a local <code>let</code> binding, including …\nConditionless loop: <code>loop { ... }</code>.\nThe <code>&lt;</code> operator (less than)\nA macro invocation: <code>println!(&quot;{}&quot;, mac)</code>.\nA macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.\nA macro invocation, which includes <code>macro_rules!</code> …\nA macro invocation within an extern block.\nA macro invocation within the definition of a trait.\nA macro invocation within an impl block.\nA macro in pattern position.\nA macro invocation in statement position.\nA macro in the type position.\nA grouping token that surrounds a macro body: <code>m!(...)</code> or …\nA <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.\nA struct or tuple struct field accessed in a struct …\nContent of a compile-time structured attribute.\nA structured list within an attribute, like …\nA name-value pair within an attribute, like …\nA method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.\nA module or module declaration: <code>mod m</code> or <code>mod m { ... }</code>.\nThe <code>*</code> operator (multiplication)\nThe <code>*=</code> operator\nAn identifier imported by a <code>use</code> item: <code>HashMap</code>.\nA name-value pair within an attribute, like …\nNamed fields of a struct or struct variant such as …\nA named field like <code>self.x</code>.\nThe <code>!=</code> operator (not equal to)\nThe <code>-</code> operator for negation\nThe never type: <code>!</code>.\nThe <code>!</code> operator for logical inversion\nContains the success value\nThe <code>||</code> operator (logical or)\nA pattern that matches any one of a set of cases.\nA parenthesized expression: <code>(a + b)</code>.\nA parenthesized pattern: <code>(A | B)</code>.\nA parenthesized type equivalent to the inner type.\nThe <code>(A, B) -&gt; C</code> in <code>Fn(A, B) -&gt; C</code>.\nArguments of a function path segment: the <code>(A, B) -&gt; C</code> in …\nA pattern in a local binding, function signature, match …\nA const block: <code>const { ... }</code>.\nA pattern that binds a new variable: …\nA literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.\nA macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.\nA pattern that matches any one of a set of cases.\nA parenthesized pattern: <code>(A | B)</code>.\nA path like <code>std::mem::replace</code> possibly containing generic …\nA range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.\nA reference pattern: <code>&amp;mut var</code>.\nThe dots in a tuple or slice pattern: <code>[0, 1, ..]</code>.\nA dynamically sized slice pattern: <code>[a, b, ref i @ .., y, z]</code>…\nA struct or struct variant pattern: <code>Variant { x, y, .. }</code>.\nA tuple pattern: <code>(a, b)</code>.\nA tuple struct or tuple variant pattern: …\nA type ascription pattern: <code>foo: f64</code>.\nA pattern that matches any value: <code>_</code>.\nA path at which a named item is exported (e.g. …\nA path like <code>std::mem::replace</code> possibly containing generic …\nA path prefix of imports in a <code>use</code> item: <code>std::...</code>.\nA path pattern like <code>Color::Red</code>, optionally qualified with a\nA path like <code>std::slice::Iter</code>, optionally qualified with a …\nAngle bracketed or parenthesized arguments of a path …\nA segment of a path together with any path arguments on …\nA lifetime predicate in a <code>where</code> clause: <code>&#39;a: &#39;b + &#39;c</code>.\nA type predicate in a <code>where</code> clause: …\nA raw pointer type: <code>*const T</code> or <code>*mut T</code>.\nA public visibility level: <code>pub</code>.\nThe explicit Self type in a qualified path: the <code>T</code> in …\nA range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.\nA range pattern: <code>1..=2</code>.\nLimit types of a range, inclusive or exclusive.\nThe <code>self</code> argument of an associated method.\nThe <code>self</code> argument of an associated method.\nA referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.\nA reference pattern: <code>&amp;mut var</code>.\nA reference type: <code>&amp;&#39;a T</code> or <code>&amp;&#39;a mut T</code>.\nThe <code>%</code> operator (modulus)\nThe <code>%=</code> operator\nAn renamed identifier imported by a <code>use</code> item: …\nAn array literal constructed from one repeated element: …\nThe dots in a tuple or slice pattern: <code>[0, 1, ..]</code>.\nA visibility level restricted to some path: <code>pub(self)</code> or …\nThe result of a Syn parser.\nA <code>return</code>, with an optional value to be returned.\nReturn type of a function signature.\nThe <code>&lt;&lt;</code> operator (shift left)\nThe <code>&lt;&lt;=</code> operator\nThe <code>&gt;&gt;</code> operator (shift right)\nThe <code>&gt;&gt;=</code> operator\nA function signature in a trait or implementation: …\nA dynamically sized slice pattern: <code>[a, b, ref i @ .., y, z]</code>…\nA dynamically sized slice type: <code>[T]</code>.\nA static item: <code>static BIKE: Shed = Shed(42)</code>.\nA foreign static item in an <code>extern</code> block: <code>static ext: u8</code>.\nThe mutability of an <code>Item::Static</code> or <code>ForeignItem::Static</code>.\nA statement, usually ending in a semicolon.\nA macro invocation in statement position.\nA UTF-8 string literal: <code>&quot;foo&quot;</code>.\nA struct literal expression: <code>Point { x: 1, y: 1 }</code>.\nA struct definition: <code>struct Foo&lt;A&gt; { x: A }</code>.\nA struct or struct variant pattern: <code>Variant { x, y, .. }</code>.\nThe <code>-</code> operator (subtraction)\nThe <code>-=</code> operator\nA type-macro that expands to the name of the Rust type …\nA trait definition: <code>pub trait Iterator { ... }</code>.\nA trait alias: <code>pub trait SharableIterator = Iterator + Sync</code>…\nA trait used as a bound on a type parameter.\nA modifier on a trait bound, currently only used for the <code>?</code> …\nAn item declaration within the definition of a trait.\nAn associated constant within the definition of a trait.\nAn associated function within the definition of a trait.\nA macro invocation within the definition of a trait.\nAn associated type within the definition of a trait.\nA trait object type <code>dyn Bound1 + Bound2 + Bound3</code> where …\nA try-expression: <code>expr?</code>.\nA try block: <code>try { ... }</code>.\nA tuple expression: <code>(a, b, c, d)</code>.\nA tuple pattern: <code>(a, b)</code>.\nA tuple type: <code>(A, B, C, String)</code>.\nA tuple struct or tuple variant pattern: …\nReturned by <code>TypeGenerics::as_turbofish</code>.\nThe possible types that a Rust value could have.\nA generic type parameter: <code>T: Into&lt;String&gt;</code>.\nA type predicate in a <code>where</code> clause: …\nA type alias: …\nA foreign type in an <code>extern</code> block: <code>type void</code>.\nAn associated type within the definition of a trait.\nAn associated type within an impl block.\nA type ascription pattern: <code>foo: f64</code>.\nA type argument.\nA particular type is returned.\nA fixed size array type: <code>[T; n]</code>.\nA bare function type: <code>fn(usize) -&gt; bool</code>.\nReturned by <code>Generics::split_for_impl</code>.\nA type contained within invisible delimiters.\nAn <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a …\nIndication that a type should be inferred by the compiler: …\nA macro in the type position.\nThe never type: <code>!</code>.\nA generic type parameter: <code>T: Into&lt;String&gt;</code>.\nA trait or lifetime used as a bound on a type parameter.\nA parenthesized type equivalent to the inner type.\nA path like <code>std::slice::Iter</code>, optionally qualified with a …\nA raw pointer type: <code>*const T</code> or <code>*mut T</code>.\nA reference type: <code>&amp;&#39;a T</code> or <code>&amp;&#39;a mut T</code>.\nA dynamically sized slice type: <code>[T]</code>.\nA trait object type <code>dyn Bound1 + Bound2 + Bound3</code> where …\nA tuple type: <code>(A, B, C, String)</code>.\nA function argument accepted by pattern and type.\nA unary operator: <code>*</code>, <code>!</code>, <code>-</code>.\nA unary operation: <code>!x</code>, <code>*x</code>.\nA union definition: <code>union Foo&lt;A, B&gt; { x: A, y: B }</code>.\nUnit struct or unit variant such as <code>None</code>.\nUnnamed fields of a tuple struct or tuple variant such as …\nAn unnamed field like <code>self.0</code>.\nAn unsafe block: <code>unsafe { ... }</code>.\nA use declaration: <code>use std::collections::HashMap</code>.\nA glob import in a <code>use</code> item: <code>*</code>.\nA braced group of imports in a <code>use</code> item: <code>{A, B, C}</code>.\nAn identifier imported by a <code>use</code> item: <code>HashMap</code>.\nA path prefix of imports in a <code>use</code> item: <code>std::...</code>.\nAn renamed identifier imported by a <code>use</code> item: …\nA suffix of an import tree in a <code>use</code> item: <code>Type as Renamed</code> …\nThe variadic argument of a foreign function.\nAn enum variant.\nTokens in expression position not interpreted by Syn.\nTokens forming an item not interpreted by Syn.\nTokens in an <code>extern</code> block not interpreted by Syn.\nTokens within the definition of a trait not interpreted by …\nTokens within an impl block not interpreted by Syn.\nA raw token literal not interpreted by Syn.\nTokens in pattern position not interpreted by Syn.\nTokens in type position not interpreted by Syn.\nA visibility level restricted to some path: <code>pub(self)</code> or …\nThe visibility level of an item: inherited or <code>pub</code> or …\nA <code>where</code> clause in a definition: …\nA single predicate in a <code>where</code> clause: <code>T: Deserialize&lt;&#39;de&gt;</code>.\nA while loop: <code>while expr { ... }</code>.\nA pattern that matches any value: <code>_</code>.\nA yield expression: <code>yield expr</code>.\nTurn a type’s generics like <code>&lt;X, Y&gt;</code> into a turbofish like …\nParses the literal into a selected number type.\nThe type being bounded\nTrait and lifetime bounds (<code>Clone+Send+&#39;static</code>)\nParse a set of curly braces and expose their content to …\nParse a set of square brackets and expose their content to …\nA stably addressed token buffer supporting efficient …\nThe colon in <code>Struct { x: x }</code>. If written in shorthand like …\nReturns an Iterator&lt;Item = &amp;ConstParam&gt; over the constant …\nReturns an Iterator&lt;Item = &amp;mut ConstParam&gt; over the …\nDefine a type that supports parsing and printing a given …\nDefine a type that supports parsing and printing a …\nExplicit discriminant: <code>Variant = 1</code>\nExtension traits to provide parsing methods on foreign …\nContent stored in the variant.\nSyntax tree traversal to transform the nodes of an owned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this path consists of a single ident, returns the ident.\nName of the variant.\nName of the field, if any.\nThe <code>example</code> in <code>macro_rules! example { ... }</code>.\n<code>(A, B)</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if there are zero fields.\nDetermines whether this is a path of length 1 equal to the …\nGet an iterator over the borrowed <code>Field</code> items in this …\nGet an iterator over the mutably borrowed <code>Field</code> items in …\nReturns the number of fields.\nReturns an Iterator&lt;Item = &amp;LifetimeParam&gt; over the …\nThe <code>for&lt;&#39;a&gt;</code> in <code>for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;</code>\nAny lifetimes from a <code>for</code> binding\nReturns an Iterator&lt;Item = &amp;mut LifetimeParam&gt; over the …\nInitializes an empty <code>where</code>-clause if there is not one …\nFacility for interpreting structured content inside of an …\nCreates a new <code>Ident</code> with the given <code>string</code> as well as the …\nPanics\nInterpret a Syn literal from a proc-macro2 literal.\nSame as <code>Ident::new</code>, but creates a raw identifier (<code>r#ident</code>…\n<code>C</code>\nParse a set of parentheses and expose their content to …\nParsing interface for parsing a token stream into a syntax …\nParse tokens of source code into the chosen syntax tree …\nParse a syntax tree node from the content of this string …\nParse a proc-macro2 token stream into the chosen syntax …\nParse the arguments to the attribute as a syntax tree.\nSee <code>Attribute::parse_args</code>.\nParse the arguments to the attribute using the given …\nSee <code>Attribute::parse_args_with</code>.\nParse the tokens within the macro invocation’s …\nParse the tokens within the macro invocation’s …\nParse the content of a file of Rust code.\nParses zero or more inner attributes from the stream.\nParse the input TokenStream of a macro, triggering a …\nParse a <code>Path</code> containing no path arguments on any of its …\nParse a pattern, possibly involving <code>|</code>, but not a leading <code>|</code>.\nParse a pattern, possibly involving <code>|</code>, possibly including a\nParses a named (braced struct) field.\nParse the arguments to the attribute, expecting it to …\nSee <code>Attribute::parse_nested_meta</code>.\nParses zero or more outer attributes from the stream.\nQuasi-quotation macro that accepts input like the <code>quote!</code> …\nThis macro is <code>parse_quote!</code> + <code>quote_spanned!</code>.\nParse a pattern that does <em>not</em> involve <code>|</code> at the top level.\nParse a string of Rust code into the chosen syntax tree …\nParse <code>::&lt;…&gt;</code> with mandatory leading <code>::</code>.\nParses an unnamed (tuple struct) field.\nInvoke parser on the content of this string literal.\nAn alternative to the primary <code>Expr::parse</code> parser (from the …\nParse the body of a block as zero or more statements, …\nAn alternative to the primary <code>Expr::parse</code> parser (from the …\nReturns the path that identifies the interpretation of …\nReturns the path that begins this structured meta item.\nThe <code>Foo&lt;&amp;&#39;a T&gt;</code> in <code>for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;</code>\nA punctuated sequence of syntax tree nodes separated by …\nA method’s <code>self</code> receiver, such as <code>&amp;self</code> or …\nAn error if this path is not a single ident, as defined in …\nError if this is a <code>Meta::Path</code> or <code>Meta::NameValue</code>.\nError if this is a <code>Meta::Path</code> or <code>Meta::List</code>.\nError if this is a <code>Meta::List</code> or <code>Meta::NameValue</code>.\nThe Self type of the impl.\nConfigures the span of this <code>Ident</code>, possibly changing its …\nReturns the span of this <code>Ident</code>.\nA trait that can provide the <code>Span</code> of the complete contents …\nSplit a type’s generics into the pieces required for impl…\nStatements in a block\nTokens representing Rust punctuation, keywords, and …\nTrait this impl implements.\nReturns an Iterator&lt;Item = &amp;TypeParam&gt; over the type …\nReturns an Iterator&lt;Item = &amp;mut TypeParam&gt; over the type …\nSyntax tree traversal to walk a shared borrow of a syntax …\nIn some positions, types may not contain the <code>+</code> character, …\nA cheaply copyable cursor into a <code>TokenBuffer</code>.\nA buffer that can be efficiently traversed multiple times, …\nCreates a cursor referencing the first token in the buffer …\nCreates a cursor referencing a static empty TokenStream.\nChecks whether the cursor is currently pointing at the end …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the cursor is pointing at a <code>Group</code> with the given …\nIf the cursor is pointing at a <code>Ident</code>, returns it along …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the cursor is pointing at a <code>Lifetime</code>, returns it along …\nIf the cursor is pointing at a <code>Literal</code>, return it along …\nCreates a <code>TokenBuffer</code> containing all the tokens from the …\nCreates a <code>TokenBuffer</code> containing all the tokens from the …\nIf the cursor is pointing at a <code>Punct</code>, returns it along …\nReturns the <code>Span</code> of the current token, or <code>Span::call_site()</code>…\nCopies all remaining tokens visible from this cursor into a\nIf the cursor is pointing at a <code>TokenTree</code>, returns it along …\nAdditional methods for <code>Ident</code> not provided by proc-macro2 …\nParses any identifier including keywords.\nPeeks any identifier including keywords. Usage: …\nStrips the raw marker <code>r#</code>, if any, from the beginning of an …\nSyntax tree traversal to transform the nodes of an owned …\nContext for parsing a single property in the conventional …\nReport that the attribute’s content did not conform to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUsed when parsing <code>list(...)</code> syntax <strong>if</strong> the content inside …\nMake a parser that is usable with <code>parse_macro_input!</code> in a …\nUsed when parsing <code>key = &quot;value&quot;</code> syntax.\nContains the error value\nError returned when a Syn parser cannot parse the input …\nSupport for checking the next token in a stream to decide …\nAn empty syntax tree node that consumes no tokens when …\nContains the success value\nParsing interface implemented by all types that can be …\nCursor position within a buffered token stream.\nInput to a Syn parser function.\nParser that can parse Rust tokens into a particular syntax …\nTypes that can be parsed by looking at just one token.\nThe result of a Syn parser.\nCursor state associated with speculative parsing.\nCalls the given parser function to parse a syntax tree …\nAdd another error message to self such that when …\nProvides low-level access to the token representation …\nExtensions to the parsing API with niche applicability.\nTriggers an error at the current position of the parse …\nTriggers an error at the current position of the parse …\nTriggers an error at the current position of the parse …\nForks a parse stream so that parsing tokens out of either …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRender the error as an invocation of <code>compile_error!</code>.\nReturns whether there are tokens remaining in this stream.\nConstructs a helper for peeking at the next token in this …\nUsually the <code>ParseStream::error</code> method will be used …\nCreates an error with the specified message spanning the …\nParses a syntax tree node of type <code>T</code>, advancing the …\nParse tokens of source code into the chosen syntax tree …\nParse a proc-macro2 token stream into the chosen syntax …\nParse a string of Rust code into the chosen syntax tree …\nParses zero or more occurrences of <code>T</code> separated by …\nLooks at the next token in the parse stream to determine …\nLooks at the next token in the parse stream to determine …\nLooks at the second-next token in the parse stream.\nLooks at the third-next token in the parse stream.\nThe source location of the error.\nReturns the <code>Span</code> of the next token in the parse stream, or …\nSpeculatively parses tokens from this parse stream, …\nRender the error as an invocation of <code>compile_error!</code>.\nExtensions to the <code>ParseStream</code> API to support manipulating …\nExtensions to the <code>ParseStream</code> API to support speculative …\nAdvance this parse stream to the position of a forked …\nReturns the delimiter, the span of the delimiter token, …\nAn iterator over owned values of type <code>T</code>.\nAn iterator over owned pairs of type <code>Pair&lt;T, P&gt;</code>.\nAn iterator over borrowed values of type <code>&amp;T</code>.\nAn iterator over mutably borrowed values of type <code>&amp;mut T</code>.\nA single syntax tree node of type <code>T</code> followed by its …\nAn iterator over borrowed pairs of type <code>Pair&lt;&amp;T, &amp;P&gt;</code>.\nAn iterator over mutably borrowed pairs of type …\n<strong>A punctuated sequence of syntax tree nodes of type <code>T</code> </strong>…\nClears the sequence of all values and punctuation, making …\nReturns true if either this <code>Punctuated</code> is empty, or it has …\nBorrows the first element in this sequence.\nMutably borrows the first element in this sequence.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts an element at position <code>index</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over the contents of this sequence as …\nProduces this punctuated pair as a tuple of syntax tree …\nExtracts the syntax tree node from this punctuated pair, …\nDetermines whether this punctuated sequence is empty, …\nReturns an iterator over borrowed syntax tree nodes of …\nReturns an iterator over mutably borrowed syntax tree …\nBorrows the last element in this sequence.\nMutably borrows the last element in this sequence.\nReturns the number of syntax tree nodes in this punctuated …\nCreates an empty punctuated sequence.\nCreates a punctuated pair out of a syntax tree node and an …\nReturns an iterator over the contents of this sequence as …\nReturns an iterator over the contents of this sequence as …\nParses one or more occurrences of <code>T</code> separated by …\nParses one or more occurrences of <code>T</code> using the given parse …\nParses zero or more occurrences of <code>T</code> separated by …\nParses zero or more occurrences of <code>T</code> using the given parse …\nRemoves the last punctuated pair from this sequence, or …\nRemoves the trailing punctuation from this punctuated …\nBorrows the punctuation from this punctuated pair, unless …\nMutably borrows the punctuation from this punctuated pair, …\nAppends a syntax tree node onto the end of this punctuated …\nAppends a trailing punctuation onto the end of this …\nAppends a syntax tree node onto the end of this punctuated …\nDetermines whether this punctuated sequence ends with a …\nBorrows the syntax tree node from this punctuated pair.\nMutably borrows the syntax tree node from this punctuated …\nA trait that can provide the <code>Span</code> of the complete contents …\nReturns a <code>Span</code> covering the complete contents of this …\n<code>abstract</code>\n<code>&amp;</code>\n<code>&amp;&amp;</code>\n<code>&amp;=</code>\n<code>as</code>\n<code>async</code>\n<code>@</code>\n<code>auto</code>\n<code>await</code>\n<code>become</code>\n<code>box</code>\n<code>{</code>…<code>}</code>\n<code>[</code>…<code>]</code>\n<code>break</code>\n<code>^</code>\n<code>^=</code>\n<code>:</code>\n<code>,</code>\n<code>const</code>\n<code>continue</code>\n<code>crate</code>\n<code>default</code>\n<code>do</code>\n<code>$</code>\n<code>.</code>\n<code>..</code>\n<code>...</code>\n<code>..=</code>\n<code>dyn</code>\n<code>else</code>\n<code>enum</code>\n<code>=</code>\n<code>==</code>\n<code>extern</code>\n<code>=&gt;</code>\n<code>final</code>\n<code>fn</code>\n<code>for</code>\n<code>&gt;=</code>\nNone-delimited group\n<code>&gt;</code>\n<code>if</code>\n<code>impl</code>\n<code>in</code>\n<code>&lt;-</code>\n<code>&lt;=</code>\n<code>let</code>\n<code>loop</code>\n<code>&lt;</code>\n<code>macro</code>\n<code>match</code>\n<code>-</code>\n<code>-=</code>\n<code>mod</code>\n<code>move</code>\n<code>mut</code>\n<code>!=</code>\n<code>!</code>\n<code>|</code>\n<code>|=</code>\n<code>||</code>\n<code>override</code>\n<code>(</code>…<code>)</code>\n<code>::</code>\n<code>%</code>\n<code>%=</code>\n<code>+</code>\n<code>+=</code>\n<code>#</code>\n<code>priv</code>\n<code>pub</code>\n<code>?</code>\n<code>-&gt;</code>\n<code>ref</code>\n<code>return</code>\n<code>Self</code>\n<code>self</code>\n<code>;</code>\n<code>&lt;&lt;</code>\n<code>&lt;&lt;=</code>\n<code>&gt;&gt;</code>\n<code>&gt;&gt;=</code>\n<code>/</code>\n<code>/=</code>\n<code>*</code>\n<code>*=</code>\n<code>static</code>\n<code>struct</code>\n<code>super</code>\n<code>~</code>\nMarker trait for types that represent single tokens.\n<code>trait</code>\n<code>try</code>\n<code>type</code>\n<code>typeof</code>\n<code>_</code>\n<code>union</code>\n<code>unsafe</code>\n<code>unsized</code>\n<code>use</code>\n<code>virtual</code>\n<code>where</code>\n<code>while</code>\n<code>yield</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSyntax tree traversal to walk a shared borrow of a syntax …")