searchState.loadedDescShard("regex_automata", 0, "This crate exposes a variety of regex engines used by the …\nReport all possible matches.\nThe type of anchored search to perform.\nThe search, based on heuristics, determined that it would …\nA representation of “half” of a match reported by a …\nThis error occurs if the haystack given to the regex …\nThe parameters for a regex search including the haystack …\nReport only the leftmost matches. When multiple leftmost …\nA representation of a match reported by a regex engine.\nAn error indicating that a search stopped before reporting …\nThe underlying kind of a <code>MatchError</code>.\nThe kind of match semantics to use for a regex pattern.\nRun an unanchored search. This means a match may occur …\nRun an anchored search for a specific pattern. This means …\nThe identifier of a regex pattern, represented by a …\nA set of <code>PatternID</code>s.\nAn error that occurs when a <code>PatternID</code> failed to insert …\nAn iterator over all pattern identifiers in a <code>PatternSet</code>.\nThe search saw a “quit” byte at which it was …\nA representation of a span reported by a regex engine.\nAn error indicating that a particular type of anchored …\nRun an anchored search. This means that a match must begin …\nSets the anchor mode of a search.\nReturns the total number of pattern identifiers that may …\nClear this set such that it contains no pattern IDs.\nReturns true when the given offset is contained within …\nReturn true if and only if the given pattern identifier is …\nA module for building and searching with deterministic …\nWhether to execute an “earliest” search or not.\nReturn the end position of this search.\nThe ending position of the match.\nThe end offset of the span, exclusive.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new “gave up” error. The given <code>offset</code> …\nReturn the anchored mode for this search configuration.\nReturn whether this search should execute in “earliest”…\nReturn the span as a range for this search configuration.\nReturn the span for this search configuration.\nReturn a borrow of the underlying haystack as a slice of …\nCreate a new “haystack too long” error. The given <code>len</code> …\nA module for building and searching with lazy …\nInsert the given pattern identifier into this set and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this anchor mode corresponds …\nReturns true if and only if the given offset in this search…\nReturn true if and only if this search can never return …\nReturns true when this span is empty. That is, when …\nReturns true when the span in this match is empty.\nReturn true if and only if this set has no pattern …\nReturn true if and only if this set has the maximum number …\nReturns an iterator over all pattern identifiers in this …\nReturns a reference to the underlying error kind.\nReturns the length of this span.\nReturns the length of this match.\nReturns the total number of pattern identifiers in this …\nProvides a regex matcher that composes several other regex …\nCreate a new half match from a pattern ID and a byte …\nCreate a new match from a pattern ID and a byte offset …\nCreate a new search configuration for the given haystack.\nCreate a new half match from a pattern ID and a byte …\nCreate a new match from a pattern ID and a span.\nCreate a new set of pattern identifiers with the given …\nCreate a new error value with the given kind.\nProvides non-deterministic finite automata (NFA) and regex …\nReturns a new span with <code>offset</code> added to this span’s <code>start</code>…\nThe position of the match.\nReturns the ID of the pattern that matched.\nReturns the ID of the pattern that matched.\nReturns the pattern ID associated with this configuration …\nCreate a new “quit” error. The given <code>byte</code> corresponds …\nLike <code>Input::span</code>, but accepts any range instead.\nReturns this span as a range.\nReturns the match span as a range.\nSet the anchor mode of a search.\nSet whether the search should execute in “earliest” …\nSet the ending offset for the span for this search …\nSet the span for this search configuration given any range.\nSet the span for this search configuration.\nSet the starting offset for the span for this search …\nSet the span for this search.\nReturns the span for this match.\nReturn the start position of this search.\nThe starting position of the match.\nThe start offset of the span, inclusive.\nInsert the given pattern identifier into this set and …\nCreate a new “unsupported anchored” error. This occurs …\nA collection of modules that provide APIs that are useful …\nThe “quit” byte that was observed that caused the …\nThe length of the haystack that exceeded the limit.\nThe anchored mode given that is unsupported.\nThe offset at which the quit byte was observed.\nThe offset at which the search stopped. This corresponds …\nA DFA that can return spans for matching capturing groups.\nAn error that occurred during the construction of a …\nA builder for a one-pass DFA.\nA cache represents mutable state that a one-pass <code>DFA</code> …\nThe configuration used for building a one-pass DFA.\nA one-pass DFA for executing a subset of anchored regex …\nReturns the total number of elements in the alphabet for …\nCreate a new one-pass DFA that matches every input.\nBuild a one-pass DFA from the given pattern.\nBuild a DFA from the given NFA.\nBuild a one-pass DFA from the given patterns.\nReturn a builder for configuring the construction of a DFA.\nWhether to attempt to shrink the size of the DFA’s …\nExecutes an anchored leftmost forward search and writes …\nReturn a default configuration for a DFA.\nApply the given one-pass DFA configuration options to this …\nCreate a new cache for this DFA.\nCreate a new empty set of capturing groups that is …\nExecutes an anchored leftmost forward search, and returns …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether this configuration has enabled byte …\nReturn the config for this one-pass DFA.\nReturns the match semantics set in this configuration.\nReturns a reference to the underlying NFA.\nReturns the DFA size limit of this configuration if one …\nReturns whether this configuration has enabled anchored …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExecutes an anchored leftmost forward search, and returns …\nSet the desired match semantics.\nReturns the memory usage, in bytes, of this DFA.\nReturns the heap memory usage, in bytes, of this cache.\nCreate a new one-pass DFA that never matches any input.\nReturn a new default one-pass DFA configuration.\nCreate a new one-pass DFA builder with the default …\nParse the given regular expression using the default …\nCreate a new <code>onepass::DFA</code> cache.\nLike <code>new</code>, but builds a one-pass DFA directly from an NFA. …\nLike <code>new</code>, but parses multiple patterns into a single “…\nReturns the total number of patterns compiled into this …\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nSet a size limit on the total heap used by a one-pass DFA.\nWhether to compile a separate start state for each pattern …\nReturns the total number of states in this one-pass DFA.\nReturns the total stride for every state in this DFA. This …\nReturns the total stride for every state in this DFA, …\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nExecutes an anchored leftmost forward search and writes …\nExecutes an anchored leftmost forward search and writes …\nAn error that occurs when initial construction of a lazy …\nAn error that occurs when cache inefficiency has dropped …\nAn error that occurs when cache usage has become …\nA state identifier specifically tailored for lazy DFAs.\nAn error that occurs when a starting configuration’s …\nAn error that can occur when computing the start state for …\nAn error that occurs when the caller requests an anchored …\nTypes and routines specific to lazy DFAs.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if and only if this represents a dead state. A …\nReturn true if and only if this lazy state ID has been …\nReturn true if and only if this represents a quit state. A …\nReturn true if and only if this lazy state ID has been …\nReturn true if and only if this lazy state ID is tagged.\nReturn true if and only if this represents a lazy state ID …\nA lazy DFA backed <code>Regex</code>.\nThe quit byte that was found.\nThe underlying cache error that occurred.\nThe anchored mode given that is unsupported.\nA builder for constructing a lazy deterministic finite …\nA cache represents a partially computed DFA.\nThe configuration used for building a lazy DFA.\nA hybrid NFA/DFA (also called a “lazy DFA”) for regex …\nRepresents the current state of an overlapping search.\nCreate a new lazy DFA that matches every input.\nBuild a lazy DFA from the given pattern.\nBuild a DFA from the given NFA.\nBuild a lazy DFA from the given patterns.\nReturn a builder for configuring the construction of a …\nReturns the equivalence classes that make up the alphabet …\nWhether to attempt to shrink the size of the lazy DFA’s …\nSets the maximum amount of heap memory, in bytes, to …\nReturns the total number of times this cache has been …\nReturn a default configuration for a <code>DFA</code>.\nApply the given lazy DFA configuration options to this …\nCreate a new cache for this lazy DFA.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether this configuration has enabled byte …\nReturns the cache capacity set on this configuration.\nReturns this lazy DFA’s configuration.\nReturn the match result of the most recent search to …\nReturns the match semantics set in this configuration.\nReturns, if set, the minimum number of bytes per state …\nReturns the minimum lazy DFA cache capacity required for …\nReturns, if set, the minimum number of times the cache …\nReturns a reference to the underlying NFA.\nReturns the prefilter set in this configuration, if one at …\nReturns whether this configuration will instruct the lazy …\nReturns whether the cache capacity check should be skipped.\nReturns whether this configuration will instruct the lazy …\nReturns whether this configuration has enabled anchored …\nReturns whether this configuration has enabled heuristic …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the desired match semantics.\nReturns the total number of patterns that match in this …\nReturns the pattern ID corresponding to the given match …\nReturns the memory usage, in bytes, of this lazy DFA.\nReturns the heap memory usage, in bytes, of this cache.\nConfigure a lazy DFA search to quit only when its …\nConfigure a lazy DFA search to quit after a certain number …\nCreate a new lazy DFA that never matches any input.\nParse the given regular expression using a default …\nCreate a new cache for the given lazy DFA.\nReturn a new default lazy DFA builder configuration.\nCreate a new lazy DFA builder with the default …\nParse the given regular expressions using a default …\nTransitions from the current state to the next state for …\nTransitions from the current state to the next state, …\nTransitions from the current state to the next state, …\nTransitions from the current state to the next state, …\nReturns the total number of patterns compiled into this …\nSet a prefilter to be used whenever a start state is …\nAdd a “quit” byte to the lazy DFA.\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nIndicates that a search has finished at the given position.\nInitializes a new search starting at the given position.\nReturns the total number of bytes that have been searched …\nUpdates the current search to indicate that it has search …\nConfigures construction of a lazy DFA to use the minimum …\nEnable specializing start states in the lazy DFA.\nCreate a new overlapping state that begins at the start …\nReturn the ID of the start state for this lazy DFA for the …\nReturn the ID of the start state for this lazy DFA when …\nReturn the ID of the start state for this lazy DFA when …\nWhether to compile a separate start state for each pattern …\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nExecutes a forward search and returns the end position of …\nExecutes an overlapping forward search and returns the end …\nExecutes a reverse overlapping search and returns the …\nExecutes a reverse search and returns the start of the …\nWrites the set of patterns that match anywhere in the …\nHeuristically enable Unicode word boundaries.\nA builder for a regex based on a hybrid NFA/DFA.\nA cache represents a partially computed forward and …\nAn iterator over all non-overlapping matches for an …\nA regular expression that uses hybrid NFA/DFAs (also …\nReturn references to the forward and reverse caches, …\nReturn mutable references to the forward and reverse …\nBuild a regex from the given pattern.\nBuild a regex from its component forward and reverse …\nBuild a regex from the given patterns.\nReturn a builder for configuring the construction of a …\nCreate a new cache for this <code>Regex</code>.\nSet the lazy DFA compilation configuration for this …\nReturns the start and end offset of the leftmost match. If …\nReturns an iterator over all non-overlapping leftmost …\nReturn the underlying lazy DFA responsible for forward …\nReturn a reference to the forward cache.\nReturn a mutable reference to the forward cache.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this regex matches the given …\nReturns the heap memory usage, in bytes, as a sum of the …\nParse the given regular expression using the default …\nCreate a new cache for the given <code>Regex</code>.\nCreate a new regex builder with the default configuration.\nLike <code>new</code>, but parses multiple patterns into a single “…\nReturns the total number of patterns matched by this regex.\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nReturn the underlying lazy DFA responsible for reverse …\nReturn a reference to the reverse cache.\nReturn a mutable reference to the reverse cache.\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nReturns the start and end offset of the leftmost match. If …\nAn error that occurs when construction of a <code>Regex</code> fails.\nA builder for configuring and constructing a <code>Regex</code>.\nRepresents mutable scratch space used by regex engines …\nAn iterator over all non-overlapping leftmost matches with …\nAn object describing the configuration of a <code>Regex</code>.\nAn iterator over all non-overlapping matches.\nA regex matcher that works by composing several other …\nYields all substrings delimited by a regular expression …\nYields at most <code>N</code> spans delimited by a regular expression …\nToggles whether automatic prefilter support is enabled.\nToggle whether a bounded backtracking regex engine should …\nBuilds a <code>Regex</code> from a single pattern string.\nBuilds a <code>Regex</code> directly from an <code>Hir</code> expression.\nBuilds a <code>Regex</code> from many pattern strings.\nBuilds a <code>Regex</code> directly from many <code>Hir</code> expressions.\nReturn a builder for configuring the construction of a …\nWhether to attempt to shrink the size of the alphabet for …\nExecutes a leftmost forward search and writes the spans of …\nReturns an iterator over all non-overlapping <code>Captures</code> …\nReturns the total number of capturing groups.\nReturn a default configuration for a <code>Regex</code>.\nConfigure the behavior of a <code>Regex</code>.\nCreates a new cache for use with lower level search APIs …\nCreates a new object for recording capture group offsets. …\nToggle whether a fully compiled DFA should be available …\nSets the size limit, in bytes, for heap memory used for a …\nSets a limit on the total number of NFA states, beyond …\nExecutes a leftmost search and returns the first match …\nReturns an iterator over all non-overlapping leftmost …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether automatic prefilters are enabled, as set by\nReturns whether the bounded backtracking regex engine may …\nReturns whether byte classes are enabled, as set by …\nReturns the configuration object used to build this <code>Regex</code>.\nReturns whether the DFA regex engine may be used, as set by\nReturns DFA size limit, as set by <code>Config::dfa_size_limit</code>.\nReturns DFA size limit in terms of the number of states in …\nReturns whether the hybrid NFA/DFA regex engine may be …\nReturns hybrid NFA/DFA cache capacity, as set by …\nReturns the line terminator for this configuration, as set …\nReturns the match kind on this configuration, as set by …\nReturns NFA size limit, as set by <code>Config::nfa_size_limit</code>.\nReturns whether the one-pass DFA regex engine may be used, …\nReturns one-pass DFA size limit, as set by …\nReturns a manually set prefilter, if one was set by …\nReturns whether empty matches must fall on valid UTF-8 …\nReturns the capture configuration, as set by …\nReturn information about the capture groups in this <code>Regex</code>.\nToggle whether the hybrid NFA/DFA (also known as the “…\nSet the cache capacity, in bytes, for the lazy DFA.\nReturns the current <code>Input</code> associated with this iterator.\nReturns the current <code>Input</code> associated with this iterator.\nReturns the current <code>Input</code> associated with this iterator.\nReturns the current <code>Input</code> associated with this iterator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this regex has a high chance of being “…\nReturns true if and only if this regex matches the given …\nSet the line terminator to be used by the <code>^</code> and <code>$</code> anchors …\nSet the match semantics for a <code>Regex</code>.\nReturn the total approximate heap memory, in bytes, used …\nReturns the heap memory usage, in bytes, of this cache.\nBuilds a <code>Regex</code> from a single pattern string using the …\nCreates a new <code>Cache</code> for use with this regex.\nCreate a new configuration object for a <code>Regex</code>.\nCreates a new builder for configuring and constructing a …\nBuilds a <code>Regex</code> from many pattern strings using the default …\nSets the size limit, in bytes, to enforce on the …\nToggle whether a one-pass DFA should be available for use …\nSets the size limit, in bytes, for the one-pass DFA.\nIf it is known which pattern ID caused this build error to …\nReturns the total number of patterns in this regex.\nOverrides and sets the prefilter to use inside a <code>Regex</code>.\nReturns the <code>Regex</code> value that created this iterator.\nReturns the <code>Regex</code> value that created this iterator.\nReset this cache such that it can be used for searching …\nReturns the start and end offset of the leftmost match. If …\nExecutes a leftmost forward search and writes the spans of …\nThis is like <code>Regex::search_captures</code>, but requires the …\nReturns the end offset of the leftmost match. If no match …\nThis is like <code>Regex::search_half</code>, but requires the caller to\nExecutes a leftmost forward search and writes the spans of …\nThis is like <code>Regex::search_slots</code>, but requires the caller …\nThis is like <code>Regex::search</code>, but requires the caller to …\nIf this error occurred because the regex exceeded the …\nReturns an iterator of spans of the haystack given, …\nReturns an iterator of at most <code>limit</code> spans of the haystack …\nReturns the total number of capturing groups that appear …\nConfigure the syntax options when parsing a pattern string …\nIf this error corresponds to a syntax error, then a …\nToggles whether empty matches are permitted to occur …\nConfigures what kinds of groups are compiled as “…\nWrites the set of patterns that match anywhere in the …\nThis is like <code>Regex::which_overlapping_matches</code>, but …\nDefines a Thompson NFA and provides the <code>PikeVM</code> and …\nAll capture states, including those corresponding to both …\nAn alternation such that there exists precisely two …\nAn error that can occurred during the construction of a …\nAn abstraction for building Thompson NFAs by hand.\nA state with a single transition that can only be taken if …\nAn empty state that records a capture location.\nA builder for compiling an NFA from a regex’s high-level …\nThe configuration used for a Thompson NFA compiler.\nA dense representation of a state with multiple …\nA sequence of transitions used to represent a dense state.\nA state that cannot be transitioned out of. This is useful …\nOnly capture states corresponding to implicit capture …\nA conditional epsilon transition satisfied via some sort of\nA match state. There is at least one such occurrence of …\nA byte oriented Thompson non-deterministic finite …\nNo capture states are compiled into the Thompson NFA.\nAn iterator over all pattern IDs in an NFA.\nA state with possibly many transitions represented in a …\nA sequence of transitions used to represent a sparse state.\nA state in an NFA.\nA single transition to another state.\nAn alternation such that there exists an epsilon …\nA configuration indicating which kinds of <code>State::Capture</code> …\nAdd a “end capture” NFA state.\nAdd a “start capture” NFA state.\nAdd an “empty” NFA state.\nAdds a “fail” NFA state.\nAdd a “look” NFA state.\nAdds a “match” NFA state.\nAdd a “range” NFA state.\nAdd a “sparse” NFA state.\nAdd a “union” NFA state.\nAdd a “reverse union” NFA state.\nReturns an NFA with a single regex pattern that always …\nAn NFA backed bounded backtracker for executing regex …\nAssemble a <code>NFA</code> from the states added so far.\nCompile the given regular expression pattern into an NFA.\nCompile the given high level intermediate representation …\nCompile the given regular expression patterns into a …\nCompile the given high level intermediate representations …\nGet the byte classes for this NFA.\nWhether to include ‘Capture’ states in the NFA.\nClear this builder.\nReturn a compiler for configuring the construction of an …\nReturn a default configuration for an <code>NFA</code>.\nApply the given NFA configuration options to this builder.\nReturns the pattern identifier of the current pattern.\nThe inclusive end of the byte range.\nFinish the assembly of a pattern in this NFA.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn whether NFA compilation is configured to produce …\nReturns the look-around matcher used for this builder.\nReturn the look-around matcher for this NFA.\nReturn the configured NFA size limit, if it exists, in the …\nReturns whether reverse mode is enabled for this builder.\nReturns whether this configuration has enabled reverse NFA …\nReturn whether NFA shrinking is enabled.\nReturn the currently configured size limit.\nReturns whether UTF-8 mode is enabled for this builder.\nReturns whether this configuration has enabled UTF-8 mode.\nReturn what kinds of capture states will be compiled into …\nReturns the capturing group info for this NFA.\nReturns true if and only if this NFA has at least one …\nReturns true if and only if this NFA can match the empty …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if all starting states for this …\nReturns true if this configuration indicates that some …\nReturns true if and only if this state contains one or …\nReturns true if this configuration indicates that no …\nReturns true when this NFA is meant to be matched in …\nWhether UTF-8 mode is enabled for this NFA or not.\nSets the look-around matcher that should be used with this …\nReturns the look-around matcher associated with this NFA.\nReturns the union of all look-around assertions used …\nReturns the union of all prefix look-around assertions for …\nThis follows the matching transition for a particular byte.\nThis follows the matching transition for a particular byte.\nReturns true if the position <code>at</code> in <code>haystack</code> falls in this …\nThis follows the matching transition for a particular byte.\nThis follows the matching transition for a particular byte.\nReturns true if the given byte falls in this transition’…\nReturns true if the given alphabet unit falls in this …\nReturns the heap memory usage, in bytes, used by the NFA …\nReturns the memory usage, in bytes, of this NFA.\nReturns an NFA that never matches at any position.\nCreate a new builder for hand-assembling NFAs.\nReturn a new default Thompson NFA compiler configuration.\nCreate a new NFA builder with its default configuration.\nParse the given regular expression using a default …\nParse the given regular expressions using a default …\nThe identifier of the state to transition to.\nSets an approximate size limit on the total heap used by …\nAdd a transition from one state to another.\nReturns the number of patterns added to this builder so …\nReturns the total number of regex patterns in this NFA.\nReturns an iterator over all pattern identifiers in this …\nAn NFA backed Pike VM for executing regex searches with …\nReverse the NFA.\nSets the look-around matcher that should be used for the …\nSets whether the NFA produced by this builder should be …\nSet the size limit on this builder.\nSet whether the NFA produced by this builder should only …\nApply best effort heuristics to shrink the NFA at the …\nIf this error occurred because the NFA exceeded the …\nThe inclusive start of the byte range.\nReturn the state identifier of the initial anchored state …\nStart the assembly of a pattern in this NFA.\nReturn the state identifier of the initial anchored state …\nReturn the state identifier of the initial unanchored …\nReturn a reference to the NFA state corresponding to the …\nReturns a slice of all states in this NFA.\nSet the syntax configuration for this builder using …\nThe sorted sequence of non-overlapping transitions.\nA dense representation of this state’s transitions on …\nWhether to enable UTF-8 mode during search or not.\nConfigures what kinds of capture groups are compiled into …\nAn unconditional epsilon transition to another NFA state. …\nAn unconditional epsilon transition to another NFA state. …\nAn ordered sequence of unconditional epsilon transitions …\nThe capture group index that this capture belongs to. …\nThe look-around assertion that must be satisfied before …\nThe state to transition to if the look-around assertion is …\nThe state to transition to, unconditionally.\nThe pattern ID that this capture belongs to.\nThe matching pattern ID.\nThe slot index for this capture. Every capturing group has …\nThe transition from this state to the next.\nA backtracking regex engine that bounds its execution to …\nA builder for a bounded backtracker.\nA cache represents mutable state that a <code>BoundedBacktracker</code> …\nThe configuration used for building a bounded backtracker.\nAn iterator over all non-overlapping leftmost matches, …\nAn iterator over all non-overlapping matches for a …\nCreate a new <code>BoundedBacktracker</code> that matches every input.\nBuild a <code>BoundedBacktracker</code> from the given pattern.\nBuild a <code>BoundedBacktracker</code> directly from its NFA.\nBuild a <code>BoundedBacktracker</code> from the given patterns.\nReturn a builder for configuring the construction of a …\nReturn a default configuration for a <code>BoundedBacktracker</code>.\nApply the given <code>BoundedBacktracker</code> configuration options …\nCreate a new cache for this regex.\nCreate a new empty set of capturing groups that is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the config for this <code>BoundedBacktracker</code>.\nReturns a reference to the underlying NFA.\nReturns the prefilter set in this configuration, if one at …\nReturns the configured visited capacity.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the maximum haystack length supported by this …\nReturns the heap memory usage, in bytes, of this cache.\nReturns the minimum visited capacity for the given …\nCreate a new <code>BoundedBacktracker</code> that never matches any …\nReturn a new default regex configuration.\nCreate a new BoundedBacktracker builder with its default …\nParse the given regular expression using the default …\nCreate a new <code>BoundedBacktracker</code> cache.\nExample\nLike <code>new</code>, but parses multiple patterns into a single “…\nReturns the total number of patterns compiled into this …\nSet a prefilter to be used whenever a start state is …\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nExecutes a leftmost forward search and writes the spans of …\nReturns an iterator over all non-overlapping <code>Captures</code> …\nExecutes a leftmost forward search and returns a <code>Match</code> if …\nReturns an iterator over all non-overlapping leftmost …\nReturns true if and only if this regex matches the given …\nExecutes a leftmost forward search and writes the spans of …\nExecutes a leftmost forward search and writes the spans of …\nSet the visited capacity used to bound backtracking.\nA builder for a <code>PikeVM</code>.\nA cache represents mutable state that a <code>PikeVM</code> requires …\nAn iterator over all non-overlapping leftmost matches, …\nThe configuration used for building a <code>PikeVM</code>.\nAn iterator over all non-overlapping matches for a …\nA virtual machine for executing regex searches with …\nCreate a new <code>PikeVM</code> that matches every input.\nBuild a <code>PikeVM</code> from the given pattern.\nBuild a <code>PikeVM</code> directly from its NFA.\nBuild a <code>PikeVM</code> from the given patterns.\nReturn a builder for configuring the construction of a …\nExecutes a leftmost forward search and writes the spans of …\nReturns an iterator over all non-overlapping <code>Captures</code> …\nReturn a default configuration for a <code>PikeVM</code>.\nApply the given <code>PikeVM</code> configuration options to this …\nCreate a new cache for this <code>PikeVM</code>.\nCreate a new empty set of capturing groups that is …\nExecutes a leftmost forward search and returns a <code>Match</code> if …\nReturns an iterator over all non-overlapping leftmost …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the config for this <code>PikeVM</code>.\nReturns the match semantics set in this configuration.\nReturns a reference to the underlying NFA.\nReturns the prefilter set in this configuration, if one at …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this <code>PikeVM</code> matches the given …\nSet the desired match semantics.\nReturns the heap memory usage, in bytes, of this cache.\nCreate a new <code>PikeVM</code> that never matches any input.\nReturn a new default PikeVM configuration.\nCreate a new PikeVM builder with its default configuration.\nParse the given regular expression using the default …\nCreate a new <code>PikeVM</code> cache.\nLike <code>new</code>, but builds a PikeVM directly from an NFA. This …\nLike <code>new</code>, but parses multiple patterns into a single “…\nReturns the total number of patterns compiled into this …\nSet a prefilter to be used whenever a start state is …\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nExecutes a leftmost forward search and writes the spans of …\nExecutes a leftmost forward search and writes the spans of …\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nWrites the set of patterns that match anywhere in the …\nThis module provides APIs for dealing with the alphabets …\nProvides types for dealing with capturing groups.\nProvides convenience routines for escaping raw bytes.\nProvides routines for interpolating capture group …\nGeneric helpers for iteration of matches from a regex …\nA lazily initialized value for safe sharing between …\nTypes and routines for working with look-around assertions.\nA thread safe memory pool.\nDefines a prefilter for accelerating regex searches.\nLower level primitive types that are useful in a variety …\nProvides helpers for dealing with start state …\nUtilities for dealing with the syntax of a regular …\nTypes and routines that support the wire format of finite …\nAn iterator over all elements in an equivalence class.\nAn iterator over each equivalence class.\nAn iterator over representative bytes from each …\nA representation of byte oriented equivalence classes.\nUnit represents a single unit of haystack for DFA based …\nReturn the total number of elements in the alphabet …\nIf this unit is an “end of input” sentinel, then …\nIf this unit is not an “end of input” sentinel, then …\nReturn this unit as a <code>usize</code>, regardless of whether it is a …\nReturns an iterator of the bytes in the given equivalence …\nCreates a new set of equivalence classes where all bytes …\nCreate a new “end of input” haystack unit.\nCreate a unit that represents the “end of input” …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the equivalence class for the given byte.\nGet the equivalence class for the given haystack unit and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only of this unit is a byte value …\nReturns true when this unit represents an “end of input…\nReturns true if and only if every byte in this class maps …\nReturns true when this unit corresponds to an ASCII word …\nReturns an iterator over all equivalence classes in this …\nReturns an iterator over a sequence of representative …\nSet the equivalence class for the given byte.\nCreates a new set of equivalence classes where each byte …\nReturns the stride, as a base-2 exponent, required for …\nCreate a new haystack unit from a byte value.\nThe span offsets of capturing groups after a match has …\nAn iterator over all capturing groups in a <code>Captures</code> value.\nRepresents information about capturing groups in a …\nAn iterator over capturing groups and their names for a …\nAn error that may occur when building a <code>GroupInfo</code>.\nAn iterator over capturing groups and their names for a …\nCreate new storage for the offsets of all matching …\nReturn the total number of capture groups across all …\nReturn an iterator of all capture groups for all patterns …\nClear this <code>Captures</code> value.\nCreate new storage for only tracking which pattern …\nThis creates an empty <code>GroupInfo</code>.\nReturns the total number of slots for explicit capturing …\nThis is a convenience routine for extracting the substrings\nThis is a convenience routine for extracting the substrings\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the span of a capturing group match corresponding …\nReturns the span of a capturing group match corresponding …\nReturns the pattern ID and the span of the match, if one …\nReturns a reference to the underlying group info on which …\nReturn the total number of capturing groups for the …\nReturn the number of capture groups in a pattern.\nReturns the total number of slots for implicit capturing …\nInterpolates the capture references in <code>replacement</code> with the\nInterpolates the capture references in <code>replacement</code> with the\nInterpolates the capture references in <code>replacement</code> with the\nInterpolates the capture references in <code>replacement</code> with the\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this capturing group …\nReturns an iterator of possible spans for every capturing …\nCreate new storage for only the full match spans of a …\nReturns the memory usage, in bytes, of this <code>GroupInfo</code>.\nCreates a new group info from a sequence of patterns, …\nReturns the identifier of the pattern that matched when …\nReturns the total number of patterns in this <code>GroupInfo</code>.\nReturn an iterator of all capture groups and their names …\nSet the pattern on this <code>Captures</code> value.\nReturns the starting slot corresponding to the given …\nReturns the total number of slots in this <code>GroupInfo</code> across …\nReturns the underlying slots, where each slot stores a …\nReturns the starting and ending slot corresponding to the …\nReturns the underlying slots as a mutable slice, where …\nReturn the capture group index corresponding to the given …\nReturn the capture name for the given index and given …\nProvides a convenient <code>Debug</code> implementation for a <code>u8</code>.\nProvides a convenient <code>Debug</code> implementation for <code>&amp;[u8]</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccepts a replacement byte string and interpolates capture …\nAccepts a replacement string and interpolates capture …\nAn iterator over all non-overlapping captures for an …\nAn iterator over all non-overlapping half matches for an …\nAn iterator over all non-overlapping matches for an …\nA searcher for creating iterators and performing lower …\nAn iterator over all non-overlapping captures for a …\nAn iterator over all non-overlapping half matches for a …\nAn iterator over all non-overlapping matches for a …\nReturn the next match for an infallible search if one …\nReturn the next half match for an infallible search if one …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn an infallible version of this iterator.\nReturn an infallible version of this iterator.\nReturn an infallible version of this iterator.\nReturns the current <code>Input</code> used by this iterator.\nReturns the current <code>Input</code> used by this iterator.\nReturns the current <code>Input</code> used by this searcher.\nReturns the current <code>Input</code> used by this iterator.\nReturns the current <code>Input</code> used by this iterator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a closure that executes a single search, return an …\nGiven a closure that executes a single search, return an …\nGiven a closure that executes a single search, return an …\nCreate a new fallible non-overlapping matches iterator.\nReturn the next match for a fallible search if one exists, …\nReturn the next half match for a fallible search if one …\nA lazily initialized value that implements <code>Deref</code> for <code>T</code>.\nReturns the argument unchanged.\nReturn a reference to the lazily initialized value.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Lazy</code> value that is initialized via the given …\nMatch the end of text. Specifically, this matches at the …\nMatch the end of a line or the end of text. Specifically, …\nMatch the end of a line or the end of text. Specifically, …\nA look-around assertion.\nA matcher for look-around assertions.\nLookSet is a memory-efficient set of look-around …\nAn iterator over all look-around assertions in a <code>LookSet</code>.\nMatch the beginning of text. Specifically, this matches at …\nMatch the beginning of a line or the beginning of text. …\nMatch the beginning of a line or the beginning of text. …\nAn error that occurs when the Unicode-aware <code>\\w</code> class is …\nMatch an ASCII-only word boundary. That is, this matches a …\nMatch an ASCII-only negation of a word boundary.\nMatch the end of an ASCII-only word boundary. That is, …\nMatch the end half of an ASCII-only word boundary. That …\nMatch the end half of a Unicode word boundary. That is, …\nMatch the end of a Unicode word boundary. That is, this …\nMatch the start of an ASCII-only word boundary. That is, …\nMatch the start half of an ASCII-only word boundary. That …\nMatch the start half of a Unicode word boundary. That is, …\nMatch the start of a Unicode word boundary. That is, this …\nMatch a Unicode-aware word boundary. That is, this matches …\nMatch a Unicode-aware negation of a word boundary.\nReturns a convenient single codepoint representation of …\nReturn the underlying representation of this look-around …\nChecks that all assertions in this set can be matched.\nThe underlying representation this set is exposed to make …\nReturns an error if and only if Unicode word boundary data …\nReturns true if and only if the given look-around …\nReturns true if and only if this set contains any anchor …\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any word …\nReturns true if and only if this set contains any ASCII …\nReturns true if and only if this set contains any Unicode …\nCreate an empty set of look-around assertions.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven the underlying representation of a <code>Look</code> value, …\nCreate a full set of look-around assertions.\nReturns the line terminator that was configured for this …\nReturn a new set that is equivalent to the original, but …\nReturns a new set that is the intersection of this and the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this set is empty.\nReturns true when <code>Look::End</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::EndCRLF</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::EndLF</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::Start</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::StartCRLF</code> is satisfied <code>at</code> the given\nReturns true when <code>Look::StartLF</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::WordAscii</code> is satisfied <code>at</code> the given\nReturns true when <code>Look::WordAsciiNegate</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordEndAscii</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordEndHalfAscii</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordEndHalfUnicode</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordEndUnicode</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordStartAscii</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordStartHalfAscii</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordStartHalfUnicode</code> is satisfied …\nReturns true when <code>Look::WordStartUnicode</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordUnicode</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordUnicodeNegate</code> is satisfied <code>at</code> …\nReturns an iterator over all of the look-around assertions …\nReturns the total number of look-around assertions in this …\nReturns true when the position <code>at</code> in <code>haystack</code> satisfies …\nReturns true when <em>all</em> of the assertions in the given set …\nCreates a new default matcher for look-around assertions.\nReturn a <code>LookSet</code> from the slice given as a native endian …\nReturn a new set that is equivalent to the original, but …\nFlip the look-around assertion to its equivalent for …\nUpdates this set in place with the result of inserting the …\nUpdates this set in place with the result of intersecting …\nSets the line terminator for use with <code>(?m:^)</code> and <code>(?m:$)</code>.\nUpdates this set in place with the result of removing the …\nUpdates this set in place with the result of subtracting …\nUpdates this set in place with the result of unioning it …\nCreate a look-around set containing the look-around …\nReturns a new set that is the result of subtracting the …\nReturns a new set that is the union of this and the one …\nWrite a <code>LookSet</code> as a native endian 32-bit integer to the …\nA thread safe pool that works in an <code>alloc</code>-only context.\nA guard that is returned when a caller requests a value …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value from the pool. The caller is guaranteed to have\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pool. The given closure is used to create …\nConsumes this guard and puts it back into the pool.\nA prefilter for accelerating regex searches.\nRun this prefilter on <code>haystack[span.start..end]</code> and return …\nReturns the argument unchanged.\nThis attempts to extract prefixes from the given <code>Hir</code> …\nThis attempts to extract prefixes from the given <code>Hir</code> …\nCalls <code>U::from(self)</code>.\nImplementations might return true here if they believe …\nReturn the length of the longest needle in this Prefilter\nReturns the heap memory, in bytes, used by the underlying …\nCreate a new prefilter from a sequence of needles and a …\nReturns the span of a prefix of …\nThe total number of values that can be represented as a …\nThe total number of values that can be represented.\nThe total number of values that can be represented.\nThe maximum index value.\nThe maximum value.\nThe maximum value.\nA <code>usize</code> that can never be <code>usize::MAX</code>.\nThe identifier of a regex pattern, represented by a …\nThis error occurs when a value could not be constructed.\nThe number of bytes that a single small index uses in …\nThe number of bytes that a single value uses in memory.\nThe number of bytes that a single value uses in memory.\nA type that represents a “small” index.\nThis error occurs when a small index could not be …\nThe identifier of a finite automaton state, represented by …\nThis error occurs when a value could not be constructed.\nThe zero index value.\nThe zero value.\nThe zero value.\nReturn the internal <code>u32</code> of this small index represented as …\nReturn the internal value as a i32…\nReturn the internal value as a i32…\nReturn the internal <code>u32</code> of this small index. This is …\nReturn the internal value as a <code>u32</code>. This is guaranteed to …\nReturn the internal value as a <code>u32</code>. This is guaranteed to …\nReturn this small index as a <code>u64</code>. This is guaranteed to …\nReturn the internal value as a <code>u64</code>. This is guaranteed to …\nReturn the internal value as a <code>u64</code>. This is guaranteed to …\nReturn this small index as a <code>usize</code>. This is guaranteed to …\nReturn the internal value as a <code>usize</code>. This is guaranteed to\nReturn the internal value as a <code>usize</code>. This is guaranteed to\nReturns the value that could not be converted to a small …\nReturns the value that could not be converted to an ID.\nReturns the value that could not be converted to an ID.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode this small index from the bytes given using the …\nDecode this value from the bytes given using the native …\nDecode this value from the bytes given using the native …\nDecode this small index from the bytes given using the …\nDecode this value from the bytes given using the native …\nDecode this value from the bytes given using the native …\nReturn the underlying <code>usize</code> value. The returned value is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLike <code>SmallIndex::new</code>, but panics if the given index is not …\nLike <code>new</code>, but panics if the given value is not valid.\nLike <code>new</code>, but panics if the given value is not valid.\nCreate a new <code>NonMaxUsize</code> from the given value.\nCreate a new small index.\nCreate a new value that is represented by a “small index.…\nCreate a new value that is represented by a “small index.…\nCreate a new small index without checking whether the …\nCreate a new value without checking whether the given …\nCreate a new value without checking whether the given …\nReturns one more than this small index as a usize.\nReturns one more than this value as a usize.\nReturns one more than this value as a usize.\nReturn the underlying small index integer as raw bytes in …\nReturn the underlying integer as raw bytes in native endian\nReturn the underlying integer as raw bytes in native endian\nThe configuration used to determine a DFA’s start state …\nSet the anchored mode of a search.\nReturns the argument unchanged.\nA convenience routine for building a start configuration …\nA convenience routine for building a start configuration …\nReturn the anchored mode in this configuration.\nReturn the look-behind byte in this configuration, if one …\nCalls <code>U::from(self)</code>.\nSet the look-behind byte at the start of a search.\nCreate a new default start configuration.\nA common set of configuration options that apply to the …\nEnable or disable the case insensitive flag by default.\nEnable or disable the “CRLF mode” flag by default.\nEnable or disable the “dot matches any character” flag …\nReturns the argument unchanged.\nReturns whether “case insensitive” mode is enabled.\nReturns whether “CRLF” mode is enabled.\nReturns whether “dot matches new line” mode is enabled.\nReturns whether “ignore whitespace” mode is enabled.\nReturns the line terminator in this syntax configuration.\nReturns whether “multi line” mode is enabled.\nReturns the “nest limit” setting.\nReturns whether “octal” mode is enabled.\nReturns whether “swap greed” mode is enabled.\nReturns whether “unicode” mode is enabled.\nReturns whether UTF-8 mode is enabled.\nEnable verbose mode in the regular expression.\nCalls <code>U::from(self)</code>.\nSets the line terminator for use with <code>(?u-s:.)</code> and <code>(?-us:.)</code>…\nEnable or disable the multi-line matching flag by default.\nSet the nesting limit used for the regular expression …\nReturn a new default syntax configuration.\nWhether to support octal syntax or not.\nA convenience routine for parsing a pattern into an HIR …\nA convenience routine for parsing many patterns into HIR …\nA convenience routine for parsing many patterns into HIR …\nA convenience routine for parsing a pattern into an HIR …\nEnable or disable the “swap greed” flag by default.\nEnable or disable the Unicode flag (<code>u</code>) by default.\nWhen disabled, the builder will permit the construction of …\nA hack to align a smaller type <code>B</code> with a bigger type <code>T</code>.\nAn error that occurs when deserializing an object defined …\nAn error that occurs when serializing an object from this …\nA zero-sized field indicating the alignment we want.\nA possibly non-sized field containing a sequence of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")