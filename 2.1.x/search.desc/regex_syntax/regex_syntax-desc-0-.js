searchState.loadedDescShard("regex_syntax", 0, "This crate provides a robust regular expression parser.\nThis error type encompasses any error that can be returned …\nAn error that occurred while translating concrete syntax …\nA convenience parser for regular expressions.\nA builder for a regular expression parser.\nAn error that occurred while translating abstract syntax …\nAn error that occurs when the Unicode-aware <code>\\w</code> class is …\nDefines an abstract syntax for regular expressions.\nBuild a parser from this configuration with the given …\nEnable or disable the case insensitive flag by default.\nEnable or disable the CRLF mode flag by default.\nEnable or disable the “dot matches any character” flag …\nEscapes all regular expression meta characters in <code>text</code>.\nEscapes all meta characters in <code>text</code> and writes the result …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefines a high-level intermediate (HIR) representation for …\nEnable verbose mode in the regular expression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the given character can be escaped in a …\nReturns true if the given character has significance in a …\nReturns true if and only if the given character is an …\nReturns true if and only if the given character is a …\nSets the line terminator for use with <code>(?u-s:.)</code> and <code>(?-us:.)</code>…\nEnable or disable the multi-line matching flag by default.\nSet the nesting limit for this parser.\nCreate a new parser builder with a default configuration.\nCreate a new parser with a default configuration.\nWhether to support octal syntax or not.\nA convenience routine for parsing a regex using default …\nParse the regular expression into a high level intermediate\nEnable or disable the “swap greed” flag by default.\nReturns true if and only if the given character is a …\nEnable or disable the Unicode flag (<code>u</code>) by default.\nConverts ranges of Unicode scalar values to equivalent …\nWhen disabled, translation will permit the construction of …\n<code>[0-9A-Za-z]</code>\n<code>[A-Za-z]</code>\nAn alternation of regular expressions.\nAn alternation of regular expressions.\n<code>[\\x00-\\x7F]</code>\nAn ASCII character class, e.g., <code>[:alnum:]</code> or <code>[:punct:]</code>.\nA single zero-width assertion.\nA single zero-width assertion.\nAn assertion kind.\nAn abstract syntax tree for a single regular expression.\n<code>{m,}</code>\nBell, spelled <code>\\a</code> (<code>\\x07</code>).\nA single binary operation (i.e., &amp;&amp;, – or ~~).\n<code>[ \\t]</code>\n<code>{m,n}</code>\nA bracketed character class set, which may contain zero or …\n<code>R</code>\n<code>(a)</code>\nThe capturing group limit was exceeded.\nA capture name.\n<code>(?&lt;name&gt;a)</code> or <code>(?P&lt;name&gt;a)</code>\nCarriage return, spelled <code>\\r</code> (<code>\\x0D</code>).\n<code>i</code>\nAn ASCII character class.\nThe available ASCII character classes.\nA bracketed character class, e.g., <code>[a-z0-9]</code>.\nA single bracketed character class set, which may contain …\nAn invalid escape sequence was found in a character class …\nA Perl character class.\nA single perl character class, e.g., <code>\\d</code> or <code>\\W</code>.\nThe available Perl character classes.\nAn invalid character class range was found. An invalid …\nAn invalid range boundary was found in a character class. …\nA character class set.\nA Unicode character class set operation.\nThe type of a Unicode character class set operation.\nA single component of a character class set.\nA single character class range in a set.\nA union of items inside a character class set.\nAn opening <code>[</code> was found with no corresponding closing <code>]</code>.\nA Unicode character class.\nA single Unicode character class, e.g., <code>\\pL</code> or <code>\\p{Greek}</code>.\nThe available forms of Unicode character classes.\nThe type of op used in a Unicode character class.\n<code>[\\x00-\\x1F\\x7F]</code>\nA property set to a specific value using a colon, e.g., …\nA comment from a regular expression with an associated …\nA concatenation of regular expressions.\nA concatenation of regular expressions.\nNote that this error variant is no longer used. Namely, a …\nAn invalid decimal number was given where one was expected.\nThe difference of two sets, e.g., <code>\\pN--[0-9]</code>.\nDecimal numbers.\n<code>[0-9]</code>\nThe “any character” class.\n<code>s</code>\nAn empty regex that matches everything.\nAn empty item.\n<code>$</code>\n<code>\\z</code>\nA property set to a specific value, e.g., <code>\\p{scx=Katakana}</code>.\nAn error that visiting an AST might return.\nAn error that occurred while parsing a regular expression …\nThe type of an error that occurred while building an AST.\nA bracketed hex literal was empty.\nA bracketed hex literal did not correspond to a Unicode …\nAn invalid hexadecimal digit was found.\nEOF was found before an escape sequence was completed.\nAn unrecognized escape sequence.\n<code>{m}</code>\nA single flag.\nA single flag in a group.\nA dangling negation was used when setting flags, e.g., <code>i-</code>.\nA flag was used twice, e.g., <code>i-i</code>.\nThe negation operator was used twice, e.g., <code>-i-s</code>.\nExpected a flag but got EOF, e.g., <code>(?</code>.\nUnrecognized flag, e.g., <code>a</code>.\nA group of flags.\nA set of flags, e.g., <code>(?is)</code>.\nA single item in a group of flags.\nThe kind of an item in a group of flags.\nForm feed, spelled <code>\\f</code> (<code>\\x0C</code>).\n<code>[!-~]</code>\nA grouped regular expression.\nA grouped regular expression.\nThe kind of a group.\nA duplicate capture name was found.\nA capture group name is empty, e.g., <code>(?P&lt;&gt;abc)</code>.\nAn invalid character was seen for a capture group name. …\nA closing <code>&gt;</code> could not be found for a capture group name.\nAn unclosed group, e.g., <code>(ab</code>.\nAn unopened group, e.g., <code>ab)</code>.\nThe literal is written as a hex code with a bracketed …\nThe literal is written as a hex code with a fixed number …\nThe type of a Unicode hex literal.\n<code>x</code>\nThe intersection of two sets, e.g., <code>\\pN&amp;&amp;[a-z]</code>.\nAn item, which can be a single literal, range, nested …\nLine feed, spelled <code>\\n</code> (<code>\\x0A</code>).\nA single literal expression.\nA single character literal, which includes escape …\nA single literal.\nThe kind of a single literal expression.\n<code>[a-z]</code>\nThe literal is written as an escape because it is …\n<code>m</code>\nA binary property, general category or script. The string …\nA property name and an associated value.\nA negation operator applied to all subsequent flags in the …\nThe nest limit was exceeded. The limit stored here is the …\n<code>(?:a)</code> and <code>(?i:a)</code>\nA property that isn’t a particular value, e.g., …\n<code>\\B</code>\nThe literal is written as an octal escape, e.g., <code>\\141</code>.\nA one letter abbreviated class, e.g., <code>\\pN</code>.\n<code>+</code>\nThe result of visiting an AST.\nA perl character class, e.g., <code>\\d</code> or <code>\\W</code>.\nA single position in a regular expression.\n<code>[ -~]</code>\n<code>[!-/:-@\\[-</code>{-~]`\nA range between two literals.\n<code>{m,n}</code>\nA repetition operation applied to a regular expression.\nA repetition operator applied to an arbitrary regular …\nAn opening <code>{</code> was not followed by a valid decimal value. …\nThe range provided in a counted repetition operator is …\nAn opening <code>{</code> was found with no corresponding closing <code>}</code>.\nThe kind of a repetition operator.\nA repetition operator was applied to a missing …\nThe repetition operator itself.\nA range repetition operator.\nA group of flags that is not applied to a particular …\nSpace, spelled <code>\\ </code> (<code>\\x20</code>). Note that this can only appear …\nWhitespace.\n<code>[\\t\\n\\v\\f\\r ]</code>\nSpan represents the position information of a single AST …\nThe literal is written as a specially recognized escape, …\nThe type of a special literal.\nThe special word boundary syntax, <code>\\b{something}</code>, was used, …\nThe special word boundary syntax, <code>\\b{something}</code>, was used, …\nThe syntax <code>\\b{</code> was observed, but afterwards the end of the …\n<code>^</code>\n<code>\\A</code>\nThe literal is written as an escape despite the fact that …\n<code>U</code>\nThe symmetric difference of two sets. The symmetric …\nTab, spelled <code>\\t</code> (<code>\\x09</code>).\nA Unicode character class, e.g., <code>\\pL</code> or <code>\\p{Greek}</code>.\n<code>u</code>\nThe Unicode class is not valid. This typically occurs when …\nA <code>\\U</code> prefix. When used without brackets, this form is …\nA <code>\\u</code> prefix. When used without brackets, this form is …\nA union of items.\nWhen octal support is disabled, this error is produced …\nWhen syntax similar to PCRE’s look-around is used, this …\n<code>[A-Z]</code>\nThe literal is written verbatim, e.g., <code>a</code> or <code>☃</code>.\nVertical tab, spelled <code>\\v</code> (<code>\\x0B</code>).\nA trait for visiting an abstract syntax tree (AST) in …\nAn abstract syntax tree for a singular expression along …\nWord characters.\n<code>[0-9A-Za-z_]</code>\n<code>\\b</code>\n<code>\\b{end}</code>\n<code>\\&gt;</code> (alias for <code>\\b{end}</code>)\n<code>\\b{end-half}</code>\n<code>\\b{start}</code>\n<code>\\&lt;</code> (alias for <code>\\b{start}</code>)\n<code>\\b{start-half}</code>\nA <code>\\x</code> prefix. When used without brackets, this form is …\n<code>[0-9A-Fa-f]</code>\n<code>*</code>\n<code>?</code>\nAdd the given item to this sequence of flags.\nCreate a “alternation” AST item.\nCreate a “assertion” AST item.\nThe actual ast.\nThe regular expression under repetition.\nThe regular expression in this group.\nThe alternate regular expressions.\nThe concatenation regular expressions.\nReturn an auxiliary span. This span exists only for some …\nIf this literal was written as a <code>\\x</code> hex escape, then this …\nThe Unicode scalar value corresponding to this literal.\nReturns the capture index of this group, if this is a …\nCreate a “bracketed class” AST item.\nCreate a “Perl class” AST item.\nCreate a “Unicode class” AST item.\nThe approximate column number, starting at <code>1</code>.\nThe comment text, starting with the first character …\nAll comments found in the original regular expression.\nCreate a “concat” AST item.\nThe number of digits that must be used with this literal …\nCreate a “dot” AST item.\nCreate an “empty” AST item.\nThe end byte offset.\nThe end of this range.\nAll implementors of <code>Visitor</code> must provide a <code>finish</code> method, …\nReturns the state of the given flag in this set.\nCreate a “flags” AST item.\nIf this group is non-capturing, then this returns the …\nThe actual sequence of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the corresponding ClassAsciiKind variant for the …\nWhether this operation was applied greedily or not.\nCreate a “group” AST item.\nThe capture index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn this alternation as an AST.\nReturn this concatenation as an AST.\nReturn this union as a character class set item.\nReturns true if and only if this group is capturing.\nReturns true if and only if this span is empty. That is, …\nReturn true if and only if this Ast is empty.\nWhether the op is an equality op or not.\nReturns true if this class has been negated.\nReturns true if and only if this item is a negation …\nReturns true if and only if this span occurs on a single …\nReturns true if and only if this character class range is …\nReturns true if and only if this repetition range is valid.\nThe sequence of items that make up this union.\nA sequence of flag items. Each item is either a flag or a …\nReturn the type of this error.\nThe kind of this literal.\nThe kind of Perl class.\nThe kind of ASCII class.\nThe kind of Unicode class.\nThe type of this set. A set is either a normal union of …\nThe type of this set operation.\nThe assertion kind, e.g., <code>\\b</code> or <code>^</code>.\nThe type of operation.\nThe kind of this group.\nThe kind of this item.\nThe left hand side of the operation.\nThe line number, starting at <code>1</code>.\nCreate a “literal” AST item.\nThe capture name.\nWhether the class is negated or not. e.g., <code>\\d</code> is not …\nWhether the class is negated or not. e.g., <code>[[:alpha:]]</code> is …\nWhether this class is negated or not.\nWhether this class is negated or not. e.g., <code>[a]</code> is not …\nCreate a new span with the given positions.\nCreate a new position with the given information.\nThe absolute offset of this position, starting at <code>0</code> from …\nThe actual operation.\nThis module provides a regular expression parser.\nThe original pattern string in which this error occurred.\nThis module provides a regular expression printer for <code>Ast</code>.\nPush a new item in this union.\nCreate a “repetition” AST item.\nThe right hand side of the operation.\nReturn the span at which this error occurred.\nReturn the span of this abstract syntax tree.\nReturn the span of this character class set.\nReturn the span of this character class set item.\nThe span of this comment, including the beginning <code>#</code> and …\nThe span of this alternation.\nThe span of this concatenation.\nThe span of this literal.\nThe span of this class.\nThe span of this class.\nThe span of this class.\nThe span of this class.\nThe span of this range.\nThe span of the items in this operation. e.g., the <code>a-z0-9</code> …\nThe span of this operation. e.g., the <code>a-z--[h-p]</code> in …\nThe span of this assertion.\nThe span of this operation.\nThe span of this operator. This includes things like <code>+</code>, <code>*?</code> …\nThe span of this group.\nThe span of this capture name.\nThe span of these flags, including the grouping …\nThe span of this group of flags.\nThe span of this item.\nCreate a new span using the given position as the start …\nThis method is called before beginning traversal of the …\nThis method is called before beginning traversal of the …\nThe start byte offset.\nThe start of this range.\nBuild a set from a union.\nExecutes an implementation of <code>Visitor</code> in constant stack …\nThis method is called between child nodes of an <code>Alternation</code>…\nThis method is called between child nodes of an <code>Alternation</code>…\nThis method is called between the left hand and right hand …\nThis method is called between the left hand and right hand …\nThis method is called on every <code>ClassSetBinaryOp</code> after …\nThis method is called on every <code>ClassSetBinaryOp</code> after …\nThis method is called on every <code>ClassSetBinaryOp</code> before …\nThis method is called on every <code>ClassSetBinaryOp</code> before …\nThis method is called on every <code>ClassSetItem</code> after …\nThis method is called on every <code>ClassSetItem</code> after …\nThis method is called on every <code>ClassSetItem</code> before …\nThis method is called on every <code>ClassSetItem</code> before …\nThis method is called between child nodes of a …\nThis method is called between child nodes of a …\nThis method is called on an <code>Ast</code> after descending all of …\nThis method is called on an <code>Ast</code> after descending all of …\nThis method is called on an <code>Ast</code> before descending into …\nThis method is called on an <code>Ast</code> before descending into …\nCreate a new span by replacing the ending the position …\nCreate a new span by replacing the starting the position …\nThe property name (which may be empty).\nThe type of Unicode op used to associate <code>name</code> with <code>value</code>.\nThe property value (which may be empty).\nThe position of the original flag. The error position …\nThe position of the original negation operator. The error …\nThe position of the initial occurrence of the capture …\nThe capture name.\nTrue if the <code>?P&lt;</code> syntax is used and false if the <code>?&lt;</code> syntax …\nA regular expression parser.\nA builder for a regular expression parser.\nBuild a parser from this configuration with the given …\nAllow using <code>{,n}</code> as an equivalent to <code>{0,n}</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEnable verbose mode in the regular expression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the nesting limit for this parser.\nCreate a new parser builder with a default configuration.\nCreate a new parser with a default configuration.\nWhether to support octal syntax or not.\nParse the regular expression into an abstract syntax tree.\nParse the regular expression and return an abstract syntax …\nA printer for a regular expression abstract syntax tree.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new printer.\nPrint the given <code>Ast</code> to the given writer. The writer must …\nAn alternation of expressions.\nMatches any byte value.\nMatches any byte value except for the <code>u8</code> given.\nMatches any byte value except for <code>\\r</code> and <code>\\n</code>.\nMatches any byte value except for <code>\\n</code>.\nMatches the UTF-8 encoding of any Unicode scalar value.\nMatches the UTF-8 encoding of any Unicode scalar value …\nMatches the UTF-8 encoding of any Unicode scalar value …\nMatches the UTF-8 encoding of any Unicode scalar value …\nA set of characters represented by arbitrary bytes (one …\nThe high-level intermediate representation for a capturing …\nA capturing group, which contains a sub-expression.\nAn error that occurs when Unicode-aware simple case …\nThe high-level intermediate representation of a character …\nA single character class that matches any of the …\nA set of characters represented by arbitrary bytes.\nAn iterator over all ranges in a byte character class.\nA single range of characters represented by arbitrary …\nA set of characters represented by Unicode scalar values.\nAn iterator over all ranges in a Unicode character class.\nA single range of characters represented by Unicode scalar …\nA concatenation of expressions.\nA type describing the different flavors of <code>.</code>.\nThe empty regular expression, which matches everything, …\nMatch the end of text. Specifically, this matches at the …\nMatch the end of a line or the end of text. Specifically, …\nMatch the end of a line or the end of text. Specifically, …\nAn error that visiting an HIR might return.\nAn error that can occur while translating an <code>Ast</code> to a <code>Hir</code>.\nThe type of an error that occurred while building an <code>Hir</code>.\nA high-level intermediate representation (HIR) for a …\nThe underlying kind of an arbitrary <code>Hir</code> expression.\nThis error occurs when one uses a non-ASCII byte for a …\nThis error occurs when translating a pattern that could …\nThe high-level intermediate representation of a literal.\nA literalstring that matches exactly these bytes.\nThe high-level intermediate representation for a …\nA look-around assertion. A look-around match always has …\nA set of look-around assertions.\nAn iterator over all look-around assertions in a <code>LookSet</code>.\nThe result of visiting an HIR.\nA type that collects various properties of an HIR value.\nThe high-level intermediate representation of a repetition …\nA repetition operation applied to a sub-expression.\nMatch the beginning of text. Specifically, this matches at …\nMatch the beginning of a line or the beginning of text. …\nMatch the beginning of a line or the beginning of text. …\nA set of characters represented by Unicode scalar values.\nThis occurs when the Unicode simple case mapping tables …\nThis error occurs when a Unicode feature is used when …\nThis occurs when a Unicode-aware Perl character class (<code>\\w</code>, …\nThis occurs when an unrecognized Unicode property name …\nThis occurs when an unrecognized Unicode property value …\nA trait for visiting the high-level IR (HIR) in depth …\nMatch an ASCII-only word boundary. That is, this matches a …\nMatch an ASCII-only negation of a word boundary.\nMatch the end of an ASCII-only word boundary. That is, …\nMatch the end half of an ASCII-only word boundary. That …\nMatch the end half of a Unicode word boundary. That is, …\nMatch the end of a Unicode word boundary. That is, this …\nMatch the start of an ASCII-only word boundary. That is, …\nMatch the start half of an ASCII-only word boundary. That …\nMatch the start half of a Unicode word boundary. That is, …\nMatch the start of a Unicode word boundary. That is, this …\nMatch a Unicode-aware word boundary. That is, this matches …\nMatch a Unicode-aware negation of a word boundary.\nReturns the alternation of the given expressions.\nReturns a convenient single codepoint representation of …\nReturn the underlying representation of this look-around …\nThe underlying representation this set is exposed to make …\nCreates a capture HIR expression.\nApply Unicode simple case folding to this character class, …\nExpand this character class such that it contains all case …\nExpand this character class such that it contains all case …\nCreates a class HIR expression. The class may either be …\nReturns the concatenation of the given expressions.\nReturns true if and only if the given look-around …\nReturns true if and only if this set contains any anchor …\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any word …\nReturns true if and only if this set contains any ASCII …\nReturns true if and only if this set contains any Unicode …\nSubtract the given character class from this character …\nSubtract the given byte class from this byte class, in …\nReturns an HIR expression for <code>.</code>.\nReturns an empty HIR expression.\nCreate a new class with no ranges.\nCreate a new class with no ranges.\nCreate an empty set of look-around assertions.\nReturn the end of this range.\nReturn the end of this range.\nReturns the total number of explicit capturing groups in …\nReturns an HIR expression that can never match anything. …\nAll implementors of <code>Visitor</code> must provide a <code>finish</code> method, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven the underlying representation of a <code>Look</code> value, …\nCreate a full set of look-around assertions.\nWhether this repetition operator is greedy or not. A …\nThe capture index of the capture.\nReturn a new set that is equivalent to the original, but …\nIntersect this character class with the given character …\nIntersect this byte class with the given byte class, in …\nReturns a new set that is the intersection of this and the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes ownership of this HIR expression and returns its …\nReturn true if and only if this HIR is either a simple …\nReturns true if and only if this character class will …\nReturns true if and only if this character class will …\nReturns true if and only if this character class is empty. …\nReturns true if and only if this set is empty.\nReturn true if and only if this HIR is a simple literal. …\nReturns true if and only if this character class will only …\nReturn true if and only if the corresponding HIR will …\nReturn an iterator over all ranges in this class.\nReturn an iterator over all ranges in this class.\nReturns an iterator over all of the look-around assertions …\nReturn the type of this error.\nReturns a reference to the underlying HIR kind.\nReturns the number of codepoints in this range.\nReturns the number of bytes in this range.\nReturns the total number of look-around assertions in this …\nProvides literal extraction from <code>Hir</code> expressions.\nCreates a literal HIR expression.\nIf this class consists of exactly one element (whether a …\nIf this class consists of exactly one codepoint, then …\nIf this class consists of exactly one byte, then return it …\nCreates a look-around assertion HIR expression.\nReturns a set of all look-around assertions that appear at …\nReturns a set of all look-around assertions that appear as …\nReturns a set of all look-around assertions that appear as …\nReturns a set of all look-around assertions that appear as …\nReturns a set of all look-around assertions that appear as …\nThe maximum range of the repetition.\nReturns the length, in bytes, of the longest string …\nReturns the length, in bytes, of the longest string …\nReturns the length, in bytes, of the longest string …\nReturns the length (in bytes) of the longest string …\nReturns the total amount of heap memory usage, in bytes, …\nThe minimum range of the repetition.\nReturns the length, in bytes, of the smallest string …\nReturns the length, in bytes, of the smallest string …\nReturns the length, in bytes, of the smallest string …\nReturns the length (in bytes) of the smallest string …\nThe name of the capture, if it exists.\nNegate this character class in place.\nNegate this character class.\nNegate this byte class.\nCreate a new class from a sequence of ranges.\nCreate a new Unicode scalar value range for a character …\nCreate a new class from a sequence of ranges.\nCreate a new byte range for a character class.\nThe original pattern string in which this error occurred.\nThis module provides a regular expression printer for <code>Hir</code>.\nReturns the properties computed for this <code>Hir</code>.\nAdd a new range to this set.\nAdd a new range to this set.\nReturn the underlying ranges as a slice.\nReturn the underlying ranges as a slice.\nReturn a <code>LookSet</code> from the slice given as a native endian …\nReturn a new set that is equivalent to the original, but …\nCreates a repetition HIR expression.\nFlip the look-around assertion to its equivalent for …\nUpdates this set in place with the result of inserting the …\nUpdates this set in place with the result of intersecting …\nUpdates this set in place with the result of removing the …\nUpdates this set in place with the result of subtracting …\nUpdates this set in place with the result of unioning it …\nCreate a look-around set containing the look-around …\nReturn the span at which this error occurred.\nThis method is called before beginning traversal of the …\nThis method is called before beginning traversal of the …\nReturn the start of this range.\nReturn the start of this range.\nReturns the total number of explicit capturing groups that …\nThe expression inside the capturing group, which may be …\nThe expression being repeated.\nReturns a slice of this kind’s sub-expressions, if any.\nReturns a new set that is the result of subtracting the …\nCompute the symmetric difference of the given character …\nCompute the symmetric difference of the given byte …\nIf this class consists of only ASCII ranges, then return …\nIf this class consists of only ASCII ranges, then return …\nDefines a translator that converts an <code>Ast</code> to an <code>Hir</code>.\nApply Unicode simple case folding to this character class, …\nExpand this character class such that it contains all case …\nUnion this character class with the given character class, …\nUnion this byte class with the given byte class, in place.\nReturns a new set of properties that corresponds to the …\nReturns a new set that is the union of this and the one …\nExecutes an implementation of <code>Visitor</code> in constant stack …\nThis method is called between child nodes of an …\nThis method is called between child nodes of an …\nThis method is called between child nodes of a …\nThis method is called between child nodes of a …\nThis method is called on an <code>Hir</code> after descending all of …\nThis method is called on an <code>Hir</code> after descending all of …\nThis method is called on an <code>Hir</code> before descending into …\nThis method is called on an <code>Hir</code> before descending into …\nReturns a new repetition with the same <code>min</code>, <code>max</code> and <code>greedy</code> …\nWrite a <code>LookSet</code> as a native endian 32-bit integer to the …\nThe kind of literals to extract from an <code>Hir</code> expression.\nExtracts prefix or suffix literal sequences from <code>Hir</code> …\nA single literal extracted from an <code>Hir</code> expression.\nExtracts only prefix literals from a regex.\nA sequence of literals.\nExtracts only suffix literals from a regex.\nReturns the bytes in this literal.\nModify this sequence to contain the cross product between …\nModify this sequence to contain the cross product between …\nDeduplicate adjacent equivalent literals in this sequence.\nReturns an empty sequence.\nReturns a new exact literal containing the bytes given.\nExtend this literal with the literal given.\nExecute the extractor and return a sequence of literals.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a new inexact literal containing the bytes given.\nReturns a sequence of literals without a finite size and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nYields ownership of the bytes inside this literal.\nReturns true if and only if this sequence is finite and …\nReturns true if and only if this literal has zero bytes.\nReturns true if and only if all literals in this sequence …\nReturns true if and only if this literal is exact.\nReturns true if this sequence is finite.\nReturns true if and only if all literals in this sequence …\nReturns true if this kind is the <code>Prefix</code> variant.\nReturns true if this kind is the <code>Suffix</code> variant.\nTrims all literals in this seq such that only the first <code>len</code>…\nTrims this literal such that only the first <code>len</code> bytes …\nTrims all literals in this seq such that only the last <code>len</code> …\nTrims this literal such that only the last <code>len</code> bytes …\nSet the kind of literal sequence to extract from an <code>Hir</code> …\nReturns the number of literals in this sequence if the …\nReturns the length of this literal in bytes.\nConfigure a limit on the length of the sequence that is …\nConfigure a limit on the maximum length of any literal in …\nConfigure a limit on the total number of repetitions that …\nConfigure a limit on the total number of literals that …\nIf this is a finite sequence, return its members as a …\nReturns the longest common prefix from this seq.\nReturns the longest common suffix from this seq.\nMake all of the literals in this sequence inexact.\nMarks this literal as inexact.\nConverts this sequence to an infinite sequence.\nReturn the maximum length of the sequence that would …\nReturns the length of the longest literal in this sequence.\nReturn the maximum length of the sequence that would …\nReturns the length of the shortest literal in this …\nShrinks this seq to its minimal size while respecting the …\nCreate a new extractor with a default configuration.\nReturns a sequence of exact literals from the given byte …\nOptimizes this seq while treating its literals as prefixes …\nOptimizes this seq while treating its literals as suffixes …\nPush a literal to the end of this sequence.\nReturns the “rank” of the given byte.\nReverse the bytes in this literal.\nReverses all of the literals in this sequence.\nReturns a sequence containing a single literal.\nSorts this sequence of literals lexicographically.\nUnions the <code>other</code> sequence into this one.\nUnions the <code>other</code> sequence into this one by splice the <code>other</code>\nA printer for a regular expression’s high-level …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new printer.\nPrint the given <code>Ast</code> to the given writer. The writer must …\nA translator maps abstract syntax to a high level …\nA builder for constructing an AST-&gt;HIR translator.\nBuild a translator using the current configuration.\nEnable or disable the case insensitive flag (<code>i</code>) by default.\nEnable or disable the CRLF mode flag (<code>R</code>) by default.\nEnable or disable the “dot matches any character” flag …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSets the line terminator for use with <code>(?u-s:.)</code> and <code>(?-us:.)</code>…\nEnable or disable the multi-line matching flag (<code>m</code>) by …\nCreate a new translator builder with a default c …\nCreate a new translator using the default configuration.\nEnable or disable the “swap greed” flag (<code>U</code>) by default.\nTranslate the given abstract syntax tree (AST) into a high …\nEnable or disable the Unicode flag (<code>u</code>) by default.\nWhen disabled, translation will permit the construction of …\nFour successive byte ranges.\nOne byte range.\nThree successive byte ranges.\nTwo successive byte ranges.\nA single inclusive range of UTF-8 bytes.\nUtf8Sequence represents a sequence of byte ranges.\nAn iterator over ranges of matching UTF-8 byte sequences.\nReturns the underlying sequence of byte ranges as a slice.\nEnd of byte range (inclusive).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of byte ranges in this sequence.\nReturns true if and only if a prefix of <code>bytes</code> matches this …\nReturns true if and only if the given byte is in this …\nCreate a new iterator over UTF-8 byte ranges for the …\nReverses the ranges in this sequence.\nStart of byte range (inclusive).")