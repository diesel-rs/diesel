<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implements `QueryableByName` for untyped sql queries, such as that one generated by `sql_query`"><title>QueryableByName in diesel::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-081576b923113409.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="diesel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (e3181b091 2024-04-18)" data-channel="nightly" data-search-js="search-5b46ae87cc198d72.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-e32f0c247825364d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../diesel/index.html">diesel</a><span class="version">2.1.6</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In diesel::prelude</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../diesel/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Derive Macro <a href="../index.html">diesel</a>::<wbr><a href="index.html">prelude</a>::<wbr><a class="derive" href="#">QueryableByName</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/diesel_derives/lib.rs.html#827">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[derive(QueryableByName)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[diesel]
    #[table_name]
    #[column_name]
    #[sql_type]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implements <code>QueryableByName</code> for untyped sql queries, such as that one generated
by <code>sql_query</code></p>
<p>To derive this trait, Diesel needs to know the SQL type of each field.
It can get the data from the corresponding table type.
It uses the <code>snake_case</code> type name with an added <code>s</code>.
It is possible to change this default by using <code>#[diesel(table_name = something)]</code>.
If you define use the table type, the SQL type will be
<code>diesel::dsl::SqlTypeOf&lt;table_name::column_name&gt;</code>. In cases which there are no table type,
you can do the same by annotating each field with <code>#[diesel(sql_type = SomeType)]</code>.</p>
<p>If the name of a field on your struct is different from the column in your
<code>table!</code> declaration, or if you’re deriving this trait on a tuple struct,
you can annotate the field with <code>#[diesel(column_name = some_column)]</code>. For tuple
structs, all fields must have this annotation.</p>
<p>If a field is another struct which implements <code>QueryableByName</code>,
instead of a column, you can annotate that with <code>#[diesel(embed)]</code>.
Then all fields contained by that inner struct are loaded into the embedded struct.</p>
<p>To provide custom deserialization behavior for a field, you can use
<code>#[diesel(deserialize_as = SomeType)]</code>. If this attribute is present, Diesel
will deserialize the corresponding field into <code>SomeType</code>, rather than the
actual field type on your struct and then call <code>.into</code> to convert it to the
actual field type. This can be used to add custom behavior for a
single field, or use types that are otherwise unsupported by Diesel.</p>
<h2 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h2><h3 id="optional-container-attributes"><a class="doc-anchor" href="#optional-container-attributes">§</a>Optional container attributes</h3>
<ul>
<li><code>#[diesel(table_name = path::to::table)]</code>, to specify that this type contains
columns for the specified table. The path is relative to the current module.
If no field attributes are specified the derive will use the sql type of
the corresponding column.</li>
<li><code>#[diesel(check_for_backend(diesel::pg::Pg, diesel::mysql::Mysql))]</code>, instructs
the derive to generate additional code to identify potential type mismatches.
It accepts a list of backend types to check the types against. Using this option
will result in much better error messages in cases where some types in your <code>QueryableByName</code>
struct don’t match. You need to specify the concrete database backend
this specific struct is indented to be used with, as otherwise rustc can’t correctly
identify the required deserialization implementation.</li>
</ul>
<h3 id="optional-field-attributes"><a class="doc-anchor" href="#optional-field-attributes">§</a>Optional field attributes</h3>
<ul>
<li><code>#[diesel(column_name = some_column)]</code>, overrides the column name for
a given field. If not set, the name of the field is used as a column
name. This attribute is required on tuple structs, if
<code>#[diesel(table_name = some_table)]</code> is used, otherwise it’s optional.</li>
<li><code>#[diesel(sql_type = SomeType)]</code>, assumes <code>SomeType</code> as sql type of the
corresponding field. These attributes have precedence over all other
variants to specify the sql type.</li>
<li><code>#[diesel(deserialize_as = Type)]</code>, instead of deserializing directly
into the field type, the implementation will deserialize into <code>Type</code>.
Then <code>Type</code> is converted via <code>.into()</code> into the field type. By default,
this derive will deserialize directly into the field type</li>
<li><code>#[diesel(embed)]</code>, specifies that the current field maps not only
a single database column, but it is a type that implements
<code>QueryableByName</code> on its own</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>If we just want to map a query to our struct, we can use <code>derive</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(QueryableByName, PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}

<span class="kw">let </span>first_user = sql_query(<span class="string">"SELECT * FROM users ORDER BY id LIMIT 1"</span>)
    .get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User { id: <span class="number">1</span>, name: <span class="string">"Sean"</span>.into() };
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
<p>If we want to do additional work during deserialization, we can use
<code>deserialize_as</code> to use a different implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>LowercaseString(String);

<span class="kw">impl </span>Into&lt;String&gt; <span class="kw">for </span>LowercaseString {
    <span class="kw">fn </span>into(<span class="self">self</span>) -&gt; String {
        <span class="self">self</span>.<span class="number">0
    </span>}
}

<span class="kw">impl</span>&lt;DB, ST&gt; FromSql&lt;ST, DB&gt; <span class="kw">for </span>LowercaseString
<span class="kw">where
    </span>DB: Backend,
    String: FromSql&lt;ST, DB&gt;,
{
    <span class="kw">fn </span>from_sql(bytes: DB::RawValue&lt;<span class="lifetime">'_</span>&gt;) -&gt; deserialize::Result&lt;<span class="self">Self</span>&gt; {
        String::from_sql(bytes)
            .map(|s| LowercaseString(s.to_lowercase()))
    }
}

<span class="attr">#[derive(QueryableByName, PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    <span class="attr">#[diesel(deserialize_as = LowercaseString)]
    </span>name: String,
}

<span class="kw">let </span>first_user = sql_query(<span class="string">"SELECT * FROM users ORDER BY id LIMIT 1"</span>)
    .get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User { id: <span class="number">1</span>, name: <span class="string">"sean"</span>.into() };
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
<p>The custom derive generates impls similar to the following one</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}

<span class="kw">impl</span>&lt;DB&gt; QueryableByName&lt;DB&gt; <span class="kw">for </span>User
<span class="kw">where
    </span>DB: Backend,
    i32: FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::id&gt;, DB&gt;,
    String: FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::name&gt;, DB&gt;,
{
    <span class="kw">fn </span>build&lt;<span class="lifetime">'a</span>&gt;(row: <span class="kw-2">&amp;</span><span class="kw">impl </span>NamedRow&lt;<span class="lifetime">'a</span>, DB&gt;) -&gt; deserialize::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>id = NamedRow::get::&lt;diesel::dsl::SqlTypeOf&lt;users::id&gt;, <span class="kw">_</span>&gt;(row, <span class="string">"id"</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>name = NamedRow::get::&lt;diesel::dsl::SqlTypeOf&lt;users::name&gt;, <span class="kw">_</span>&gt;(row, <span class="string">"name"</span>)<span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{ id, name })
    }
}

<span class="kw">let </span>first_user = sql_query(<span class="string">"SELECT * FROM users ORDER BY id LIMIT 1"</span>)
    .get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User { id: <span class="number">1</span>, name: <span class="string">"Sean"</span>.into() };
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
</div></details></section></div></main></body></html>