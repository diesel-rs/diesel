<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Automatically annotates return type of a query fragment function"><title>auto_type in diesel_derives - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="diesel_derives" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (975e6c8fe 2025-09-23)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">auto_type</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../diesel_derives/index.html">diesel_<wbr>derives</a><span class="version">2.3.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">auto_<wbr>type</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li><li><a href="#limitations" title="Limitations">Limitations</a></li><li><a href="#advanced-usage" title="Advanced usage">Advanced usage</a><ul><li><a href="#annotating-types" title="Annotating types">Annotating types</a></li></ul></li><li><a href="#expanded-code" title="Expanded Code">Expanded Code</a><ul><li><a href="#input" title="Input">Input</a></li><li><a href="#expanded-code-1" title="Expanded Code">Expanded Code</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate diesel_<wbr>derives</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">diesel_derives</a></div><h1>Attribute Macro <span class="attr">auto_<wbr>type</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/diesel_derives/lib.rs.html#1806-1811">Source</a> </span></div><pre class="rust item-decl"><code>#[auto_type]</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Automatically annotates return type of a query fragment function</p>
<p>This may be useful when factoring out common query fragments into functions.
If not using this, it would typically involve explicitly writing the full
type of the query fragment function, which depending on the length of said
query fragment can be quite difficult (especially to maintain) and verbose.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::dsl;

<span class="attr">#[dsl::auto_type]
</span><span class="kw">fn </span>user_has_post() -&gt; <span class="kw">_ </span>{
    dsl::exists(posts::table.filter(posts::user_id.eq(users::id)))
}

<span class="kw">let </span>users_with_posts: Vec&lt;String&gt; = users::table
    .filter(user_has_post())
    .select(users::name)
    .load(conn)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(
    <span class="kw-2">&amp;</span>[<span class="string">"Sean"</span>, <span class="string">"Tess"</span>] <span class="kw">as </span><span class="kw-2">&amp;</span>[<span class="kw">_</span>],
    users_with_posts
        .iter()
        .map(|s| s.as_str())
        .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;()
);</code></pre></div><h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2>
<p>While this attribute tries to support as much of diesels built-in DSL as possible it’s
unfortunately not possible to support everything. Notable unsupported types are:</p>
<ul>
<li>Update statements</li>
<li>Insert from select statements</li>
<li>Query constructed by <code>diesel::sql_query</code></li>
<li>Expressions using <code>diesel::dsl::sql</code></li>
</ul>
<p>For these cases a manual type annotation is required. See the “Annotating Types” section below
for details.</p>
<h2 id="advanced-usage"><a class="doc-anchor" href="#advanced-usage">§</a>Advanced usage</h2>
<p>By default, the macro will:</p>
<ul>
<li>Generate a type alias for the return type of the function, named the
exact same way as the function itself.</li>
<li>Assume that functions, unless otherwise annotated, have a type alias for
their return type available at the same path as the function itself
(including case). (e.g. for the <code>dsl::not(x)</code> call, it expects that there
is a <code>dsl::not&lt;X&gt;</code> type alias available)</li>
<li>Assume that methods, unless otherwise annotated, have a type alias
available as <code>diesel::dsl::PascalCaseOfMethodName</code> (e.g. for the
<code>x.and(y)</code> call, it expects that there is a <code>diesel::dsl::And&lt;X, Y&gt;</code> type
alias available)</li>
</ul>
<p>The defaults can be changed by passing the following attributes to the
macro:</p>
<ul>
<li><code>#[auto_type(no_type_alias)]</code> to disable the generation of the type alias.</li>
<li><code>#[auto_type(dsl_path = "path::to::dsl")]</code> to change the path where the
macro will look for type aliases for methods. This is required if you mix your own
custom query dsl extensions with diesel types. In that case, you may use this argument to
reference a module defined like so:
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>dsl {
    <span class="doccomment">/// export all of diesel dsl
    </span><span class="kw">pub use </span>diesel::dsl::<span class="kw-2">*</span>;
  
    <span class="doccomment">/// Export your extension types here
    </span><span class="kw">pub use </span><span class="kw">crate</span>::your_extension::dsl::YourType;
 }</code></pre></div></li>
<li><code>#[auto_type(type_case = "snake_case")]</code> to change the case of the
method type alias.</li>
</ul>
<p>The <code>dsl_path</code> attribute in particular may be used to declare an
intermediate module where you would define the few additional needed type
aliases that can’t be inferred automatically.</p>
<h3 id="annotating-types"><a class="doc-anchor" href="#annotating-types">§</a>Annotating types</h3>
<p>Sometimes the macro can’t infer the type of a particular sub-expression. In
that case, you can annotate the type of the sub-expression:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>diesel::dsl;

<span class="comment">// This will generate a `user_has_post_with_id_greater_than` type alias
</span><span class="attr">#[dsl::auto_type]
</span><span class="kw">fn </span>user_has_post_with_id_greater_than(id_greater_than: i32) -&gt; <span class="kw">_ </span>{
    dsl::exists(
        posts::table
            .filter(posts::user_id.eq(users::id))
            .filter(posts::id.gt(id_greater_than)),
    )
}

<span class="attr">#[dsl::auto_type]
</span><span class="kw">fn </span>users_with_posts_with_id_greater_than(id_greater_than: i32) -&gt; <span class="kw">_ </span>{
    <span class="comment">// If we didn't specify the type for this query fragment, the macro would infer it as
    // `user_has_post_with_id_greater_than&lt;i32&gt;`, which would be incorrect because there is
    // no generic parameter.
    </span><span class="kw">let </span>filter: user_has_post_with_id_greater_than =
        user_has_post_with_id_greater_than(id_greater_than);
    <span class="comment">// The macro inferring that it has to pass generic parameters is still the convention
    // because it's the most general case, as well as the common case within Diesel itself,
    // and because annotating this way is reasonably simple, while the other way around
    // would be hard.

    </span>users::table.filter(filter).select(users::name)
}

<span class="kw">let </span>users_with_posts: Vec&lt;String&gt; = users_with_posts_with_id_greater_than(<span class="number">2</span>).load(conn)<span class="question-mark">?</span>;

<span class="macro">assert_eq!</span>(
    <span class="kw-2">&amp;</span>[<span class="string">"Tess"</span>] <span class="kw">as </span><span class="kw-2">&amp;</span>[<span class="kw">_</span>],
    users_with_posts
        .iter()
        .map(|s| s.as_str())
        .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;()
);</code></pre></div><h2 id="expanded-code"><a class="doc-anchor" href="#expanded-code">§</a>Expanded Code</h2><details>
<summary> Expanded Code </summary>
<h5 id="input"><a class="doc-anchor" href="#input">§</a>Input</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[diesel::dsl::auto_type]
</span><span class="kw">fn </span>foo() -&gt; <span class="kw">_ </span>{
    users::table.select(users::id)
}
</code></pre></div><h5 id="expanded-code-1"><a class="doc-anchor" href="#expanded-code-1">§</a>Expanded Code</h5><div class="warning">Expanded code might use diesel internal API's and is only shown for educational purpose</div>
<p>The macro expands the input to the following Rust code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[allow(non_camel_case_types)]
</span><span class="kw">type </span>foo = diesel::dsl::Select&lt;users::table, users::id&gt;;
<span class="attr">#[allow(clippy::needless_lifetimes)]
</span><span class="kw">fn </span>foo() -&gt; foo {
    users::table.select(users::id)
}</code></pre></div></details></div></details></section></div></main></body></html>