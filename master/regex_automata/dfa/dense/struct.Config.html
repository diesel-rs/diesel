<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The configuration used for compiling a dense DFA."><title>Config in regex_automata::dfa::dense - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (975e6c8fe 2025-09-23)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Config</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_<wbr>automata</a><span class="version">0.4.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Config</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.accelerate" title="accelerate">accelerate</a></li><li><a href="#method.byte_classes" title="byte_classes">byte_classes</a></li><li><a href="#method.determinize_size_limit" title="determinize_size_limit">determinize_size_limit</a></li><li><a href="#method.dfa_size_limit" title="dfa_size_limit">dfa_size_limit</a></li><li><a href="#method.get_accelerate" title="get_accelerate">get_accelerate</a></li><li><a href="#method.get_byte_classes" title="get_byte_classes">get_byte_classes</a></li><li><a href="#method.get_determinize_size_limit" title="get_determinize_size_limit">get_determinize_size_limit</a></li><li><a href="#method.get_dfa_size_limit" title="get_dfa_size_limit">get_dfa_size_limit</a></li><li><a href="#method.get_match_kind" title="get_match_kind">get_match_kind</a></li><li><a href="#method.get_minimize" title="get_minimize">get_minimize</a></li><li><a href="#method.get_prefilter" title="get_prefilter">get_prefilter</a></li><li><a href="#method.get_quit" title="get_quit">get_quit</a></li><li><a href="#method.get_specialize_start_states" title="get_specialize_start_states">get_specialize_start_states</a></li><li><a href="#method.get_starts" title="get_starts">get_starts</a></li><li><a href="#method.get_starts_for_each_pattern" title="get_starts_for_each_pattern">get_starts_for_each_pattern</a></li><li><a href="#method.get_unicode_word_boundary" title="get_unicode_word_boundary">get_unicode_word_boundary</a></li><li><a href="#method.match_kind" title="match_kind">match_kind</a></li><li><a href="#method.minimize" title="minimize">minimize</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.prefilter" title="prefilter">prefilter</a></li><li><a href="#method.quit" title="quit">quit</a></li><li><a href="#method.specialize_start_states" title="specialize_start_states">specialize_start_states</a></li><li><a href="#method.start_kind" title="start_kind">start_kind</a></li><li><a href="#method.starts_for_each_pattern" title="starts_for_each_pattern">starts_for_each_pattern</a></li><li><a href="#method.unicode_word_boundary" title="unicode_word_boundary">unicode_word_boundary</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Config" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-Config" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Config" title="Default">Default</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Config" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Config" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Config" title="Send">Send</a></li><li><a href="#impl-Sync-for-Config" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Config" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Config" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In regex_<wbr>automata::<wbr>dfa::<wbr>dense</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">dense</a></div><h1>Struct <span class="struct">Config</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/regex_automata/dfa/dense.rs.html#74-94">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Config { <span class="comment">/* private fields */</span> }</code></pre><span class="item-info"><div class="stab portability">Available on <strong>(crate features <code>dfa-search</code> or <code>dfa-onepass</code>) and crate feature <code>dfa-search</code> and crate feature <code>dfa-build</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The configuration used for compiling a dense DFA.</p>
<p>As a convenience, <a href="struct.DFA.html#method.config" title="associated function regex_automata::dfa::dense::DFA::config"><code>DFA::config</code></a> is an alias for <a href="struct.Config.html#method.new" title="associated function regex_automata::dfa::dense::Config::new"><code>Config::new</code></a>. The
advantage of the former is that it often lets you avoid importing the
<code>Config</code> type directly.</p>
<p>A dense DFA configuration is a simple data object that is typically used
with <a href="struct.Builder.html#method.configure" title="method regex_automata::dfa::dense::Builder::configure"><code>dense::Builder::configure</code></a>.</p>
<p>The default configuration guarantees that a search will never return
a “quit” error, although it is possible for a search to fail if
<a href="struct.Config.html#method.starts_for_each_pattern" title="method regex_automata::dfa::dense::Config::starts_for_each_pattern"><code>Config::starts_for_each_pattern</code></a> wasn’t enabled (which it is
not by default) and an <a href="../../enum.Anchored.html#variant.Pattern" title="variant regex_automata::Anchored::Pattern"><code>Anchored::Pattern</code></a> mode is requested via
<a href="../../struct.Input.html" title="struct regex_automata::Input"><code>Input</code></a>.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Config" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#97-1067">Source</a><a href="#impl-Config" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#99-101">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Return a new default dense DFA compiler configuration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.accelerate" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#120-123">Source</a><h4 class="code-header">pub fn <a href="#method.accelerate" class="fn">accelerate</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Enable state acceleration.</p>
<p>When enabled, DFA construction will analyze each state to determine
whether it is eligible for simple acceleration. Acceleration typically
occurs when most of a state’s transitions loop back to itself, leaving
only a select few bytes that will exit the state. When this occurs,
other routines like <code>memchr</code> can be used to look for those bytes which
may be much faster than traversing the DFA.</p>
<p>Callers may elect to disable this if consistent performance is more
desirable than variable performance. Namely, acceleration can sometimes
make searching slower than it otherwise would be if the transitions
that leave accelerated states are traversed frequently.</p>
<p>See <a href="../trait.Automaton.html#method.accelerator" title="method regex_automata::dfa::Automaton::accelerator"><code>Automaton::accelerator</code></a> for an example.</p>
<p>This is enabled by default.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prefilter" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#197-204">Source</a><h4 class="code-header">pub fn <a href="#method.prefilter" class="fn">prefilter</a>(self, pre: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../util/prefilter/struct.Prefilter.html" title="struct regex_automata::util::prefilter::Prefilter">Prefilter</a>&gt;) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Set a prefilter to be used whenever a start state is entered.</p>
<p>A <a href="../../util/prefilter/struct.Prefilter.html" title="struct regex_automata::util::prefilter::Prefilter"><code>Prefilter</code></a> in this context is meant to accelerate searches by
looking for literal prefixes that every match for the corresponding
pattern (or patterns) must start with. Once a prefilter produces a
match, the underlying search routine continues on to try and confirm
the match.</p>
<p>Be warned that setting a prefilter does not guarantee that the search
will be faster. While it’s usually a good bet, if the prefilter
produces a lot of false positive candidates (i.e., positions matched
by the prefilter but not by the regex), then the overall result can
be slower than if you had just executed the regex engine without any
prefilters.</p>
<p>Note that unless <a href="struct.Config.html#method.specialize_start_states" title="method regex_automata::dfa::dense::Config::specialize_start_states"><code>Config::specialize_start_states</code></a> has been
explicitly set, then setting this will also enable (when <code>pre</code> is
<code>Some</code>) or disable (when <code>pre</code> is <code>None</code>) start state specialization.
This occurs because without start state specialization, a prefilter
is likely to be less effective. And without a prefilter, start state
specialization is usually pointless.</p>
<p><strong>WARNING:</strong> Note that prefilters are not preserved as part of
serialization. Serializing a DFA will drop its prefilter.</p>
<p>By default no prefilter is set.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{dense::DFA, Automaton},
    util::prefilter::Prefilter,
    Input, HalfMatch, MatchKind,
};

<span class="kw">let </span>pre = Prefilter::new(MatchKind::LeftmostFirst, <span class="kw-2">&amp;</span>[<span class="string">"foo"</span>, <span class="string">"bar"</span>]);
<span class="kw">let </span>re = DFA::builder()
    .configure(DFA::config().prefilter(pre))
    .build(<span class="string">r"(foo|bar)[a-z]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>input = Input::new(<span class="string">"foo1 barfox bar"</span>);
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">11</span>)),
    re.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>,
);
</code></pre></div>
<p>Be warned though that an incorrect prefilter can lead to incorrect
results!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{dense::DFA, Automaton},
    util::prefilter::Prefilter,
    Input, HalfMatch, MatchKind,
};

<span class="kw">let </span>pre = Prefilter::new(MatchKind::LeftmostFirst, <span class="kw-2">&amp;</span>[<span class="string">"foo"</span>, <span class="string">"car"</span>]);
<span class="kw">let </span>re = DFA::builder()
    .configure(DFA::config().prefilter(pre))
    .build(<span class="string">r"(foo|bar)[a-z]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>input = Input::new(<span class="string">"foo1 barfox bar"</span>);
<span class="macro">assert_eq!</span>(
    <span class="comment">// No match reported even though there clearly is one!
    </span><span class="prelude-val">None</span>,
    re.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>,
);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.minimize" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#246-249">Source</a><h4 class="code-header">pub fn <a href="#method.minimize" class="fn">minimize</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Minimize the DFA.</p>
<p>When enabled, the DFA built will be minimized such that it is as small
as possible.</p>
<p>Whether one enables minimization or not depends on the types of costs
you’re willing to pay and how much you care about its benefits. In
particular, minimization has worst case <code>O(n*k*logn)</code> time and <code>O(k*n)</code>
space, where <code>n</code> is the number of DFA states and <code>k</code> is the alphabet
size. In practice, minimization can be quite costly in terms of both
space and time, so it should only be done if you’re willing to wait
longer to produce a DFA. In general, you might want a minimal DFA in
the following circumstances:</p>
<ol>
<li>You would like to optimize for the size of the automaton. This can
manifest in one of two ways. Firstly, if you’re converting the
DFA into Rust code (or a table embedded in the code), then a minimal
DFA will translate into a corresponding reduction in code  size, and
thus, also the final compiled binary size. Secondly, if you are
building many DFAs and putting them on the heap, you’ll be able to
fit more if they are smaller. Note though that building a minimal
DFA itself requires additional space; you only realize the space
savings once the minimal DFA is constructed (at which point, the
space used for minimization is freed).</li>
<li>You’ve observed that a smaller DFA results in faster match
performance. Naively, this isn’t guaranteed since there is no
inherent difference between matching with a bigger-than-minimal
DFA and a minimal DFA. However, a smaller DFA may make use of your
CPU’s cache more efficiently.</li>
<li>You are trying to establish an equivalence between regular
languages. The standard method for this is to build a minimal DFA
for each language and then compare them. If the DFAs are equivalent
(up to state renaming), then the languages are equivalent.</li>
</ol>
<p>Typically, minimization only makes sense as an offline process. That
is, one might minimize a DFA before serializing it to persistent
storage. In practical terms, minimization can take around an order of
magnitude more time than compiling the initial DFA via determinization.</p>
<p>This option is disabled by default.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.match_kind" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#358-361">Source</a><h4 class="code-header">pub fn <a href="#method.match_kind" class="fn">match_kind</a>(self, kind: <a class="enum" href="../../enum.MatchKind.html" title="enum regex_automata::MatchKind">MatchKind</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Set the desired match semantics.</p>
<p>The default is <a href="../../enum.MatchKind.html#variant.LeftmostFirst" title="variant regex_automata::MatchKind::LeftmostFirst"><code>MatchKind::LeftmostFirst</code></a>, which corresponds to the
match semantics of Perl-like regex engines. That is, when multiple
patterns would match at the same leftmost position, the pattern that
appears first in the concrete syntax is chosen.</p>
<p>Currently, the only other kind of match semantics supported is
<a href="../../enum.MatchKind.html#variant.All" title="variant regex_automata::MatchKind::All"><code>MatchKind::All</code></a>. This corresponds to classical DFA construction
where all possible matches are added to the DFA.</p>
<p>Typically, <code>All</code> is used when one wants to execute an overlapping
search and <code>LeftmostFirst</code> otherwise. In particular, it rarely makes
sense to use <code>All</code> with the various “leftmost” find routines, since the
leftmost routines depend on the <code>LeftmostFirst</code> automata construction
strategy. Specifically, <code>LeftmostFirst</code> adds dead states to the DFA
as a way to terminate the search and report a match. <code>LeftmostFirst</code>
also supports non-greedy matches using this strategy where as <code>All</code>
does not.</p>
<h5 id="example-overlapping-search"><a class="doc-anchor" href="#example-overlapping-search">§</a>Example: overlapping search</h5>
<p>This example shows the typical use of <code>MatchKind::All</code>, which is to
report overlapping matches.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, OverlappingState, dense},
    HalfMatch, Input, MatchKind,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().match_kind(MatchKind::All))
    .build_many(<span class="kw-2">&amp;</span>[<span class="string">r"\w+$"</span>, <span class="string">r"\S+$"</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>input = Input::new(<span class="string">"@foo"</span>);
<span class="kw">let </span><span class="kw-2">mut </span>state = OverlappingState::start();

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">1</span>, <span class="number">4</span>));
dfa.try_search_overlapping_fwd(<span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>state)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, state.get_match());

<span class="comment">// The first pattern also matches at the same position, so re-running
// the search will yield another match. Notice also that the first
// pattern is returned after the second. This is because the second
// pattern begins its match before the first, is therefore an earlier
// match and is thus reported first.
</span><span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">4</span>));
dfa.try_search_overlapping_fwd(<span class="kw-2">&amp;</span>input, <span class="kw-2">&amp;mut </span>state)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, state.get_match());
</code></pre></div><h5 id="example-reverse-automaton-to-find-start-of-match"><a class="doc-anchor" href="#example-reverse-automaton-to-find-start-of-match">§</a>Example: reverse automaton to find start of match</h5>
<p>Another example for using <code>MatchKind::All</code> is for constructing a
reverse automaton to find the start of a match. <code>All</code> semantics are
used for this in order to find the longest possible match, which
corresponds to the leftmost starting position.</p>
<p>Note that if you need the starting position then
<a href="../regex/struct.Regex.html" title="struct regex_automata::dfa::regex::Regex"><code>dfa::regex::Regex</code></a> will handle this for
you, so it’s usually not necessary to do this yourself.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{dense, Automaton, StartKind},
    nfa::thompson::NFA,
    Anchored, HalfMatch, Input, MatchKind,
};

<span class="kw">let </span>haystack = <span class="string">"123foobar456"</span>.as_bytes();
<span class="kw">let </span>pattern = <span class="string">r"[a-z]+r"</span>;

<span class="kw">let </span>dfa_fwd = dense::DFA::new(pattern)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa_rev = dense::Builder::new()
    .thompson(NFA::config().reverse(<span class="bool-val">true</span>))
    .configure(dense::Config::new()
        <span class="comment">// This isn't strictly necessary since both anchored and
        // unanchored searches are supported by default. But since
        // finding the start-of-match only requires anchored searches,
        // we can get rid of the unanchored configuration and possibly
        // slim down our DFA considerably.
        </span>.start_kind(StartKind::Anchored)
        .match_kind(MatchKind::All)
    )
    .build(pattern)<span class="question-mark">?</span>;
<span class="kw">let </span>expected_fwd = HalfMatch::must(<span class="number">0</span>, <span class="number">9</span>);
<span class="kw">let </span>expected_rev = HalfMatch::must(<span class="number">0</span>, <span class="number">3</span>);
<span class="kw">let </span>got_fwd = dfa_fwd.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(haystack))<span class="question-mark">?</span>.unwrap();
<span class="comment">// Here we don't specify the pattern to search for since there's only
// one pattern and we're doing a leftmost search. But if this were an
// overlapping search, you'd need to specify the pattern that matched
// in the forward direction. (Otherwise, you might wind up finding the
// starting position of a match of some other pattern.) That in turn
// requires building the reverse automaton with starts_for_each_pattern
// enabled. Indeed, this is what Regex does internally.
</span><span class="kw">let </span>input = Input::new(haystack)
    .range(..got_fwd.offset())
    .anchored(Anchored::Yes);
<span class="kw">let </span>got_rev = dfa_rev.try_search_rev(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>.unwrap();
<span class="macro">assert_eq!</span>(expected_fwd, got_fwd);
<span class="macro">assert_eq!</span>(expected_rev, got_rev);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.start_kind" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#397-400">Source</a><h4 class="code-header">pub fn <a href="#method.start_kind" class="fn">start_kind</a>(self, kind: <a class="enum" href="../enum.StartKind.html" title="enum regex_automata::dfa::StartKind">StartKind</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>The type of starting state configuration to use for a DFA.</p>
<p>By default, the starting state configuration is <a href="../enum.StartKind.html#variant.Both" title="variant regex_automata::dfa::StartKind::Both"><code>StartKind::Both</code></a>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{dense::DFA, Automaton, StartKind},
    Anchored, HalfMatch, Input,
};

<span class="kw">let </span>haystack = <span class="string">"quux foo123"</span>;
<span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">11</span>);

<span class="comment">// By default, DFAs support both anchored and unanchored searches.
</span><span class="kw">let </span>dfa = DFA::new(<span class="string">r"[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>input = Input::new(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>);

<span class="comment">// But if we only need anchored searches, then we can build a DFA
// that only supports anchored searches. This leads to a smaller DFA
// (potentially significantly smaller in some cases), but a DFA that
// will panic if you try to use it with an unanchored search.
</span><span class="kw">let </span>dfa = DFA::builder()
    .configure(DFA::config().start_kind(StartKind::Anchored))
    .build(<span class="string">r"[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>input = Input::new(haystack)
    .range(<span class="number">8</span>..)
    .anchored(Anchored::Yes);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.starts_for_each_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#475-478">Source</a><h4 class="code-header">pub fn <a href="#method.starts_for_each_pattern" class="fn">starts_for_each_pattern</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Whether to compile a separate start state for each pattern in the
automaton.</p>
<p>When enabled, a separate <strong>anchored</strong> start state is added for each
pattern in the DFA. When this start state is used, then the DFA will
only search for matches for the pattern specified, even if there are
other patterns in the DFA.</p>
<p>The main downside of this option is that it can potentially increase
the size of the DFA and/or increase the time it takes to build the DFA.</p>
<p>There are a few reasons one might want to enable this (it’s disabled
by default):</p>
<ol>
<li>When looking for the start of an overlapping match (using a
reverse DFA), doing it correctly requires starting the reverse search
using the starting state of the pattern that matched in the forward
direction. Indeed, when building a <a href="../regex/struct.Regex.html" title="struct regex_automata::dfa::regex::Regex"><code>Regex</code></a>,
it will automatically enable this option when building the reverse DFA
internally.</li>
<li>When you want to use a DFA with multiple patterns to both search
for matches of any pattern or to search for anchored matches of one
particular pattern while using the same DFA. (Otherwise, you would need
to compile a new DFA for each pattern.)</li>
<li>Since the start states added for each pattern are anchored, if you
compile an unanchored DFA with one pattern while also enabling this
option, then you can use the same DFA to perform anchored or unanchored
searches. The latter you get with the standard search APIs. The former
you get from the various <code>_at</code> search methods that allow you specify a
pattern ID to search for.</li>
</ol>
<p>By default this is disabled.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>This example shows how to use this option to permit the same DFA to
run both anchored and unanchored searches for a single pattern.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{dense, Automaton},
    Anchored, HalfMatch, PatternID, Input,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().starts_for_each_pattern(<span class="bool-val">true</span>))
    .build(<span class="string">r"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">"quux foo123"</span>;

<span class="comment">// Here's a normal unanchored search. Notice that we use 'None' for the
// pattern ID. Since the DFA was built as an unanchored machine, it
// use its default unanchored starting state.
</span><span class="kw">let </span>expected = HalfMatch::must(<span class="number">0</span>, <span class="number">11</span>);
<span class="kw">let </span>input = Input::new(haystack);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>);
<span class="comment">// But now if we explicitly specify the pattern to search ('0' being
// the only pattern in the DFA), then it will use the starting state
// for that specific pattern which is always anchored. Since the
// pattern doesn't have a match at the beginning of the haystack, we
// find nothing.
</span><span class="kw">let </span>input = Input::new(haystack)
    .anchored(Anchored::Pattern(PatternID::must(<span class="number">0</span>)));
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, dfa.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>);
<span class="comment">// And finally, an anchored search is not the same as putting a '^' at
// beginning of the pattern. An anchored search can only match at the
// beginning of the *search*, which we can change:
</span><span class="kw">let </span>input = Input::new(haystack)
    .anchored(Anchored::Pattern(PatternID::must(<span class="number">0</span>)))
    .range(<span class="number">5</span>..);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(expected), dfa.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.byte_classes" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#508-511">Source</a><h4 class="code-header">pub fn <a href="#method.byte_classes" class="fn">byte_classes</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Whether to attempt to shrink the size of the DFA’s alphabet or not.</p>
<p>This option is enabled by default and should never be disabled unless
one is debugging a generated DFA.</p>
<p>When enabled, the DFA will use a map from all possible bytes to their
corresponding equivalence class. Each equivalence class represents a
set of bytes that does not discriminate between a match and a non-match
in the DFA. For example, the pattern <code>[ab]+</code> has at least two
equivalence classes: a set containing <code>a</code> and <code>b</code> and a set containing
every byte except for <code>a</code> and <code>b</code>. <code>a</code> and <code>b</code> are in the same
equivalence class because they never discriminate between a match and a
non-match.</p>
<p>The advantage of this map is that the size of the transition table
can be reduced drastically from <code>#states * 256 * sizeof(StateID)</code> to
<code>#states * k * sizeof(StateID)</code> where <code>k</code> is the number of equivalence
classes (rounded up to the nearest power of 2). As a result, total
space usage can decrease substantially. Moreover, since a smaller
alphabet is used, DFA compilation becomes faster as well.</p>
<p><strong>WARNING:</strong> This is only useful for debugging DFAs. Disabling this
does not yield any speed advantages. Namely, even when this is
disabled, a byte class map is still used while searching. The only
difference is that every byte will be forced into its own distinct
equivalence class. This is useful for debugging the actual generated
transitions because it lets one see the transitions defined on actual
bytes instead of the equivalence classes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unicode_word_boundary" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#596-603">Source</a><h4 class="code-header">pub fn <a href="#method.unicode_word_boundary" class="fn">unicode_word_boundary</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Heuristically enable Unicode word boundaries.</p>
<p>When set, this will attempt to implement Unicode word boundaries as if
they were ASCII word boundaries. This only works when the search input
is ASCII only. If a non-ASCII byte is observed while searching, then a
<a href="../../struct.MatchError.html#method.quit" title="associated function regex_automata::MatchError::quit"><code>MatchError::quit</code></a> error is returned.</p>
<p>A possible alternative to enabling this option is to simply use an
ASCII word boundary, e.g., via <code>(?-u:\b)</code>. The main reason to use this
option is if you absolutely need Unicode support. This option lets one
use a fast search implementation (a DFA) for some potentially very
common cases, while providing the option to fall back to some other
regex engine to handle the general case when an error is returned.</p>
<p>If the pattern provided has no Unicode word boundary in it, then this
option has no effect. (That is, quitting on a non-ASCII byte only
occurs when this option is enabled <em>and</em> a Unicode word boundary is
present in the pattern.)</p>
<p>This is almost equivalent to setting all non-ASCII bytes to be quit
bytes. The only difference is that this will cause non-ASCII bytes to
be quit bytes <em>only</em> when a Unicode word boundary is present in the
pattern.</p>
<p>When enabling this option, callers <em>must</em> be prepared to handle
a <a href="../../struct.MatchError.html" title="struct regex_automata::MatchError"><code>MatchError</code></a> error during search.
When using a <a href="../regex/struct.Regex.html" title="struct regex_automata::dfa::regex::Regex"><code>Regex</code></a>, this corresponds
to using the <code>try_</code> suite of methods. Alternatively, if
callers can guarantee that their input is ASCII only, then a
<a href="../../struct.MatchError.html#method.quit" title="associated function regex_automata::MatchError::quit"><code>MatchError::quit</code></a> error will never be
returned while searching.</p>
<p>This is disabled by default.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>This example shows how to heuristically enable Unicode word boundaries
in a pattern. It also shows what happens when a search comes across a
non-ASCII byte.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, dense},
    HalfMatch, Input, MatchError,
};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().unicode_word_boundary(<span class="bool-val">true</span>))
    .build(<span class="string">r"\b[0-9]+\b"</span>)<span class="question-mark">?</span>;

<span class="comment">// The match occurs before the search ever observes the snowman
// character, so no error occurs.
</span><span class="kw">let </span>haystack = <span class="string">"foo 123  ☃"</span>.as_bytes();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">7</span>));
<span class="kw">let </span>got = dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(haystack))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(expected, got);

<span class="comment">// Notice that this search fails, even though the snowman character
// occurs after the ending match offset. This is because search
// routines read one byte past the end of the search to account for
// look-around, and indeed, this is required here to determine whether
// the trailing \b matches.
</span><span class="kw">let </span>haystack = <span class="string">"foo 123 ☃"</span>.as_bytes();
<span class="kw">let </span>expected = MatchError::quit(<span class="number">0xE2</span>, <span class="number">8</span>);
<span class="kw">let </span>got = dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(haystack));
<span class="macro">assert_eq!</span>(<span class="prelude-val">Err</span>(expected), got);

<span class="comment">// Another example is executing a search where the span of the haystack
// we specify is all ASCII, but there is non-ASCII just before it. This
// correctly also reports an error.
</span><span class="kw">let </span>input = Input::new(<span class="string">"β123"</span>).range(<span class="number">2</span>..);
<span class="kw">let </span>expected = MatchError::quit(<span class="number">0xB2</span>, <span class="number">1</span>);
<span class="kw">let </span>got = dfa.try_search_fwd(<span class="kw-2">&amp;</span>input);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Err</span>(expected), got);

<span class="comment">// And similarly for the trailing word boundary.
</span><span class="kw">let </span>input = Input::new(<span class="string">"123β"</span>).range(..<span class="number">3</span>);
<span class="kw">let </span>expected = MatchError::quit(<span class="number">0xCE</span>, <span class="number">3</span>);
<span class="kw">let </span>got = dfa.try_search_fwd(<span class="kw-2">&amp;</span>input);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Err</span>(expected), got);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.quit" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#667-683">Source</a><h4 class="code-header">pub fn <a href="#method.quit" class="fn">quit</a>(self, byte: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Add a “quit” byte to the DFA.</p>
<p>When a quit byte is seen during search time, then search will return
a <a href="../../struct.MatchError.html#method.quit" title="associated function regex_automata::MatchError::quit"><code>MatchError::quit</code></a> error indicating the
offset at which the search stopped.</p>
<p>A quit byte will always overrule any other aspects of a regex. For
example, if the <code>x</code> byte is added as a quit byte and the regex <code>\w</code> is
used, then observing <code>x</code> will cause the search to quit immediately
despite the fact that <code>x</code> is in the <code>\w</code> class.</p>
<p>This mechanism is primarily useful for heuristically enabling certain
features like Unicode word boundaries in a DFA. Namely, if the input
to search is ASCII, then a Unicode word boundary can be implemented
via an ASCII word boundary with no change in semantics. Thus, a DFA
can attempt to match a Unicode word boundary but give up as soon as it
observes a non-ASCII byte. Indeed, if callers set all non-ASCII bytes
to be quit bytes, then Unicode word boundaries will be permitted when
building DFAs. Of course, callers should enable
<a href="struct.Config.html#method.unicode_word_boundary" title="method regex_automata::dfa::dense::Config::unicode_word_boundary"><code>Config::unicode_word_boundary</code></a> if they want this behavior instead.
(The advantage being that non-ASCII quit bytes will only be added if a
Unicode word boundary is in the pattern.)</p>
<p>When enabling this option, callers <em>must</em> be prepared to handle a
<a href="../../struct.MatchError.html" title="struct regex_automata::MatchError"><code>MatchError</code></a> error during search. When using a
<a href="../regex/struct.Regex.html" title="struct regex_automata::dfa::regex::Regex"><code>Regex</code></a>, this corresponds to using the
<code>try_</code> suite of methods.</p>
<p>By default, there are no quit bytes set.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if heuristic Unicode word boundaries are enabled and any
non-ASCII byte is removed from the set of quit bytes. Namely, enabling
Unicode word boundaries requires setting every non-ASCII byte to a quit
byte. So if the caller attempts to undo any of that, then this will
panic.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This example shows how to cause a search to terminate if it sees a
<code>\n</code> byte. This could be useful if, for example, you wanted to prevent
a user supplied pattern from matching across a line boundary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense}, Input, MatchError};

<span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().quit(<span class="string">b'\n'</span>, <span class="bool-val">true</span>))
    .build(<span class="string">r"foo\p{any}+bar"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>haystack = <span class="string">"foo\nbar"</span>.as_bytes();
<span class="comment">// Normally this would produce a match, since \p{any} contains '\n'.
// But since we instructed the automaton to enter a quit state if a
// '\n' is observed, this produces a match error instead.
</span><span class="kw">let </span>expected = MatchError::quit(<span class="string">b'\n'</span>, <span class="number">3</span>);
<span class="kw">let </span>got = dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(haystack)).unwrap_err();
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.specialize_start_states" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#761-764">Source</a><h4 class="code-header">pub fn <a href="#method.specialize_start_states" class="fn">specialize_start_states</a>(self, yes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Enable specializing start states in the DFA.</p>
<p>When start states are specialized, an implementor of a search routine
using a lazy DFA can tell when the search has entered a starting state.
When start states aren’t specialized, then it is impossible to know
whether the search has entered a start state.</p>
<p>Ideally, this option wouldn’t need to exist and we could always
specialize start states. The problem is that start states can be quite
active. This in turn means that an efficient search routine is likely
to ping-pong between a heavily optimized hot loop that handles most
states and to a less optimized specialized handling of start states.
This causes branches to get heavily mispredicted and overall can
materially decrease throughput. Therefore, specializing start states
should only be enabled when it is needed.</p>
<p>Knowing whether a search is in a start state is typically useful when a
prefilter is active for the search. A prefilter is typically only run
when in a start state and a prefilter can greatly accelerate a search.
Therefore, the possible cost of specializing start states is worth it
in this case. Otherwise, if you have no prefilter, there is likely no
reason to specialize start states.</p>
<p>This is disabled by default, but note that it is automatically
enabled (or disabled) if <a href="struct.Config.html#method.prefilter" title="method regex_automata::dfa::dense::Config::prefilter"><code>Config::prefilter</code></a> is set. Namely, unless
<code>specialize_start_states</code> has already been set, <a href="struct.Config.html#method.prefilter" title="method regex_automata::dfa::dense::Config::prefilter"><code>Config::prefilter</code></a>
will automatically enable or disable it based on whether a prefilter
is present or not, respectively. This is done because a prefilter’s
effectiveness is rooted in being executed whenever the DFA is in a
start state, and that’s only possible to do when they are specialized.</p>
<p>Note that it is plausibly reasonable to <em>disable</em> this option
explicitly while <em>enabling</em> a prefilter. In that case, a prefilter
will still be run at the beginning of a search, but never again. This
in theory could strike a good balance if you’re in a situation where a
prefilter is likely to produce many false positive candidates.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows how to enable start state specialization and then
shows how to check whether a state is a start state or not.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, Input};

<span class="kw">let </span>dfa = DFA::builder()
    .configure(DFA::config().specialize_start_states(<span class="bool-val">true</span>))
    .build(<span class="string">r"[a-z]+"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>haystack = <span class="string">"123 foobar 4567"</span>.as_bytes();
<span class="kw">let </span>sid = dfa.start_state_forward(<span class="kw-2">&amp;</span>Input::new(haystack))<span class="question-mark">?</span>;
<span class="comment">// The ID returned by 'start_state_forward' will always be tagged as
// a start state when start state specialization is enabled.
</span><span class="macro">assert!</span>(dfa.is_special_state(sid));
<span class="macro">assert!</span>(dfa.is_start_state(sid));
</code></pre></div>
<p>Compare the above with the default DFA configuration where start states
are <em>not</em> specialized. In this case, the start state is not tagged at
all:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, dense::DFA}, Input};

<span class="kw">let </span>dfa = DFA::new(<span class="string">r"[a-z]+"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>haystack = <span class="string">"123 foobar 4567"</span>;
<span class="kw">let </span>sid = dfa.start_state_forward(<span class="kw-2">&amp;</span>Input::new(haystack))<span class="question-mark">?</span>;
<span class="comment">// Start states are not special in the default configuration!
</span><span class="macro">assert!</span>(!dfa.is_special_state(sid));
<span class="macro">assert!</span>(!dfa.is_start_state(sid));
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dfa_size_limit" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#850-853">Source</a><h4 class="code-header">pub fn <a href="#method.dfa_size_limit" class="fn">dfa_size_limit</a>(self, bytes: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Set a size limit on the total heap used by a DFA.</p>
<p>This size limit is expressed in bytes and is applied during
determinization of an NFA into a DFA. If the DFA’s heap usage, and only
the DFA, exceeds this configured limit, then determinization is stopped
and an error is returned.</p>
<p>This limit does not apply to auxiliary storage used during
determinization that isn’t part of the generated DFA.</p>
<p>This limit is only applied during determinization. Currently, there is
no way to post-pone this check to after minimization if minimization
was enabled.</p>
<p>The total limit on heap used during determinization is the sum of the
DFA and determinization size limits.</p>
<p>The default is no limit.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>This example shows a DFA that fails to build because of a configured
size limit. This particular example also serves as a cautionary tale
demonstrating just how big DFAs with large Unicode character classes
can get.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{dense, Automaton}, Input};

<span class="comment">// 6MB isn't enough!
</span>dense::Builder::new()
    .configure(dense::Config::new().dfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">6_000_000</span>)))
    .build(<span class="string">r"\w{20}"</span>)
    .unwrap_err();

<span class="comment">// ... but 7MB probably is!
// (Note that DFA sizes aren't necessarily stable between releases.)
</span><span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new().dfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">7_000_000</span>)))
    .build(<span class="string">r"\w{20}"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">"A"</span>.repeat(<span class="number">20</span>).into_bytes();
<span class="macro">assert!</span>(dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="kw-2">&amp;</span>haystack))<span class="question-mark">?</span>.is_some());
</code></pre></div>
<p>While one needs a little more than 6MB to represent <code>\w{20}</code>, it
turns out that you only need a little more than 6KB to represent
<code>(?-u:\w{20})</code>. So only use Unicode if you need it!</p>
<p>As with <a href="struct.Config.html#method.determinize_size_limit" title="method regex_automata::dfa::dense::Config::determinize_size_limit"><code>Config::determinize_size_limit</code></a>, the size of a DFA is
influenced by other factors, such as what start state configurations
to support. For example, if you only need unanchored searches and not
anchored searches, then configuring the DFA to only support unanchored
searches can reduce its size. By default, DFAs support both unanchored
and anchored searches.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{dense, Automaton, StartKind}, Input};

<span class="comment">// 3MB isn't enough!
</span>dense::Builder::new()
    .configure(dense::Config::new()
        .dfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">3_000_000</span>))
        .start_kind(StartKind::Unanchored)
    )
    .build(<span class="string">r"\w{20}"</span>)
    .unwrap_err();

<span class="comment">// ... but 4MB probably is!
// (Note that DFA sizes aren't necessarily stable between releases.)
</span><span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new()
        .dfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">4_000_000</span>))
        .start_kind(StartKind::Unanchored)
    )
    .build(<span class="string">r"\w{20}"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">"A"</span>.repeat(<span class="number">20</span>).into_bytes();
<span class="macro">assert!</span>(dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="kw-2">&amp;</span>haystack))<span class="question-mark">?</span>.is_some());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.determinize_size_limit" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#946-949">Source</a><h4 class="code-header">pub fn <a href="#method.determinize_size_limit" class="fn">determinize_size_limit</a>(self, bytes: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class="docblock"><p>Set a size limit on the total heap used by determinization.</p>
<p>This size limit is expressed in bytes and is applied during
determinization of an NFA into a DFA. If the heap used for auxiliary
storage during determinization (memory that is not in the DFA but
necessary for building the DFA) exceeds this configured limit, then
determinization is stopped and an error is returned.</p>
<p>This limit does not apply to heap used by the DFA itself.</p>
<p>The total limit on heap used during determinization is the sum of the
DFA and determinization size limits.</p>
<p>The default is no limit.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This example shows a DFA that fails to build because of a
configured size limit on the amount of heap space used by
determinization. This particular example complements the example for
<a href="struct.Config.html#method.dfa_size_limit" title="method regex_automata::dfa::dense::Config::dfa_size_limit"><code>Config::dfa_size_limit</code></a> by demonstrating that not only does Unicode
potentially make DFAs themselves big, but it also results in more
auxiliary storage during determinization. (Although, auxiliary storage
is still not as much as the DFA itself.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{dense, Automaton}, Input};

<span class="comment">// 700KB isn't enough!
</span>dense::Builder::new()
    .configure(dense::Config::new()
        .determinize_size_limit(<span class="prelude-val">Some</span>(<span class="number">700_000</span>))
    )
    .build(<span class="string">r"\w{20}"</span>)
    .unwrap_err();

<span class="comment">// ... but 800KB probably is!
// (Note that auxiliary storage sizes aren't necessarily stable between
// releases.)
</span><span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new()
        .determinize_size_limit(<span class="prelude-val">Some</span>(<span class="number">800_000</span>))
    )
    .build(<span class="string">r"\w{20}"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">"A"</span>.repeat(<span class="number">20</span>).into_bytes();
<span class="macro">assert!</span>(dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="kw-2">&amp;</span>haystack))<span class="question-mark">?</span>.is_some());
</code></pre></div>
<p>Note that some parts of the configuration on a DFA can have a
big impact on how big the DFA is, and thus, how much memory is
used. For example, the default setting for <a href="struct.Config.html#method.start_kind" title="method regex_automata::dfa::dense::Config::start_kind"><code>Config::start_kind</code></a> is
<a href="../enum.StartKind.html#variant.Both" title="variant regex_automata::dfa::StartKind::Both"><code>StartKind::Both</code></a>. But if you only need an anchored search, for
example, then it can be much cheaper to build a DFA that only supports
anchored searches. (Running an unanchored search with it would panic.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{dense, Automaton, StartKind},
    Anchored, Input,
};

<span class="comment">// 200KB isn't enough!
</span>dense::Builder::new()
    .configure(dense::Config::new()
        .determinize_size_limit(<span class="prelude-val">Some</span>(<span class="number">200_000</span>))
        .start_kind(StartKind::Anchored)
    )
    .build(<span class="string">r"\w{20}"</span>)
    .unwrap_err();

<span class="comment">// ... but 300KB probably is!
// (Note that auxiliary storage sizes aren't necessarily stable between
// releases.)
</span><span class="kw">let </span>dfa = dense::Builder::new()
    .configure(dense::Config::new()
        .determinize_size_limit(<span class="prelude-val">Some</span>(<span class="number">300_000</span>))
        .start_kind(StartKind::Anchored)
    )
    .build(<span class="string">r"\w{20}"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">"A"</span>.repeat(<span class="number">20</span>).into_bytes();
<span class="kw">let </span>input = Input::new(<span class="kw-2">&amp;</span>haystack).anchored(Anchored::Yes);
<span class="macro">assert!</span>(dfa.try_search_fwd(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>.is_some());
</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_accelerate" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#953-955">Source</a><h4 class="code-header">pub fn <a href="#method.get_accelerate" class="fn">get_accelerate</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration has enabled simple state
acceleration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_prefilter" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#958-960">Source</a><h4 class="code-header">pub fn <a href="#method.get_prefilter" class="fn">get_prefilter</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../../util/prefilter/struct.Prefilter.html" title="struct regex_automata::util::prefilter::Prefilter">Prefilter</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the prefilter attached to this configuration, if any.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_minimize" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#964-966">Source</a><h4 class="code-header">pub fn <a href="#method.get_minimize" class="fn">get_minimize</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration has enabled the expensive process
of minimizing a DFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_match_kind" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#969-971">Source</a><h4 class="code-header">pub fn <a href="#method.get_match_kind" class="fn">get_match_kind</a>(&amp;self) -&gt; <a class="enum" href="../../enum.MatchKind.html" title="enum regex_automata::MatchKind">MatchKind</a></h4></section></summary><div class="docblock"><p>Returns the match semantics set in this configuration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_starts" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#974-976">Source</a><h4 class="code-header">pub fn <a href="#method.get_starts" class="fn">get_starts</a>(&amp;self) -&gt; <a class="enum" href="../enum.StartKind.html" title="enum regex_automata::dfa::StartKind">StartKind</a></h4></section></summary><div class="docblock"><p>Returns the starting state configuration for a DFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_starts_for_each_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#980-982">Source</a><h4 class="code-header">pub fn <a href="#method.get_starts_for_each_pattern" class="fn">get_starts_for_each_pattern</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration has enabled anchored starting states
for every pattern in the DFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_byte_classes" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#987-989">Source</a><h4 class="code-header">pub fn <a href="#method.get_byte_classes" class="fn">get_byte_classes</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration has enabled byte classes or not.
This is typically a debugging oriented option, as disabling it confers
no speed benefit.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unicode_word_boundary" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#994-996">Source</a><h4 class="code-header">pub fn <a href="#method.get_unicode_word_boundary" class="fn">get_unicode_word_boundary</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration has enabled heuristic Unicode word
boundary support. When enabled, it is possible for a search to return
an error.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_quit" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1002-1004">Source</a><h4 class="code-header">pub fn <a href="#method.get_quit" class="fn">get_quit</a>(&amp;self, byte: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration will instruct the DFA to enter a
quit state whenever the given byte is seen during a search. When at
least one byte has this enabled, it is possible for a search to return
an error.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_specialize_start_states" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1011-1013">Source</a><h4 class="code-header">pub fn <a href="#method.get_specialize_start_states" class="fn">get_specialize_start_states</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether this configuration will instruct the DFA to
“specialize” start states. When enabled, the DFA will mark start states
as “special” so that search routines using the DFA can detect when
it’s in a start state and do some kind of optimization (like run a
prefilter).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_dfa_size_limit" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1019-1021">Source</a><h4 class="code-header">pub fn <a href="#method.get_dfa_size_limit" class="fn">get_dfa_size_limit</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the DFA size limit of this configuration if one was set.
The size limit is total number of bytes on the heap that a DFA is
permitted to use. If the DFA exceeds this limit during construction,
then construction is stopped and an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_determinize_size_limit" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#1035-1037">Source</a><h4 class="code-header">pub fn <a href="#method.get_determinize_size_limit" class="fn">get_determinize_size_limit</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the determinization size limit of this configuration if one
was set. The size limit is total number of bytes on the heap that
determinization is permitted to use. If determinization exceeds this
limit during construction, then construction is stopped and an error is
returned.</p>
<p>This is different from the DFA size limit in that this only applies to
the auxiliary storage used during determinization. Once determinization
is complete, this memory is freed.</p>
<p>The limit on the total heap memory used is the sum of the DFA and
determinization size limits.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Config" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#73">Source</a><a href="#impl-Clone-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#73">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Config" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#73">Source</a><a href="#impl-Debug-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#73">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Config" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#73">Source</a><a href="#impl-Default-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/dense.rs.html#73">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Config" class="impl"><a href="#impl-Freeze-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section><section id="impl-RefUnwindSafe-for-Config" class="impl"><a href="#impl-RefUnwindSafe-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section><section id="impl-Send-for-Config" class="impl"><a href="#impl-Send-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section><section id="impl-Sync-for-Config" class="impl"><a href="#impl-Sync-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section><section id="impl-Unpin-for-Config" class="impl"><a href="#impl-Unpin-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section><section id="impl-UnwindSafe-for-Config" class="impl"><a href="#impl-UnwindSafe-for-Config" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::dense::Config">Config</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>