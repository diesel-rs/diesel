<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A regular expression that uses deterministic finite automata for fast searching."><title>Regex in regex_automata::dfa::regex - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (975e6c8fe 2025-09-23)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Regex</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_<wbr>automata</a><span class="version">0.4.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Regex</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#crate-features" title="Crate features">Crate features</a></li><li><a href="#when-should-i-use-this" title="When should I use this?">When should I use this?</a></li><li><a href="#sparse-dfas" title="Sparse DFAs">Sparse DFAs</a></li><li><a href="#fallibility" title="Fallibility">Fallibility</a></li><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.builder" title="builder">builder</a></li><li><a href="#method.find" title="find">find</a></li><li><a href="#method.find_iter" title="find_iter">find_iter</a></li><li><a href="#method.forward" title="forward">forward</a></li><li><a href="#method.is_match" title="is_match">is_match</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.new_many" title="new_many">new_many</a></li><li><a href="#method.new_many_sparse" title="new_many_sparse">new_many_sparse</a></li><li><a href="#method.new_sparse" title="new_sparse">new_sparse</a></li><li><a href="#method.pattern_len" title="pattern_len">pattern_len</a></li><li><a href="#method.reverse" title="reverse">reverse</a></li><li><a href="#method.try_search" title="try_search">try_search</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Regex%3CA%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-Regex%3CA%3E" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Regex%3CA%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Regex%3CA%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Regex%3CA%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-Regex%3CA%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Regex%3CA%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Regex%3CA%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In regex_<wbr>automata::<wbr>dfa::<wbr>regex</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">regex</a></div><h1>Struct <span class="struct">Regex</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/regex_automata/dfa/regex.rs.html#60-180">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Regex&lt;A = <a class="struct" href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;&gt;&gt; { <span class="comment">/* private fields */</span> }</code></pre><span class="item-info"><div class="stab portability">Available on <strong>(crate features <code>dfa-search</code> or <code>dfa-onepass</code>) and crate feature <code>dfa-search</code> and crate feature <code>alloc</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A regular expression that uses deterministic finite automata for fast
searching.</p>
<p>A regular expression is comprised of two DFAs, a “forward” DFA and a
“reverse” DFA. The forward DFA is responsible for detecting the end of
a match while the reverse DFA is responsible for detecting the start
of a match. Thus, in order to find the bounds of any given match, a
forward search must first be run followed by a reverse search. A match
found by the forward DFA guarantees that the reverse DFA will also find
a match.</p>
<p>The type of the DFA used by a <code>Regex</code> corresponds to the <code>A</code> type
parameter, which must satisfy the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait. Typically,
<code>A</code> is either a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a> or a
<a href="../sparse/struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA"><code>sparse::DFA</code></a>, where dense DFAs use more
memory but search faster, while sparse DFAs use less memory but search
more slowly.</p>
<h2 id="crate-features"><a class="doc-anchor" href="#crate-features">§</a>Crate features</h2>
<p>Note that despite what the documentation auto-generates, the <em>only</em>
crate feature needed to use this type is <code>dfa-search</code>. You do <em>not</em>
need to enable the <code>alloc</code> feature.</p>
<p>By default, a regex’s automaton type parameter is set to
<code>dense::DFA&lt;Vec&lt;u32&gt;&gt;</code> when the <code>alloc</code> feature is enabled. For most
in-memory work loads, this is the most convenient type that gives the
best search performance. When the <code>alloc</code> feature is disabled, no
default type is used.</p>
<h2 id="when-should-i-use-this"><a class="doc-anchor" href="#when-should-i-use-this">§</a>When should I use this?</h2>
<p>Generally speaking, if you can afford the overhead of building a full
DFA for your regex, and you don’t need things like capturing groups,
then this is a good choice if you’re looking to optimize for matching
speed. Note however that its speed may be worse than a general purpose
regex engine if you don’t provide a <a href="../dense/struct.Config.html#method.prefilter" title="method regex_automata::dfa::dense::Config::prefilter"><code>dense::Config::prefilter</code></a> to the
underlying DFA.</p>
<h2 id="sparse-dfas"><a class="doc-anchor" href="#sparse-dfas">§</a>Sparse DFAs</h2>
<p>Since a <code>Regex</code> is generic over the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait, it can be
used with any kind of DFA. While this crate constructs dense DFAs by
default, it is easy enough to build corresponding sparse DFAs, and then
build a regex from them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="comment">// First, build a regex that uses dense DFAs.
</span><span class="kw">let </span>dense_re = Regex::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// Second, build sparse DFAs from the forward and reverse dense DFAs.
</span><span class="kw">let </span>fwd = dense_re.forward().to_sparse()<span class="question-mark">?</span>;
<span class="kw">let </span>rev = dense_re.reverse().to_sparse()<span class="question-mark">?</span>;

<span class="comment">// Third, build a new regex from the constituent sparse DFAs.
</span><span class="kw">let </span>sparse_re = Regex::builder().build_from_dfas(fwd, rev);

<span class="comment">// A regex that uses sparse DFAs can be used just like with dense DFAs.
</span><span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, sparse_re.is_match(<span class="string">b"foo123"</span>));
</code></pre></div>
<p>Alternatively, one can use a <a href="struct.Builder.html" title="struct regex_automata::dfa::regex::Builder"><code>Builder</code></a> to construct a sparse DFA
more succinctly. (Note though that dense DFAs are still constructed
first internally, and then converted to sparse DFAs, as in the example
above.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="kw">let </span>sparse_re = Regex::builder().build_sparse(<span class="string">r"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="comment">// A regex that uses sparse DFAs can be used just like with dense DFAs.
</span><span class="macro">assert!</span>(sparse_re.is_match(<span class="string">b"foo123"</span>));
</code></pre></div><h2 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h2>
<p>Most of the search routines defined on this type will <em>panic</em> when the
underlying search fails. This might be because the DFA gave up because
it saw a quit byte, whether configured explicitly or via heuristic
Unicode word boundary support, although neither are enabled by default.
Or it might fail because an invalid <code>Input</code> configuration is given,
for example, with an unsupported <a href="../../enum.Anchored.html" title="enum regex_automata::Anchored"><code>Anchored</code></a> mode.</p>
<p>If you need to handle these error cases instead of allowing them to
trigger a panic, then the lower level <a href="struct.Regex.html#method.try_search" title="method regex_automata::dfa::regex::Regex::try_search"><code>Regex::try_search</code></a> provides
a fallible API that never panics.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>This example shows how to cause a search to terminate if it sees a
<code>\n</code> byte, and handle the error returned. This could be useful if, for
example, you wanted to prevent a user supplied pattern from matching
across a line boundary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{<span class="self">self</span>, regex::Regex}, Input, MatchError};

<span class="kw">let </span>re = Regex::builder()
    .dense(dfa::dense::Config::new().quit(<span class="string">b'\n'</span>, <span class="bool-val">true</span>))
    .build(<span class="string">r"foo\p{any}+bar"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>input = Input::new(<span class="string">"foo\nbar"</span>);
<span class="comment">// Normally this would produce a match, since \p{any} contains '\n'.
// But since we instructed the automaton to enter a quit state if a
// '\n' is observed, this produces a match error instead.
</span><span class="kw">let </span>expected = MatchError::quit(<span class="string">b'\n'</span>, <span class="number">3</span>);
<span class="kw">let </span>got = re.try_search(<span class="kw-2">&amp;</span>input).unwrap_err();
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Regex" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#183-231">Source</a><a href="#impl-Regex" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#202-204">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>syntax</code> and <code>dfa-build</code></strong> only.</div></span></summary><div class="docblock"><p>Parse the given regular expression using the default configuration and
return the corresponding regex.</p>
<p>If you want a non-default configuration, then use the <a href="struct.Builder.html" title="struct regex_automata::dfa::regex::Builder"><code>Builder</code></a> to
set your own configuration.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new(<span class="string">"foo[0-9]+bar"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">14</span>)),
    re.find(<span class="string">b"zzzfoo12345barzzz"</span>),
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new_many" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#226-230">Source</a><h4 class="code-header">pub fn <a href="#method.new_many" class="fn">new_many</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;(patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[P]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>syntax</code> and <code>dfa-build</code></strong> only.</div></span></summary><div class="docblock"><p>Like <code>new</code>, but parses multiple patterns into a single “regex set.”
This similarly uses the default regex configuration.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new_many(<span class="kw-2">&amp;</span>[<span class="string">"[a-z]+"</span>, <span class="string">"[0-9]+"</span>])<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_iter(<span class="string">b"abc 1 foo 4567 0 quux"</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">4</span>..<span class="number">5</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">6</span>..<span class="number">9</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">10</span>..<span class="number">14</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">15</span>..<span class="number">16</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">17</span>..<span class="number">21</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CDFA%3CVec%3Cu8%3E%3E%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#234-285">Source</a><a href="#impl-Regex%3CDFA%3CVec%3Cu8%3E%3E%3E" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;<a class="struct" href="../sparse/struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_sparse" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#253-257">Source</a><h4 class="code-header">pub fn <a href="#method.new_sparse" class="fn">new_sparse</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;<a class="struct" href="../sparse/struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;&gt;, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>syntax</code> and <code>dfa-build</code></strong> only.</div></span></summary><div class="docblock"><p>Parse the given regular expression using the default configuration,
except using sparse DFAs, and return the corresponding regex.</p>
<p>If you want a non-default configuration, then use the <a href="struct.Builder.html" title="struct regex_automata::dfa::regex::Builder"><code>Builder</code></a> to
set your own configuration.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new_sparse(<span class="string">"foo[0-9]+bar"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">14</span>)),
    re.find(<span class="string">b"zzzfoo12345barzzz"</span>),
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new_many_sparse" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#280-284">Source</a><h4 class="code-header">pub fn <a href="#method.new_many_sparse" class="fn">new_many_sparse</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;(
    patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[P]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;<a class="struct" href="../sparse/struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;&gt;, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>syntax</code> and <code>dfa-build</code></strong> only.</div></span></summary><div class="docblock"><p>Like <code>new</code>, but parses multiple patterns into a single “regex set”
using sparse DFAs. This otherwise similarly uses the default regex
configuration.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new_many_sparse(<span class="kw-2">&amp;</span>[<span class="string">"[a-z]+"</span>, <span class="string">"[0-9]+"</span>])<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>it = re.find_iter(<span class="string">b"abc 1 foo 4567 0 quux"</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">4</span>..<span class="number">5</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">6</span>..<span class="number">9</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">10</span>..<span class="number">14</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">15</span>..<span class="number">16</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">17</span>..<span class="number">21</span>)), it.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, it.next());</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CDFA%3C%26%5Bu32%5D%3E%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#288-319">Source</a><a href="#impl-Regex%3CDFA%3C%26%5Bu32%5D%3E%3E" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;<a class="struct" href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">DFA</a>&lt;&amp;'static [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>]&gt;&gt;</h3><div class="docblock"><p>Convenience routines for regex construction.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.builder" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#316-318">Source</a><h4 class="code-header">pub fn <a href="#method.builder" class="fn">builder</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct regex_automata::dfa::regex::Builder">Builder</a></h4></section></summary><div class="docblock"><p>Return a builder for configuring the construction of a <code>Regex</code>.</p>
<p>This is a convenience routine to avoid needing to import the
<a href="struct.Builder.html" title="struct regex_automata::dfa::regex::Builder"><code>Builder</code></a> type in common cases.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows how to use the builder to disable UTF-8 mode
everywhere.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::regex::Regex, nfa::thompson, util::syntax, Match,
};

<span class="kw">let </span>re = Regex::builder()
    .syntax(syntax::Config::new().utf8(<span class="bool-val">false</span>))
    .thompson(thompson::Config::new().utf8(<span class="bool-val">false</span>))
    .build(<span class="string">r"foo(?-u:[^b])ar.*"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>haystack = <span class="string">b"\xFEfoo\xFFarzz\xE2\x98\xFF\n"</span>;
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">9</span>));
<span class="kw">let </span>got = re.find(haystack);
<span class="macro">assert_eq!</span>(expected, got);
</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#322-444">Source</a><a href="#impl-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h3><div class="docblock"><p>Standard search routines for finding and iterating over matches.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#358-363">Source</a><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>&lt;'h, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(&amp;self, input: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if this regex matches the given haystack.</p>
<p>This routine may short circuit if it knows that scanning future input
will never lead to a different result. In particular, if the underlying
DFA enters a match state or a dead state, then this routine will return
<code>true</code> or <code>false</code>, respectively, without inspecting any future input.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This routine panics if the search could not complete. This can occur
in a number of circumstances:</p>
<ul>
<li>The configuration of the DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the DFA quitting.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search panics, callers cannot know whether a match exists or
not.</p>
<p>Use <a href="struct.Regex.html#method.try_search" title="method regex_automata::dfa::regex::Regex::try_search"><code>Regex::try_search</code></a> if you want to handle these error conditions.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="kw">let </span>re = Regex::new(<span class="string">"foo[0-9]+bar"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="bool-val">true</span>, re.is_match(<span class="string">"foo12345bar"</span>));
<span class="macro">assert_eq!</span>(<span class="bool-val">false</span>, re.is_match(<span class="string">"foobar"</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#403-405">Source</a><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'h, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(&amp;self, input: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.Match.html" title="struct regex_automata::Match">Match</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This routine panics if the search could not complete. This can occur
in a number of circumstances:</p>
<ul>
<li>The configuration of the DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the DFA quitting.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search panics, callers cannot know whether a match exists or
not.</p>
<p>Use <a href="struct.Regex.html#method.try_search" title="method regex_automata::dfa::regex::Regex::try_search"><code>Regex::try_search</code></a> if you want to handle these error conditions.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, dfa::regex::Regex};

<span class="comment">// Greediness is applied appropriately.
</span><span class="kw">let </span>re = Regex::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">11</span>)), re.find(<span class="string">"zzzfoo12345zzz"</span>));

<span class="comment">// Even though a match is found after reading the first byte (`a`),
// the default leftmost-first match semantics demand that we find the
// earliest match that prefers earlier parts of the pattern over latter
// parts.
</span><span class="kw">let </span>re = Regex::new(<span class="string">"abc|a"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">3</span>)), re.find(<span class="string">"abc"</span>));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.find_iter" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#437-443">Source</a><h4 class="code-header">pub fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'r, 'h, I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'h&gt;&gt;&gt;(
    &amp;'r self,
    input: I,
) -&gt; <a class="struct" href="struct.FindMatches.html" title="struct regex_automata::dfa::regex::FindMatches">FindMatches</a>&lt;'r, 'h, A&gt; <a href="#" class="tooltip" data-notable-ty="FindMatches&lt;&#39;r, &#39;h, A&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over all non-overlapping leftmost matches in the
given bytes. If no match exists, then the iterator yields no elements.</p>
<p>This corresponds to the “standard” regex search iterator.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>If the search returns an error during iteration, then iteration
panics. See <a href="struct.Regex.html#method.find" title="method regex_automata::dfa::regex::Regex::find"><code>Regex::find</code></a> for the panic conditions.</p>
<p>Use <a href="struct.Regex.html#method.try_search" title="method regex_automata::dfa::regex::Regex::try_search"><code>Regex::try_search</code></a> with
<a href="../../util/iter/struct.Searcher.html" title="struct regex_automata::util::iter::Searcher"><code>util::iter::Searcher</code></a> if you want to
handle these error conditions.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{Match, dfa::regex::Regex};

<span class="kw">let </span>re = Regex::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>text = <span class="string">"foo1 foo12 foo123"</span>;
<span class="kw">let </span>matches: Vec&lt;Match&gt; = re.find_iter(text).collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[
    Match::must(<span class="number">0</span>, <span class="number">0</span>..<span class="number">4</span>),
    Match::must(<span class="number">0</span>, <span class="number">5</span>..<span class="number">10</span>),
    Match::must(<span class="number">0</span>, <span class="number">11</span>..<span class="number">17</span>),
]);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA%3E-1" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#448-545">Source</a><a href="#impl-Regex%3CA%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h3><div class="docblock"><p>Lower level fallible search routines that permit controlling where the
search starts and ends in a particular sequence.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_search" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#475-535">Source</a><h4 class="code-header">pub fn <a href="#method.try_search" class="fn">try_search</a>(&amp;self, input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.Match.html" title="struct regex_automata::Match">Match</a>&gt;, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end offset of the leftmost match. If no match
exists, then <code>None</code> is returned.</p>
<p>This is like <a href="struct.Regex.html#method.find" title="method regex_automata::dfa::regex::Regex::find"><code>Regex::find</code></a> but with two differences:</p>
<ol>
<li>It is not generic over <code>Into&lt;Input&gt;</code> and instead accepts a
<code>&amp;Input</code>. This permits reusing the same <code>Input</code> for multiple searches
without needing to create a new one. This <em>may</em> help with latency.</li>
<li>It returns an error if the search could not complete where as
<a href="struct.Regex.html#method.find" title="method regex_automata::dfa::regex::Regex::find"><code>Regex::find</code></a> will panic.</li>
</ol>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This routine errors if the search could not complete. This can occur
in the following circumstances:</p>
<ul>
<li>The configuration of the DFA may permit it to “quit” the search.
For example, setting quit bytes or enabling heuristic support for
Unicode word boundaries. The default configuration does not enable any
option that could result in the DFA quitting.</li>
<li>When the provided <code>Input</code> configuration is not supported. For
example, by providing an unsupported anchor mode.</li>
</ul>
<p>When a search returns an error, callers cannot know whether a match
exists or not.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Regex%3CA%3E-2" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#549-584">Source</a><a href="#impl-Regex%3CA%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a>&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h3><div class="docblock"><p>Non-search APIs for querying information about the regex and setting a
prefilter.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.forward" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#555-557">Source</a><h4 class="code-header">pub fn <a href="#method.forward" class="fn">forward</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;A</a></h4></section></summary><div class="docblock"><p>Return the underlying DFA responsible for forward matching.</p>
<p>This is useful for accessing the underlying DFA and converting it to
some other format or size. See the <a href="struct.Builder.html#method.build_from_dfas" title="method regex_automata::dfa::regex::Builder::build_from_dfas"><code>Builder::build_from_dfas</code></a> docs
for an example of where this might be useful.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reverse" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#564-566">Source</a><h4 class="code-header">pub fn <a href="#method.reverse" class="fn">reverse</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;A</a></h4></section></summary><div class="docblock"><p>Return the underlying DFA responsible for reverse matching.</p>
<p>This is useful for accessing the underlying DFA and converting it to
some other format or size. See the <a href="struct.Builder.html#method.build_from_dfas" title="method regex_automata::dfa::regex::Builder::build_from_dfas"><code>Builder::build_from_dfas</code></a> docs
for an example of where this might be useful.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_len" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#580-583">Source</a><h4 class="code-header">pub fn <a href="#method.pattern_len" class="fn">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of patterns matched by this regex.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::regex::Regex;

<span class="kw">let </span>re = Regex::new_many(<span class="kw-2">&amp;</span>[<span class="string">r"[a-z]+"</span>, <span class="string">r"[0-9]+"</span>, <span class="string">r"\w+"</span>])<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="number">3</span>, re.pattern_len());</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Regex%3CA%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#179">Source</a><a href="#impl-Clone-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#179">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Regex%3CA%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#179">Source</a><a href="#impl-Debug-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/regex.rs.html#179">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Regex%3CA%3E" class="impl"><a href="#impl-Freeze-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-Regex%3CA%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-Regex%3CA%3E" class="impl"><a href="#impl-Send-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-Regex%3CA%3E" class="impl"><a href="#impl-Sync-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-Regex%3CA%3E" class="impl"><a href="#impl-Unpin-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-Regex%3CA%3E" class="impl"><a href="#impl-UnwindSafe-for-Regex%3CA%3E" class="anchor">§</a><h3 class="code-header">impl&lt;A&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex_automata::dfa::regex::Regex">Regex</a>&lt;A&gt;<div class="where">where
    A: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"FindMatches<'r, 'h, A>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.FindMatches.html\" title=\"struct regex_automata::dfa::regex::FindMatches\">FindMatches</a>&lt;'r, 'h, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'r, 'h, A: <a class=\"trait\" href=\"../trait.Automaton.html\" title=\"trait regex_automata::dfa::Automaton\">Automaton</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.FindMatches.html\" title=\"struct regex_automata::dfa::regex::FindMatches\">FindMatches</a>&lt;'r, 'h, A&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"../../struct.Match.html\" title=\"struct regex_automata::Match\">Match</a>;</div>"}</script></section></div></main></body></html>