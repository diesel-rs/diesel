<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A wrapper around a `syn::DeriveInput` which provides utilities for creating custom derive trait implementations."><title>Structure in synstructure - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="synstructure" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (975e6c8fe 2025-09-23)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Structure</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../synstructure/index.html">synstructure</a><span class="version">0.13.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Structure</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_bounds" title="add_bounds">add_bounds</a></li><li><a href="#method.add_impl_generic" title="add_impl_generic">add_impl_generic</a></li><li><a href="#method.add_trait_bounds" title="add_trait_bounds">add_trait_bounds</a></li><li><a href="#method.add_where_predicate" title="add_where_predicate">add_where_predicate</a></li><li><a href="#method.ast" title="ast">ast</a></li><li><a href="#method.bind_with" title="bind_with">bind_with</a></li><li><a href="#method.binding_name" title="binding_name">binding_name</a></li><li><a href="#method.bound_impl" title="bound_impl">bound_impl</a></li><li><a href="#method.drain_filter" title="drain_filter">drain_filter</a></li><li><a href="#method.drain_filter_variants" title="drain_filter_variants">drain_filter_variants</a></li><li><a href="#method.each" title="each">each</a></li><li><a href="#method.each_variant" title="each_variant">each_variant</a></li><li><a href="#method.filter" title="filter">filter</a></li><li><a href="#method.filter_variants" title="filter_variants">filter_variants</a></li><li><a href="#method.fold" title="fold">fold</a></li><li><a href="#method.gen_impl" title="gen_impl">gen_impl</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.omitted_variants" title="omitted_variants">omitted_variants</a></li><li><a href="#method.referenced_ty_params" title="referenced_ty_params">referenced_ty_params</a></li><li><a href="#method.remove_variant" title="remove_variant">remove_variant</a></li><li><a href="#method.try_new" title="try_new">try_new</a></li><li><a href="#method.unbound_impl" title="unbound_impl">unbound_impl</a></li><li><a href="#method.underscore_const" title="underscore_const">underscore_const</a></li><li><a href="#method.unsafe_bound_impl" title="unsafe_bound_impl">unsafe_bound_impl</a></li><li><a href="#method.unsafe_unbound_impl" title="unsafe_unbound_impl">unsafe_unbound_impl</a></li><li><a href="#method.variants" title="variants">variants</a></li><li><a href="#method.variants_mut" title="variants_mut">variants_mut</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Structure%3C'a%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-Structure%3C'a%3E" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-Structure%3C'a%3E" title="Eq">Eq</a></li><li><a href="#impl-Hash-for-Structure%3C'a%3E" title="Hash">Hash</a></li><li><a href="#impl-PartialEq-for-Structure%3C'a%3E" title="PartialEq">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-Structure%3C'a%3E" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Send-for-Structure%3C'a%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-Structure%3C'a%3E" title="!Sync">!Sync</a></li><li><a href="#impl-Freeze-for-Structure%3C'a%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Structure%3C'a%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-Structure%3C'a%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Structure%3C'a%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate synstructure</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">synstructure</a></div><h1>Struct <span class="struct">Structure</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/synstructure/lib.rs.html#996-1003">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Structure&lt;'a&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A wrapper around a <code>syn::DeriveInput</code> which provides utilities for creating
custom derive trait implementations.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#1005-2386">Source</a><a href="#impl-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1013-1015">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(ast: &amp;'a <a class="struct" href="https://docs.rs/syn/2.0.106/syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This method will panic if the provided AST node represents an untagged
union.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_new" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1022-1067">Source</a><h4 class="code-header">pub fn <a href="#method.try_new" class="fn">try_new</a>(ast: &amp;'a <a class="struct" href="https://docs.rs/syn/2.0.106/syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; <a class="type" href="https://docs.rs/syn/2.0.106/syn/error/type.Result.html" title="type syn::error::Result">Result</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
<p>Unlike <code>Structure::new</code>, this method does not panic if the provided AST
node represents an untagged union.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.variants" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1070-1072">Source</a><h4 class="code-header">pub fn <a href="#method.variants" class="fn">variants</a>(&amp;self) -&gt; &amp;[<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;]</h4></section></summary><div class="docblock"><p>Returns a slice of the variants in this Structure.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.variants_mut" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1075-1077">Source</a><h4 class="code-header">pub fn <a href="#method.variants_mut" class="fn">variants_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;]</h4></section></summary><div class="docblock"><p>Returns a mut slice of the variants in this Structure.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ast" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1081-1083">Source</a><h4 class="code-header">pub fn <a href="#method.ast" class="fn">ast</a>(&amp;self) -&gt; &amp;'a <a class="struct" href="https://docs.rs/syn/2.0.106/syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a></h4></section></summary><div class="docblock"><p>Returns a reference to the underlying <code>syn</code> AST node which this
<code>Structure</code> was created from.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.omitted_variants" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1086-1088">Source</a><h4 class="code-header">pub fn <a href="#method.omitted_variants" class="fn">omitted_variants</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>True if any variants were omitted due to a <code>filter_variants</code> call.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.each" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1121-1134">Source</a><h4 class="code-header">pub fn <a href="#method.each" class="fn">each</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; R,
    R: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,</div></h4></section></summary><div class="docblock"><p>Runs the passed-in function once for each bound field, passing in a <code>BindingInfo</code>.
and generating <code>match</code> arms which evaluate the returned tokens.</p>
<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B(i32, i32),
        C(u32),
    }
};
<span class="kw">let </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="macro">assert_eq!</span>(
    s.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B(<span class="kw-2">ref </span>__binding_0, <span class="kw-2">ref </span>__binding_1,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_1) }
        }
        A::C(<span class="kw-2">ref </span>__binding_0,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.fold" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1169-1183">Source</a><h4 class="code-header">pub fn <a href="#method.fold" class="fn">fold</a>&lt;F, I, R&gt;(&amp;self, init: I, f: F) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>, &amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; R,
    I: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,
    R: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,</div></h4></section></summary><div class="docblock"><p>Runs the passed-in function once for each bound field, passing in the
result of the previous call, and a <code>BindingInfo</code>. generating <code>match</code>
arms which evaluate to the resulting tokens.</p>
<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>
<p>If a variant has been ignored, it will return the <code>init</code> value.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B(i32, i32),
        C(u32),
    }
};
<span class="kw">let </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="macro">assert_eq!</span>(
    s.fold(<span class="macro">quote!</span>(<span class="number">0</span>), |acc, bi| <span class="macro">quote!</span>(#acc + #bi)).to_string(),

    <span class="macro">quote!</span>{
        A::B(<span class="kw-2">ref </span>__binding_0, <span class="kw-2">ref </span>__binding_1,) =&gt; {
            <span class="number">0 </span>+ __binding_0 + __binding_1
        }
        A::C(<span class="kw-2">ref </span>__binding_0,) =&gt; {
            <span class="number">0 </span>+ __binding_0
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.each_variant" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1219-1234">Source</a><h4 class="code-header">pub fn <a href="#method.each_variant" class="fn">each_variant</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a><div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'_&gt;) -&gt; R,
    R: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,</div></h4></section></summary><div class="docblock"><p>Runs the passed-in function once for each variant, passing in a
<code>VariantInfo</code>. and generating <code>match</code> arms which evaluate the returned
tokens.</p>
<p>This method will ignore variants and not bind fields which are ignored
through the <code>filter</code> and <code>filter_variant</code> methods.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B(i32, i32),
        C(u32),
    }
};
<span class="kw">let </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="macro">assert_eq!</span>(
    s.each_variant(|v| {
        <span class="kw">let </span>name = <span class="kw-2">&amp;</span>v.ast().ident;
        <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="macro">stringify!</span>(#name)))
    }).to_string(),

    <span class="macro">quote!</span>{
        A::B(<span class="kw-2">ref </span>__binding_0, <span class="kw-2">ref </span>__binding_1,) =&gt; {
            <span class="macro">println!</span>(<span class="macro">stringify!</span>(B))
        }
        A::C(<span class="kw-2">ref </span>__binding_0,) =&gt; {
            <span class="macro">println!</span>(<span class="macro">stringify!</span>(C))
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1273-1281">Source</a><h4 class="code-header">pub fn <a href="#method.filter" class="fn">filter</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Filter the bindings created by this <code>Structure</code> object. This has 2 effects:</p>
<ul>
<li>
<p>The bindings will no longer appear in match arms generated by methods
on this <code>Structure</code> or its subobjects.</p>
</li>
<li>
<p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
non-filtered fields.</p>
</li>
</ul>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B{ a: i32, b: i32 },
        C{ a: u32 },
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter(|bi| {
    bi.ast().ident == <span class="prelude-val">Some</span>(<span class="macro">quote::format_ident!</span>(<span class="string">"a"</span>))
});

<span class="macro">assert_eq!</span>(
    s.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B{ a: <span class="kw-2">ref </span>__binding_0, .. } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
        A::C{ a: <span class="kw-2">ref </span>__binding_0, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.drain_filter" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1333-1349">Source</a><h4 class="code-header">pub fn <a href="#method.drain_filter" class="fn">drain_filter</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates all the bindings of this <code>Structure</code> object and uses a closure to determine if a
binding should be removed. If the closure returns <code>true</code> the binding is removed from the
structure. If the closure returns <code>false</code>, the binding remains in the structure.</p>
<p>All the removed bindings are moved to a new <code>Structure</code> object which is otherwise identical
to the current one. To understand the effects of removing a binding from a structure check
the <a href="struct.Structure.html#method.filter" title="method synstructure::Structure::filter"><code>Structure::filter</code></a> documentation.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B{ a: i32, b: i32 },
        C{ a: u32 },
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>with_b = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="kw">let </span>with_a = with_b.drain_filter(|bi| {
    bi.ast().ident == <span class="prelude-val">Some</span>(<span class="macro">quote::format_ident!</span>(<span class="string">"a"</span>))
});

<span class="macro">assert_eq!</span>(
    with_a.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B{ a: <span class="kw-2">ref </span>__binding_0, .. } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
        A::C{ a: <span class="kw-2">ref </span>__binding_0, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
    }.to_string()
);

<span class="macro">assert_eq!</span>(
    with_b.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B{ b: <span class="kw-2">ref </span>__binding_1, .. } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_1) }
        }
        A::C{ .. } =&gt; {

        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.add_where_predicate" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1388-1391">Source</a><h4 class="code-header">pub fn <a href="#method.add_where_predicate" class="fn">add_where_predicate</a>(&amp;mut self, pred: <a class="enum" href="https://docs.rs/syn/2.0.106/syn/generics/enum.WherePredicate.html" title="enum syn::generics::WherePredicate">WherePredicate</a>) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>Specify additional where predicate bounds which should be generated by
impl-generating functions such as <code>gen_impl</code>, <code>bound_impl</code>, and
<code>unsafe_bound_impl</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="comment">// Add an additional where predicate.
</span>s.add_where_predicate(<span class="macro">syn::parse_quote!</span>(T: std::fmt::Display));

<span class="macro">assert_eq!</span>(
    s.bound_impl(<span class="macro">quote!</span>(krate::Trait), <span class="macro">quote!</span>{
        <span class="kw">fn </span>a() {}
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt;
                <span class="kw">where </span>T: std::fmt::Display,
                      T: krate::Trait,
                      <span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait,
                      U: krate::Trait
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.add_bounds" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1430-1433">Source</a><h4 class="code-header">pub fn <a href="#method.add_bounds" class="fn">add_bounds</a>(&amp;mut self, mode: <a class="enum" href="enum.AddBounds.html" title="enum synstructure::AddBounds">AddBounds</a>) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>Specify which bounds should be generated by impl-generating functions
such as <code>gen_impl</code>, <code>bound_impl</code>, and <code>unsafe_bound_impl</code>.</p>
<p>The default behaviour is to generate both field and generic bounds from
type parameters.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="comment">// Limit bounds to only generics.
</span>s.add_bounds(AddBounds::Generics);

<span class="macro">assert_eq!</span>(
    s.bound_impl(<span class="macro">quote!</span>(krate::Trait), <span class="macro">quote!</span>{
        <span class="kw">fn </span>a() {}
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt;
                <span class="kw">where </span>T: krate::Trait,
                      U: krate::Trait
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_variants" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1469-1479">Source</a><h4 class="code-header">pub fn <a href="#method.filter_variants" class="fn">filter_variants</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'_&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Filter the variants matched by this <code>Structure</code> object. This has 2 effects:</p>
<ul>
<li>
<p>Match arms destructuring these variants will no longer be generated by
methods on this <code>Structure</code></p>
</li>
<li>
<p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
fields in non-fitered variants.</p>
</li>
</ul>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B(i32, i32),
        C(u32),
    }
};

<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    s.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::C(<span class="kw-2">ref </span>__binding_0,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
        <span class="kw">_ </span>=&gt; {}
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.drain_filter_variants" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1523-1541">Source</a><h4 class="code-header">pub fn <a href="#method.drain_filter_variants" class="fn">drain_filter_variants</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'_&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class="docblock"><p>Iterates all the variants of this <code>Structure</code> object and uses a closure to determine if a
variant should be removed. If the closure returns <code>true</code> the variant is removed from the
structure. If the closure returns <code>false</code>, the variant remains in the structure.</p>
<p>All the removed variants are moved to a new <code>Structure</code> object which is otherwise identical
to the current one. To understand the effects of removing a variant from a structure check
the <a href="struct.Structure.html#method.filter_variants" title="method synstructure::Structure::filter_variants"><code>Structure::filter_variants</code></a> documentation.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B(i32, i32),
        C(u32),
    }
};

<span class="kw">let </span><span class="kw-2">mut </span>with_c = Structure::new(<span class="kw-2">&amp;</span>di);

<span class="kw">let </span>with_b = with_c.drain_filter_variants(|v| v.ast().ident == <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    with_c.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::C(<span class="kw-2">ref </span>__binding_0,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
    }.to_string()
);

<span class="macro">assert_eq!</span>(
    with_b.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B(<span class="kw-2">ref </span>__binding_0, <span class="kw-2">ref </span>__binding_1,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_1) }
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.remove_variant" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1548-1552">Source</a><h4 class="code-header">pub fn <a href="#method.remove_variant" class="fn">remove_variant</a>(&amp;mut self, idx: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>Remove the variant at the given index.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>Panics if the index is out of range.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bind_with" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1584-1592">Source</a><h4 class="code-header">pub fn <a href="#method.bind_with" class="fn">bind_with</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>&lt;'_&gt;) -&gt; <a class="enum" href="enum.BindStyle.html" title="enum synstructure::BindStyle">BindStyle</a>,</div></h4></section></summary><div class="docblock"><p>Updates the <code>BindStyle</code> for each of the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B(i32, i32),
        C(u32),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.bind_with(|bi| BindStyle::RefMut);

<span class="macro">assert_eq!</span>(
    s.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B(<span class="kw-2">ref mut </span>__binding_0, <span class="kw-2">ref mut </span>__binding_1,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_1) }
        }
        A::C(<span class="kw-2">ref mut </span>__binding_0,) =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, __binding_0) }
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.binding_name" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1630-1638">Source</a><h4 class="code-header">pub fn <a href="#method.binding_name" class="fn">binding_name</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; &amp;mut Self<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="https://docs.rs/syn/2.0.106/syn/data/struct.Field.html" title="struct syn::data::Field">Field</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>,</div></h4></section></summary><div class="docblock"><p>Updates the binding name for each fo the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>
<p>The function will be called with the <code>BindingInfo</code> and its index in the
enclosing variant.</p>
<p>The default name is <code>__binding_{}</code> where <code>{}</code> is replaced with an
increasing number.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A {
        B{ a: i32, b: i32 },
        C{ a: u32 },
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.binding_name(|bi, i| bi.ident.clone().unwrap());

<span class="macro">assert_eq!</span>(
    s.each(|bi| <span class="macro">quote!</span>(<span class="macro">println!</span>(<span class="string">"{:?}"</span>, #bi))).to_string(),

    <span class="macro">quote!</span>{
        A::B{ a: <span class="kw-2">ref </span>a, b: <span class="kw-2">ref </span>b, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, a) }
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, b) }
        }
        A::C{ a: <span class="kw-2">ref </span>a, } =&gt; {
            { <span class="macro">println!</span>(<span class="string">"{:?}"</span>, a) }
        }
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.referenced_ty_params" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1667-1675">Source</a><h4 class="code-header">pub fn <a href="#method.referenced_ty_params" class="fn">referenced_ty_params</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'a <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a list of the type parameters which are refrenced in the types
of non-filtered fields / variants.</p>
<h5 id="caveat"><a class="doc-anchor" href="#caveat">§</a>Caveat</h5>
<p>If the struct contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T, i32),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"C"</span>);

<span class="macro">assert_eq!</span>(
    s.referenced_ty_params(),
    <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="macro">quote::format_ident!</span>(<span class="string">"T"</span>)]
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.add_impl_generic" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1713-1716">Source</a><h4 class="code-header">pub fn <a href="#method.add_impl_generic" class="fn">add_impl_generic</a>(&amp;mut self, param: <a class="enum" href="https://docs.rs/syn/2.0.106/syn/generics/enum.GenericParam.html" title="enum syn::generics::GenericParam">GenericParam</a>) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>Adds an <code>impl&lt;&gt;</code> generic parameter.
This can be used when the trait to be derived needs some extra generic parameters.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);
<span class="kw">let </span>generic: syn::GenericParam = <span class="macro">syn::parse_quote!</span>(X: krate::AnotherTrait);

<span class="macro">assert_eq!</span>(
    s.add_impl_generic(generic)
        .bound_impl(<span class="macro">quote!</span>(krate::Trait&lt;X&gt;),
        <span class="macro">quote!</span>{
                <span class="kw">fn </span>a() {}
        }
    ).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U, X: krate::AnotherTrait&gt; krate::Trait&lt;X&gt; <span class="kw">for </span>A&lt;T, U&gt;
                <span class="kw">where </span>T : krate :: Trait &lt; X &gt;,
                      <span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait&lt;X&gt;,
                      U: krate::Trait&lt;X&gt;
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.add_trait_bounds" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1726-1791">Source</a><h4 class="code-header">pub fn <a href="#method.add_trait_bounds" class="fn">add_trait_bounds</a>(
    &amp;self,
    bound: &amp;<a class="struct" href="https://docs.rs/syn/2.0.106/syn/generics/struct.TraitBound.html" title="struct syn::generics::TraitBound">TraitBound</a>,
    where_clause: &amp;mut <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://docs.rs/syn/2.0.106/syn/generics/struct.WhereClause.html" title="struct syn::generics::WhereClause">WhereClause</a>&gt;,
    mode: <a class="enum" href="enum.AddBounds.html" title="enum synstructure::AddBounds">AddBounds</a>,
)</h4></section></summary><div class="docblock"><p>Add trait bounds for a trait with the given path for each type parmaeter
referenced in the types of non-filtered fields.</p>
<h5 id="caveat-1"><a class="doc-anchor" href="#caveat-1">§</a>Caveat</h5>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.underscore_const" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1794-1796">Source</a><h4 class="code-header">pub fn <a href="#method.underscore_const" class="fn">underscore_const</a>(&amp;mut self, _enabled: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>This method is a no-op, underscore consts are used by default now.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bound_impl" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1857-1864">Source</a><h4 class="code-header">pub fn <a href="#method.bound_impl" class="fn">bound_impl</a>&lt;P: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(
    &amp;self,
    path: P,
    body: B,
) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>
<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>
<h5 id="hygiene-and-paths"><a class="doc-anchor" href="#hygiene-and-paths">§</a>Hygiene and Paths</h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="caveat-2"><a class="doc-anchor" href="#caveat-2">§</a>Caveat</h5>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    s.bound_impl(<span class="macro">quote!</span>(krate::Trait), <span class="macro">quote!</span>{
        <span class="kw">fn </span>a() {}
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt;
                <span class="kw">where </span><span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait,
                      U: krate::Trait
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unsafe_bound_impl" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1925-1932">Source</a><h4 class="code-header">pub fn <a href="#method.unsafe_bound_impl" class="fn">unsafe_bound_impl</a>&lt;P: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(
    &amp;self,
    path: P,
    body: B,
) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the unsafe trait <code>path</code>.</p>
<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>
<h5 id="hygiene-and-paths-1"><a class="doc-anchor" href="#hygiene-and-paths-1">§</a>Hygiene and Paths</h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="caveat-3"><a class="doc-anchor" href="#caveat-3">§</a>Caveat</h5>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    s.unsafe_bound_impl(<span class="macro">quote!</span>(krate::Trait), <span class="macro">quote!</span>{
        <span class="kw">fn </span>a() {}
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">unsafe impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt;
                <span class="kw">where </span><span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait,
                      U: krate::Trait
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unbound_impl" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#1983-1990">Source</a><h4 class="code-header">pub fn <a href="#method.unbound_impl" class="fn">unbound_impl</a>&lt;P: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(
    &amp;self,
    path: P,
    body: B,
) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>
<p>This method will not add any where clauses to the impl.</p>
<h5 id="hygiene-and-paths-2"><a class="doc-anchor" href="#hygiene-and-paths-2">§</a>Hygiene and Paths</h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    s.unbound_impl(<span class="macro">quote!</span>(krate::Trait), <span class="macro">quote!</span>{
        <span class="kw">fn </span>a() {}
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt; {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.unsafe_unbound_impl" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#2042-2049">Source</a><h4 class="code-header">pub fn <a href="#method.unsafe_unbound_impl" class="fn">unsafe_unbound_impl</a>&lt;P: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B: <a class="trait" href="https://docs.rs/quote/1.0.40/quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(
    &amp;self,
    path: P,
    body: B,
) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated</span></div></span></summary><div class="docblock"><blockquote>
<p>NOTE: This methods’ features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the unsafe trait <code>path</code>.</p>
<p>This method will not add any where clauses to the impl.</p>
<h5 id="hygiene-and-paths-3"><a class="doc-anchor" href="#hygiene-and-paths-3">§</a>Hygiene and Paths</h5>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don’t want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h5>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    s.unsafe_unbound_impl(<span class="macro">quote!</span>(krate::Trait), <span class="macro">quote!</span>{
        <span class="kw">fn </span>a() {}
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">unsafe impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt; {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.gen_impl" class="method"><a class="src rightside" href="../src/synstructure/lib.rs.html#2295-2301">Source</a><h4 class="code-header">pub fn <a href="#method.gen_impl" class="fn">gen_impl</a>(&amp;self, cfg: <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>) -&gt; <a class="struct" href="https://docs.rs/proc-macro2/1.0.101/proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><p>Generate an impl block for the given struct. This impl block will
automatically use hygiene tricks to avoid polluting the caller’s
namespace, and will automatically add trait bounds for generic type
parameters.</p>
<h5 id="syntax"><a class="doc-anchor" href="#syntax">§</a>Syntax</h5>
<p>This function accepts its arguments as a <code>TokenStream</code>. The recommended way
to call this function is passing the result of invoking the <code>quote!</code>
macro to it.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>s.gen_impl(<span class="macro">quote!</span> {
    <span class="comment">// You can write any items which you want to import into scope here.
    // For example, you may want to include an `extern crate` for the
    // crate which implements your trait. These items will only be
    // visible to the code you generate, and won't be exposed to the
    // consuming crate
    </span><span class="kw">extern crate </span>krate;

    <span class="comment">// You can also add `use` statements here to bring types or traits
    // into scope.
    //
    // WARNING: Try not to use common names here, because the stable
    // version of syn does not support hygiene and you could accidentally
    // shadow types from the caller crate.
    </span><span class="kw">use </span>krate::Trait <span class="kw">as </span>MyTrait;

    <span class="comment">// The actual impl block is a `gen impl` or `gen unsafe impl` block.
    // You can use `@Self` to refer to the structure's type.
    </span>gen <span class="kw">impl </span>MyTrait <span class="kw">for </span>@<span class="self">Self </span>{
        <span class="kw">fn </span>f(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
})</code></pre></div>
<p>The most common usage of this trait involves loading the crate the
target trait comes from with <code>extern crate</code>, and then invoking a <code>gen impl</code> block.</p>
<h5 id="hygiene"><a class="doc-anchor" href="#hygiene">§</a>Hygiene</h5>
<p>This method tries to handle hygiene intelligently for both stable and
unstable proc-macro implementations, however there are visible
differences.</p>
<p>The output of every <code>gen_impl</code> function is wrapped in a dummy <code>const</code>
value, to ensure that it is given its own scope, and any values brought
into scope are not leaked to the calling crate.</p>
<p>By default, the above invocation may generate an output like the
following:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">const _</span>: () = {
    <span class="kw">extern crate </span>krate;
    <span class="kw">use </span>krate::Trait <span class="kw">as </span>MyTrait;
    <span class="kw">impl</span>&lt;T&gt; MyTrait <span class="kw">for </span>Struct&lt;T&gt; <span class="kw">where </span>T: MyTrait {
        <span class="kw">fn </span>f(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
};</code></pre></div><h6 id="using-the-std-crate"><a class="doc-anchor" href="#using-the-std-crate">§</a>Using the <code>std</code> crate</h6>
<p>If you are using <code>quote!()</code> to implement your trait, with the
<code>proc-macro2/nightly</code> feature, <code>std</code> isn’t considered to be in scope for
your macro. This means that if you use types from <code>std</code> in your
procedural macro, you’ll want to explicitly load it with an <code>extern crate std;</code>.</p>
<h6 id="absolute-paths"><a class="doc-anchor" href="#absolute-paths">§</a>Absolute paths</h6>
<p>You should generally avoid using absolute paths in your generated code,
as they will resolve very differently when using the stable and nightly
versions of <code>proc-macro2</code>. Instead, load the crates you need to use
explictly with <code>extern crate</code> and</p>
<h5 id="trait-bounds"><a class="doc-anchor" href="#trait-bounds">§</a>Trait Bounds</h5>
<p>This method will automatically add trait bounds for any type parameters
which are referenced within the types of non-ignored fields.</p>
<p>Additional type parameters may be added with the generics syntax after
the <code>impl</code> keyword.</p>
<h6 id="type-macro-caveat"><a class="doc-anchor" href="#type-macro-caveat">§</a>Type Macro Caveat</h6>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This function will generate a <code>compile_error!</code> if additional type
parameters added by <code>impl&lt;..&gt;</code> conflict with generic type parameters on
the original struct.</p>
<h5 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h5>
<p>This function will panic if the input <code>TokenStream</code> is not well-formed.</p>
<h5 id="example-usage"><a class="doc-anchor" href="#example-usage">§</a>Example Usage</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>di: syn::DeriveInput = <span class="macro">syn::parse_quote!</span> {
    <span class="kw">enum </span>A&lt;T, U&gt; {
        B(T),
        C(<span class="prelude-ty">Option</span>&lt;U&gt;),
    }
};
<span class="kw">let </span><span class="kw-2">mut </span>s = Structure::new(<span class="kw-2">&amp;</span>di);

s.filter_variants(|v| v.ast().ident != <span class="string">"B"</span>);

<span class="macro">assert_eq!</span>(
    s.gen_impl(<span class="macro">quote!</span> {
        <span class="kw">extern crate </span>krate;
        gen <span class="kw">impl </span>krate::Trait <span class="kw">for </span>@<span class="self">Self </span>{
            <span class="kw">fn </span>a() {}
        }
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt;
            <span class="kw">where
                </span><span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait,
                U: krate::Trait
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);

<span class="comment">// NOTE: You can also add extra generics after the impl
</span><span class="macro">assert_eq!</span>(
    s.gen_impl(<span class="macro">quote!</span> {
        <span class="kw">extern crate </span>krate;
        gen <span class="kw">impl</span>&lt;X: krate::OtherTrait&gt; krate::Trait&lt;X&gt; <span class="kw">for </span>@<span class="self">Self
        </span><span class="kw">where
            </span>X: Send + Sync,
        {
            <span class="kw">fn </span>a() {}
        }
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;X: krate::OtherTrait, T, U&gt; krate::Trait&lt;X&gt; <span class="kw">for </span>A&lt;T, U&gt;
            <span class="kw">where
                </span>X: Send + Sync,
                <span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait&lt;X&gt;,
                U: krate::Trait&lt;X&gt;
            {
                <span class="kw">fn </span>a() {}
            }
        };
    }.to_string()
);

<span class="comment">// NOTE: you can generate multiple traits with a single call
</span><span class="macro">assert_eq!</span>(
    s.gen_impl(<span class="macro">quote!</span> {
        <span class="kw">extern crate </span>krate;

        gen <span class="kw">impl </span>krate::Trait <span class="kw">for </span>@<span class="self">Self </span>{
            <span class="kw">fn </span>a() {}
        }

        gen <span class="kw">impl </span>krate::OtherTrait <span class="kw">for </span>@<span class="self">Self </span>{
            <span class="kw">fn </span>b() {}
        }
    }).to_string(),
    <span class="macro">quote!</span>{
        <span class="kw">const _</span>: () = {
            <span class="kw">extern crate </span>krate;
            <span class="kw">impl</span>&lt;T, U&gt; krate::Trait <span class="kw">for </span>A&lt;T, U&gt;
            <span class="kw">where
                </span><span class="prelude-ty">Option</span>&lt;U&gt;: krate::Trait,
                U: krate::Trait
            {
                <span class="kw">fn </span>a() {}
            }

            <span class="kw">impl</span>&lt;T, U&gt; krate::OtherTrait <span class="kw">for </span>A&lt;T, U&gt;
            <span class="kw">where
                </span><span class="prelude-ty">Option</span>&lt;U&gt;: krate::OtherTrait,
                U: krate::OtherTrait
            {
                <span class="kw">fn </span>b() {}
            }
        };
    }.to_string()
);</code></pre></div>
<p>Use <code>add_bounds</code> to change which bounds are generated.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#impl-Clone-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#impl-Debug-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#impl-Hash-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut __H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#impl-PartialEq-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#impl-Eq-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-StructuralPartialEq-for-Structure%3C'a%3E" class="impl"><a class="src rightside" href="../src/synstructure/lib.rs.html#995">Source</a><a href="#impl-StructuralPartialEq-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Structure%3C'a%3E" class="impl"><a href="#impl-Freeze-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-RefUnwindSafe-for-Structure%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-Structure%3C'a%3E" class="impl"><a href="#impl-Send-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-Structure%3C'a%3E" class="impl"><a href="#impl-Sync-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-Structure%3C'a%3E" class="impl"><a href="#impl-Unpin-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-Structure%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-Structure%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>