<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ISO 8601 combined date and time without timezone."><title>NaiveDateTime in chrono - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="chrono" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (975e6c8fe 2025-09-23)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">NaiveDateTime</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../chrono/index.html">chrono</a><span class="version">0.4.42</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Naive<wbr>Date<wbr>Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li><li><a href="#associatedconstant.UNIX_EPOCH" title="UNIX_EPOCH">UNIX_EPOCH</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.and_local_timezone" title="and_local_timezone">and_local_timezone</a></li><li><a href="#method.and_utc" title="and_utc">and_utc</a></li><li><a href="#method.checked_add_days" title="checked_add_days">checked_add_days</a></li><li><a href="#method.checked_add_months" title="checked_add_months">checked_add_months</a></li><li><a href="#method.checked_add_offset" title="checked_add_offset">checked_add_offset</a></li><li><a href="#method.checked_add_signed" title="checked_add_signed">checked_add_signed</a></li><li><a href="#method.checked_sub_days" title="checked_sub_days">checked_sub_days</a></li><li><a href="#method.checked_sub_months" title="checked_sub_months">checked_sub_months</a></li><li><a href="#method.checked_sub_offset" title="checked_sub_offset">checked_sub_offset</a></li><li><a href="#method.checked_sub_signed" title="checked_sub_signed">checked_sub_signed</a></li><li><a href="#method.date" title="date">date</a></li><li><a href="#method.format" title="format">format</a></li><li><a href="#method.format_with_items" title="format_with_items">format_with_items</a></li><li><a href="#method.from_timestamp" title="from_timestamp">from_timestamp</a></li><li><a href="#method.from_timestamp_micros" title="from_timestamp_micros">from_timestamp_micros</a></li><li><a href="#method.from_timestamp_millis" title="from_timestamp_millis">from_timestamp_millis</a></li><li><a href="#method.from_timestamp_nanos" title="from_timestamp_nanos">from_timestamp_nanos</a></li><li><a href="#method.from_timestamp_opt" title="from_timestamp_opt">from_timestamp_opt</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.parse_and_remainder" title="parse_and_remainder">parse_and_remainder</a></li><li><a href="#method.parse_from_str" title="parse_from_str">parse_from_str</a></li><li><a href="#method.signed_duration_since" title="signed_duration_since">signed_duration_since</a></li><li><a href="#method.time" title="time">time</a></li><li><a href="#method.timestamp" title="timestamp">timestamp</a></li><li><a href="#method.timestamp_micros" title="timestamp_micros">timestamp_micros</a></li><li><a href="#method.timestamp_millis" title="timestamp_millis">timestamp_millis</a></li><li><a href="#method.timestamp_nanos" title="timestamp_nanos">timestamp_nanos</a></li><li><a href="#method.timestamp_nanos_opt" title="timestamp_nanos_opt">timestamp_nanos_opt</a></li><li><a href="#method.timestamp_subsec_micros" title="timestamp_subsec_micros">timestamp_subsec_micros</a></li><li><a href="#method.timestamp_subsec_millis" title="timestamp_subsec_millis">timestamp_subsec_millis</a></li><li><a href="#method.timestamp_subsec_nanos" title="timestamp_subsec_nanos">timestamp_subsec_nanos</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDays%3E-for-NaiveDateTime" title="Add&#60;Days&#62;">Add&#60;Days&#62;</a></li><li><a href="#impl-Add%3CDuration%3E-for-NaiveDateTime" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CFixedOffset%3E-for-NaiveDateTime" title="Add&#60;FixedOffset&#62;">Add&#60;FixedOffset&#62;</a></li><li><a href="#impl-Add%3CMonths%3E-for-NaiveDateTime" title="Add&#60;Months&#62;">Add&#60;Months&#62;</a></li><li><a href="#impl-Add%3CTimeDelta%3E-for-NaiveDateTime" title="Add&#60;TimeDelta&#62;">Add&#60;TimeDelta&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-NaiveDateTime" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CTimeDelta%3E-for-NaiveDateTime" title="AddAssign&#60;TimeDelta&#62;">AddAssign&#60;TimeDelta&#62;</a></li><li><a href="#impl-Clone-for-NaiveDateTime" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-NaiveDateTime" title="Copy">Copy</a></li><li><a href="#impl-Datelike-for-NaiveDateTime" title="Datelike">Datelike</a></li><li><a href="#impl-Debug-for-NaiveDateTime" title="Debug">Debug</a></li><li><a href="#impl-Default-for-NaiveDateTime" title="Default">Default</a></li><li><a href="#impl-Display-for-NaiveDateTime" title="Display">Display</a></li><li><a href="#impl-DurationRound-for-NaiveDateTime" title="DurationRound">DurationRound</a></li><li><a href="#impl-Eq-for-NaiveDateTime" title="Eq">Eq</a></li><li><a href="#impl-From%3CNaiveDate%3E-for-NaiveDateTime" title="From&#60;NaiveDate&#62;">From&#60;NaiveDate&#62;</a></li><li><a href="#impl-From%3CNaiveDateTime%3E-for-NaiveDate" title="From&#60;NaiveDateTime&#62;">From&#60;NaiveDateTime&#62;</a></li><li><a href="#impl-FromStr-for-NaiveDateTime" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-NaiveDateTime" title="Hash">Hash</a></li><li><a href="#impl-Ord-for-NaiveDateTime" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-NaiveDateTime" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-NaiveDateTime" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-StructuralPartialEq-for-NaiveDateTime" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-Sub-for-NaiveDateTime" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDays%3E-for-NaiveDateTime" title="Sub&#60;Days&#62;">Sub&#60;Days&#62;</a></li><li><a href="#impl-Sub%3CDuration%3E-for-NaiveDateTime" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CFixedOffset%3E-for-NaiveDateTime" title="Sub&#60;FixedOffset&#62;">Sub&#60;FixedOffset&#62;</a></li><li><a href="#impl-Sub%3CMonths%3E-for-NaiveDateTime" title="Sub&#60;Months&#62;">Sub&#60;Months&#62;</a></li><li><a href="#impl-Sub%3CTimeDelta%3E-for-NaiveDateTime" title="Sub&#60;TimeDelta&#62;">Sub&#60;TimeDelta&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-NaiveDateTime" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CTimeDelta%3E-for-NaiveDateTime" title="SubAssign&#60;TimeDelta&#62;">SubAssign&#60;TimeDelta&#62;</a></li><li><a href="#impl-Timelike-for-NaiveDateTime" title="Timelike">Timelike</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-NaiveDateTime" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-NaiveDateTime" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-NaiveDateTime" title="Send">Send</a></li><li><a href="#impl-Sync-for-NaiveDateTime" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-NaiveDateTime" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-NaiveDateTime" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-SubsecRound-for-T" title="SubsecRound">SubsecRound</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate chrono</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">chrono</a></div><h1>Struct <span class="struct">Naive<wbr>Date<wbr>Time</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/chrono/naive/datetime/mod.rs.html#76-79">Source</a> </span></div><pre class="rust item-decl"><code>pub struct NaiveDateTime { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>ISO 8601 combined date and time without timezone.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p><code>NaiveDateTime</code> is commonly created from <a href="struct.NaiveDate.html" title="struct chrono::NaiveDate"><code>NaiveDate</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>).unwrap();</code></pre></div>
<p>You can use typical <a href="trait.Datelike.html" title="trait chrono::Datelike">date-like</a> and <a href="trait.Timelike.html" title="trait chrono::Timelike">time-like</a> methods,
provided that relevant traits are in the scope.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, Timelike, Weekday};

<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Fri);
<span class="macro">assert_eq!</span>(dt.num_seconds_from_midnight(), <span class="number">33011</span>);</code></pre></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#81-954">Source</a><a href="#impl-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#942">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: Self</h4></section></summary><div class="docblock"><p>The minimum possible <code>NaiveDateTime</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#945">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: Self</h4></section></summary><div class="docblock"><p>The maximum possible <code>NaiveDateTime</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.UNIX_EPOCH" class="associatedconstant"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#953">Source</a><h4 class="code-header">pub const <a href="#associatedconstant.UNIX_EPOCH" class="constant">UNIX_EPOCH</a>: Self</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.41: use <code>DateTime::UNIX_EPOCH</code> instead</span></div></span></summary><div class="docblock"><p>The datetime of the Unix Epoch, 1970-01-01 00:00:00.</p>
<p>Note that while this may look like the UNIX epoch, it is missing the
time zone. The actual UNIX epoch cannot be expressed by this type,
however it is available as <a href="struct.DateTime.html#associatedconstant.UNIX_EPOCH" title="associated constant chrono::DateTime::UNIX_EPOCH"><code>DateTime::UNIX_EPOCH</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#99-101">Source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(date: <a class="struct" href="struct.NaiveDate.html" title="struct chrono::NaiveDate">NaiveDate</a>, time: <a class="struct" href="struct.NaiveTime.html" title="struct chrono::NaiveTime">NaiveTime</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> from date and time components.
Equivalent to <a href="./struct.NaiveDate.html#method.and_time"><code>date.and_time(time)</code></a>
and many other helper constructors on <code>NaiveDate</code>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, NaiveTime};

<span class="kw">let </span>d = NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">3</span>).unwrap();
<span class="kw">let </span>t = NaiveTime::from_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();

<span class="kw">let </span>dt = NaiveDateTime::new(d, t);
<span class="macro">assert_eq!</span>(dt.date(), d);
<span class="macro">assert_eq!</span>(dt.time(), t);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.from_timestamp" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#122-126">Source</a><h4 class="code-header">pub const fn <a href="#method.from_timestamp" class="fn">from_timestamp</a>(secs: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>, nsecs: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.23: use <code>DateTime::from_timestamp</code> instead</span></div></span></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> corresponding to a UTC date and time,
from the number of non-leap seconds
since the midnight UTC on January 1, 1970 (aka “UNIX timestamp”)
and the number of nanoseconds since the last whole non-leap second.</p>
<p>For a non-naive version of this function see <a href="trait.TimeZone.html#method.timestamp" title="method chrono::TimeZone::timestamp"><code>TimeZone::timestamp</code></a>.</p>
<p>The nanosecond part can exceed 1,000,000,000 in order to represent a
<a href="struct.NaiveTime.html#leap-second-handling" title="struct chrono::NaiveTime">leap second</a>, but only when <code>secs % 60 == 59</code>.
(The true “UNIX timestamp” cannot represent a leap second unambiguously.)</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if the number of seconds would be out of range for a <code>NaiveDateTime</code> (more than
ca. 262,000 years away from common era), and panics on an invalid nanosecond (2 seconds or
more).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_timestamp_millis" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#139-141">Source</a><h4 class="code-header">pub const fn <a href="#method.from_timestamp_millis" class="fn">from_timestamp_millis</a>(millis: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>DateTime::from_timestamp_millis</code> instead</span></div></span></summary><div class="docblock"><p>Creates a new <a href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a> from milliseconds since the UNIX epoch.</p>
<p>The UNIX epoch starts on midnight, January 1, 1970, UTC.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>Returns <code>None</code> if the number of milliseconds would be out of range for a <code>NaiveDateTime</code>
(more than ca. 262,000 years away from common era)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_timestamp_micros" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#154-158">Source</a><h4 class="code-header">pub const fn <a href="#method.from_timestamp_micros" class="fn">from_timestamp_micros</a>(micros: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>DateTime::from_timestamp_micros</code> instead</span></div></span></summary><div class="docblock"><p>Creates a new <a href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a> from microseconds since the UNIX epoch.</p>
<p>The UNIX epoch starts on midnight, January 1, 1970, UTC.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>Returns <code>None</code> if the number of microseconds would be out of range for a <code>NaiveDateTime</code>
(more than ca. 262,000 years away from common era)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_timestamp_nanos" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#171-175">Source</a><h4 class="code-header">pub const fn <a href="#method.from_timestamp_nanos" class="fn">from_timestamp_nanos</a>(nanos: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>DateTime::from_timestamp_nanos</code> instead</span></div></span></summary><div class="docblock"><p>Creates a new <a href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a> from nanoseconds since the UNIX epoch.</p>
<p>The UNIX epoch starts on midnight, January 1, 1970, UTC.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>Returns <code>None</code> if the number of nanoseconds would be out of range for a <code>NaiveDateTime</code>
(more than ca. 262,000 years away from common era)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_timestamp_opt" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#194-196">Source</a><h4 class="code-header">pub const fn <a href="#method.from_timestamp_opt" class="fn">from_timestamp_opt</a>(secs: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>, nsecs: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>DateTime::from_timestamp</code> instead</span></div></span></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> corresponding to a UTC date and time,
from the number of non-leap seconds
since the midnight UTC on January 1, 1970 (aka “UNIX timestamp”)
and the number of nanoseconds since the last whole non-leap second.</p>
<p>The nanosecond part can exceed 1,000,000,000 in order to represent a
<a href="struct.NaiveTime.html#leap-second-handling" title="struct chrono::NaiveTime">leap second</a>, but only when <code>secs % 60 == 59</code>.
(The true “UNIX timestamp” cannot represent a leap second unambiguously.)</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>Returns <code>None</code> if the number of seconds would be out of range for a <code>NaiveDateTime</code> (more
than ca. 262,000 years away from common era), and panics on an invalid nanosecond
(2 seconds or more).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_from_str" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#285-289">Source</a><h4 class="code-header">pub fn <a href="#method.parse_from_str" class="fn">parse_from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, fmt: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="type" href="format/type.ParseResult.html" title="type chrono::format::ParseResult">ParseResult</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a string with the specified format string and returns a new <code>NaiveDateTime</code>.
See the <a href="format/strftime/index.html" title="mod chrono::format::strftime"><code>format::strftime</code> module</a>
on the supported escape sequences.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime};

<span class="kw">let </span>parse_from_str = NaiveDateTime::parse_from_str;

<span class="macro">assert_eq!</span>(
    parse_from_str(<span class="string">"2015-09-05 23:56:04"</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>),
    <span class="prelude-val">Ok</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">5</span>).unwrap().and_hms_opt(<span class="number">23</span>, <span class="number">56</span>, <span class="number">4</span>).unwrap())
);
<span class="macro">assert_eq!</span>(
    parse_from_str(<span class="string">"5sep2015pm012345.6789"</span>, <span class="string">"%d%b%Y%p%I%M%S%.f"</span>),
    <span class="prelude-val">Ok</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">5</span>)
        .unwrap()
        .and_hms_micro_opt(<span class="number">13</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">678_900</span>)
        .unwrap())
);</code></pre></div>
<p>Offset is ignored for the purpose of parsing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(
    parse_from_str(<span class="string">"2014-5-17T12:34:56+09:30"</span>, <span class="string">"%Y-%m-%dT%H:%M:%S%z"</span>),
    <span class="prelude-val">Ok</span>(NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">17</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);</code></pre></div>
<p><a href="./struct.NaiveTime.html#leap-second-handling">Leap seconds</a> are correctly handled by
treating any time of the form <code>hh:mm:60</code> as a leap second.
(This equally applies to the formatting, so the round trip is possible.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(
    parse_from_str(<span class="string">"2015-07-01 08:59:60.123"</span>, <span class="string">"%Y-%m-%d %H:%M:%S%.f"</span>),
    <span class="prelude-val">Ok</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">7</span>, <span class="number">1</span>)
        .unwrap()
        .and_hms_milli_opt(<span class="number">8</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">1_123</span>)
        .unwrap())
);</code></pre></div>
<p>Missing seconds are assumed to be zero,
but out-of-bound times or insufficient fields are errors otherwise.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(
    parse_from_str(<span class="string">"94/9/4 7:15"</span>, <span class="string">"%y/%m/%d %H:%M"</span>),
    <span class="prelude-val">Ok</span>(NaiveDate::from_ymd_opt(<span class="number">1994</span>, <span class="number">9</span>, <span class="number">4</span>).unwrap().and_hms_opt(<span class="number">7</span>, <span class="number">15</span>, <span class="number">0</span>).unwrap())
);

<span class="macro">assert!</span>(parse_from_str(<span class="string">"04m33s"</span>, <span class="string">"%Mm%Ss"</span>).is_err());
<span class="macro">assert!</span>(parse_from_str(<span class="string">"94/9/4 12"</span>, <span class="string">"%y/%m/%d %H"</span>).is_err());
<span class="macro">assert!</span>(parse_from_str(<span class="string">"94/9/4 17:60"</span>, <span class="string">"%y/%m/%d %H:%M"</span>).is_err());
<span class="macro">assert!</span>(parse_from_str(<span class="string">"94/9/4 24:00:00"</span>, <span class="string">"%y/%m/%d %H:%M:%S"</span>).is_err());</code></pre></div>
<p>All parsed fields should be consistent to each other, otherwise it’s an error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fmt = <span class="string">"%Y-%m-%d %H:%M:%S = UNIX timestamp %s"</span>;
<span class="macro">assert!</span>(parse_from_str(<span class="string">"2001-09-09 01:46:39 = UNIX timestamp 999999999"</span>, fmt).is_ok());
<span class="macro">assert!</span>(parse_from_str(<span class="string">"1970-01-01 00:00:00 = UNIX timestamp 1"</span>, fmt).is_err());</code></pre></div>
<p>Years before 1 BCE or after 9999 CE, require an initial sign</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">let </span>fmt = <span class="string">"%Y-%m-%d %H:%M:%S"</span>;
 <span class="macro">assert!</span>(parse_from_str(<span class="string">"10000-09-09 01:46:39"</span>, fmt).is_err());
 <span class="macro">assert!</span>(parse_from_str(<span class="string">"+10000-09-09 01:46:39"</span>, fmt).is_ok());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.parse_and_remainder" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#313-317">Source</a><h4 class="code-header">pub fn <a href="#method.parse_and_remainder" class="fn">parse_and_remainder</a>&lt;'a&gt;(
    s: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
    fmt: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
) -&gt; <a class="type" href="format/type.ParseResult.html" title="type chrono::format::ParseResult">ParseResult</a>&lt;(<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Parses a string with the specified format string and returns a new <code>NaiveDateTime</code>, and a
slice with the remaining portion of the string.
See the <a href="format/strftime/index.html" title="mod chrono::format::strftime"><code>format::strftime</code> module</a>
on the supported escape sequences.</p>
<p>Similar to <a href="#method.parse_from_str"><code>parse_from_str</code></a>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(datetime, remainder) = NaiveDateTime::parse_and_remainder(
    <span class="string">"2015-02-18 23:16:09 trailing text"</span>,
    <span class="string">"%Y-%m-%d %H:%M:%S"</span>,
)
.unwrap();
<span class="macro">assert_eq!</span>(
    datetime,
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">2</span>, <span class="number">18</span>).unwrap().and_hms_opt(<span class="number">23</span>, <span class="number">16</span>, <span class="number">9</span>).unwrap()
);
<span class="macro">assert_eq!</span>(remainder, <span class="string">" trailing text"</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.date" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#330-332">Source</a><h4 class="code-header">pub const fn <a href="#method.date" class="fn">date</a>(&amp;self) -&gt; <a class="struct" href="struct.NaiveDate.html" title="struct chrono::NaiveDate">NaiveDate</a></h4></section></summary><div class="docblock"><p>Retrieves a date component.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::NaiveDate;

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.date(), NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>).unwrap());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.time" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#345-347">Source</a><h4 class="code-header">pub const fn <a href="#method.time" class="fn">time</a>(&amp;self) -&gt; <a class="struct" href="struct.NaiveTime.html" title="struct chrono::NaiveTime">NaiveTime</a></h4></section></summary><div class="docblock"><p>Retrieves a time component.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveTime};

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.time(), NaiveTime::from_hms_opt(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>).unwrap());</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#356-358">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp" class="fn">timestamp</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>.and_utc().timestamp()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of non-leap seconds since the midnight on January 1, 1970.</p>
<p>Note that this does <em>not</em> account for the timezone!
The true “UNIX timestamp” would count seconds since the midnight <em>UTC</em> on the epoch.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_millis" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#367-369">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_millis" class="fn">timestamp_millis</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>.and_utc().timestamp_millis()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of non-leap <em>milliseconds</em> since midnight on January 1, 1970.</p>
<p>Note that this does <em>not</em> account for the timezone!
The true “UNIX timestamp” would count seconds since the midnight <em>UTC</em> on the epoch.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_micros" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#378-380">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_micros" class="fn">timestamp_micros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>.and_utc().timestamp_micros()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of non-leap <em>microseconds</em> since midnight on January 1, 1970.</p>
<p>Note that this does <em>not</em> account for the timezone!
The true “UNIX timestamp” would count seconds since the midnight <em>UTC</em> on the epoch.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_nanos" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#398-400">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_nanos" class="fn">timestamp_nanos</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.31: use <code>.and_utc().timestamp_nanos_opt()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of non-leap <em>nanoseconds</em> since midnight on January 1, 1970.</p>
<p>Note that this does <em>not</em> account for the timezone!
The true “UNIX timestamp” would count seconds since the midnight <em>UTC</em> on the epoch.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>An <code>i64</code> with nanosecond precision can span a range of ~584 years. This function panics on
an out of range <code>NaiveDateTime</code>.</p>
<p>The dates that can be represented as nanoseconds are between 1677-09-21T00:12:43.145224192
and 2262-04-11T23:47:16.854775807.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_nanos_opt" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#417-419">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_nanos_opt" class="fn">timestamp_nanos_opt</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i64.html">i64</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>.and_utc().timestamp_nanos_opt()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of non-leap <em>nanoseconds</em> since midnight on January 1, 1970.</p>
<p>Note that this does <em>not</em> account for the timezone!
The true “UNIX timestamp” would count seconds since the midnight <em>UTC</em> on the epoch.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>An <code>i64</code> with nanosecond precision can span a range of ~584 years. This function returns
<code>None</code> on an out of range <code>NaiveDateTime</code>.</p>
<p>The dates that can be represented as nanoseconds are between 1677-09-21T00:12:43.145224192
and 2262-04-11T23:47:16.854775807.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_subsec_millis" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#428-430">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_subsec_millis" class="fn">timestamp_subsec_millis</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>.and_utc().timestamp_subsec_millis()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of milliseconds since the last whole non-leap second.</p>
<p>The return value ranges from 0 to 999,
or for <a href="./struct.NaiveTime.html#leap-second-handling">leap seconds</a>, to 1,999.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_subsec_micros" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#439-441">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_subsec_micros" class="fn">timestamp_subsec_micros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.35: use <code>.and_utc().timestamp_subsec_micros()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of microseconds since the last whole non-leap second.</p>
<p>The return value ranges from 0 to 999,999,
or for <a href="./struct.NaiveTime.html#leap-second-handling">leap seconds</a>, to 1,999,999.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timestamp_subsec_nanos" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#448-450">Source</a><h4 class="code-header">pub const fn <a href="#method.timestamp_subsec_nanos" class="fn">timestamp_subsec_nanos</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.4.36: use <code>.and_utc().timestamp_subsec_nanos()</code> instead</span></div></span></summary><div class="docblock"><p>Returns the number of nanoseconds since the last whole non-leap second.</p>
<p>The return value ranges from 0 to 999,999,999,
or for <a href="./struct.NaiveTime.html#leap-second-handling">leap seconds</a>, to 1,999,999,999.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add_signed" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#529-534">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_add_signed" class="fn">checked_add_signed</a>(self, rhs: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Adds given <code>TimeDelta</code> to the current date and time.</p>
<p>As a part of Chrono’s <a href="./struct.NaiveTime.html#leap-second-handling">leap second handling</a>,
the addition assumes that <strong>there is no leap second ever</strong>,
except when the <code>NaiveDateTime</code> itself represents a leap second
in which case the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>Returns <code>None</code> if the resulting date would be out of range.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, TimeDelta};

<span class="kw">let </span>from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();

<span class="kw">let </span>d = from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>);
<span class="kw">let </span>hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_add_signed(TimeDelta::zero()), <span class="prelude-val">Some</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)));
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_add_signed(TimeDelta::try_seconds(<span class="number">1</span>).unwrap()),
    <span class="prelude-val">Some</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>))
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_add_signed(TimeDelta::try_seconds(-<span class="number">1</span>).unwrap()),
    <span class="prelude-val">Some</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>))
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_add_signed(TimeDelta::try_seconds(<span class="number">3600 </span>+ <span class="number">60</span>).unwrap()),
    <span class="prelude-val">Some</span>(hms(<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>))
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_add_signed(TimeDelta::try_seconds(<span class="number">86_400</span>).unwrap()),
    <span class="prelude-val">Some</span>(from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">9</span>).and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap())
);

<span class="kw">let </span>hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();
<span class="macro">assert_eq!</span>(
    hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">980</span>).checked_add_signed(TimeDelta::try_milliseconds(<span class="number">450</span>).unwrap()),
    <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">430</span>))
);</code></pre></div>
<p>Overflow returns <code>None</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_add_signed(TimeDelta::try_days(<span class="number">1_000_000_000</span>).unwrap()), <span class="prelude-val">None</span>);</code></pre></div>
<p>Leap seconds are handled,
but the addition assumes that it is the only leap second happened.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>leap = hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>);
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::zero()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>)));
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::try_milliseconds(-<span class="number">500</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">800</span>)));
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_800</span>)));
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::try_milliseconds(<span class="number">800</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">100</span>)));
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::try_seconds(<span class="number">10</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">300</span>)));
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::try_seconds(-<span class="number">10</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">300</span>)));
<span class="macro">assert_eq!</span>(leap.checked_add_signed(TimeDelta::try_days(<span class="number">1</span>).unwrap()),
           <span class="prelude-val">Some</span>(from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">9</span>).and_hms_milli_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">300</span>).unwrap()));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add_months" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#568-570">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_add_months" class="fn">checked_add_months</a>(self, rhs: <a class="struct" href="struct.Months.html" title="struct chrono::Months">Months</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Adds given <code>Months</code> to the current date and time.</p>
<p>Uses the last day of the month if the day does not exist in the resulting month.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>Returns <code>None</code> if the resulting date would be out of range.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Months, NaiveDate};

<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>)
        .unwrap()
        .and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)
        .unwrap()
        .checked_add_months(Months::new(<span class="number">1</span>)),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">2</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap())
);

<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>)
        .unwrap()
        .and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)
        .unwrap()
        .checked_add_months(Months::new(core::i32::MAX <span class="kw">as </span>u32 + <span class="number">1</span>)),
    <span class="prelude-val">None
</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add_offset" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#578-586">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_add_offset" class="fn">checked_add_offset</a>(self, rhs: <a class="struct" href="struct.FixedOffset.html" title="struct chrono::FixedOffset">FixedOffset</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Adds given <code>FixedOffset</code> to the current datetime.
Returns <code>None</code> if the result would be outside the valid range for <a href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime"><code>NaiveDateTime</code></a>.</p>
<p>This method is similar to <a href="#method.checked_add_offset"><code>checked_add_signed</code></a>, but preserves
leap seconds.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub_offset" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#593-601">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_sub_offset" class="fn">checked_sub_offset</a>(self, rhs: <a class="struct" href="struct.FixedOffset.html" title="struct chrono::FixedOffset">FixedOffset</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Subtracts given <code>FixedOffset</code> from the current datetime.
Returns <code>None</code> if the result would be outside the valid range for <a href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime"><code>NaiveDateTime</code></a>.</p>
<p>This method is similar to <a href="#method.checked_sub_signed"><code>checked_sub_signed</code></a>, but preserves
leap seconds.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub_signed" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#709-714">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_sub_signed" class="fn">checked_sub_signed</a>(self, rhs: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Subtracts given <code>TimeDelta</code> from the current date and time.</p>
<p>As a part of Chrono’s <a href="./struct.NaiveTime.html#leap-second-handling">leap second handling</a>,
the subtraction assumes that <strong>there is no leap second ever</strong>,
except when the <code>NaiveDateTime</code> itself represents a leap second
in which case the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h5 id="errors-7"><a class="doc-anchor" href="#errors-7">§</a>Errors</h5>
<p>Returns <code>None</code> if the resulting date would be out of range.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, TimeDelta};

<span class="kw">let </span>from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();

<span class="kw">let </span>d = from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>);
<span class="kw">let </span>hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_sub_signed(TimeDelta::zero()), <span class="prelude-val">Some</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)));
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_sub_signed(TimeDelta::try_seconds(<span class="number">1</span>).unwrap()),
    <span class="prelude-val">Some</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>))
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_sub_signed(TimeDelta::try_seconds(-<span class="number">1</span>).unwrap()),
    <span class="prelude-val">Some</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>))
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_sub_signed(TimeDelta::try_seconds(<span class="number">3600 </span>+ <span class="number">60</span>).unwrap()),
    <span class="prelude-val">Some</span>(hms(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>))
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_sub_signed(TimeDelta::try_seconds(<span class="number">86_400</span>).unwrap()),
    <span class="prelude-val">Some</span>(from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">7</span>).and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap())
);

<span class="kw">let </span>hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();
<span class="macro">assert_eq!</span>(
    hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">450</span>).checked_sub_signed(TimeDelta::try_milliseconds(<span class="number">670</span>).unwrap()),
    <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">780</span>))
);</code></pre></div>
<p>Overflow returns <code>None</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).checked_sub_signed(TimeDelta::try_days(<span class="number">1_000_000_000</span>).unwrap()), <span class="prelude-val">None</span>);</code></pre></div>
<p>Leap seconds are handled,
but the subtraction assumes that it is the only leap second happened.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>leap = hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>);
<span class="macro">assert_eq!</span>(leap.checked_sub_signed(TimeDelta::zero()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>)));
<span class="macro">assert_eq!</span>(leap.checked_sub_signed(TimeDelta::try_milliseconds(<span class="number">200</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_100</span>)));
<span class="macro">assert_eq!</span>(leap.checked_sub_signed(TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">800</span>)));
<span class="macro">assert_eq!</span>(leap.checked_sub_signed(TimeDelta::try_seconds(<span class="number">60</span>).unwrap()),
           <span class="prelude-val">Some</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">300</span>)));
<span class="macro">assert_eq!</span>(leap.checked_sub_signed(TimeDelta::try_days(<span class="number">1</span>).unwrap()),
           <span class="prelude-val">Some</span>(from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">7</span>).and_hms_milli_opt(<span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">300</span>).unwrap()));</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub_months" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#748-750">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_sub_months" class="fn">checked_sub_months</a>(self, rhs: <a class="struct" href="struct.Months.html" title="struct chrono::Months">Months</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Subtracts given <code>Months</code> from the current date and time.</p>
<p>Uses the last day of the month if the day does not exist in the resulting month.</p>
<h5 id="errors-8"><a class="doc-anchor" href="#errors-8">§</a>Errors</h5>
<p>Returns <code>None</code> if the resulting date would be out of range.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Months, NaiveDate};

<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>)
        .unwrap()
        .and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)
        .unwrap()
        .checked_sub_months(Months::new(<span class="number">1</span>)),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2013</span>, <span class="number">12</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap())
);

<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>)
        .unwrap()
        .and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)
        .unwrap()
        .checked_sub_months(Months::new(core::i32::MAX <span class="kw">as </span>u32 + <span class="number">1</span>)),
    <span class="prelude-val">None
</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add_days" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#756-758">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_add_days" class="fn">checked_add_days</a>(self, days: <a class="struct" href="struct.Days.html" title="struct chrono::Days">Days</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Add a duration in <a href="struct.Days.html" title="struct chrono::Days"><code>Days</code></a> to the date part of the <code>NaiveDateTime</code></p>
<p>Returns <code>None</code> if the resulting date would be out of range.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub_days" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#764-766">Source</a><h4 class="code-header">pub const fn <a href="#method.checked_sub_days" class="fn">checked_sub_days</a>(self, days: <a class="struct" href="struct.Days.html" title="struct chrono::Days">Days</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Subtract a duration in <a href="struct.Days.html" title="struct chrono::Days"><code>Days</code></a> from the date part of the <code>NaiveDateTime</code></p>
<p>Returns <code>None</code> if the resulting date would be out of range.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.signed_duration_since" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#818-825">Source</a><h4 class="code-header">pub const fn <a href="#method.signed_duration_since" class="fn">signed_duration_since</a>(self, rhs: <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>) -&gt; <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a></h4></section></summary><div class="docblock"><p>Subtracts another <code>NaiveDateTime</code> from the current date and time.
This does not overflow or underflow at all.</p>
<p>As a part of Chrono’s <a href="./struct.NaiveTime.html#leap-second-handling">leap second handling</a>,
the subtraction assumes that <strong>there is no leap second ever</strong>,
except when any of the <code>NaiveDateTime</code>s themselves represents a leap second
in which case the assumption becomes that
<strong>there are exactly one (or two) leap second(s) ever</strong>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, TimeDelta};

<span class="kw">let </span>from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();

<span class="kw">let </span>d = from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(
    d.and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap().signed_duration_since(d.and_hms_opt(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>).unwrap()),
    TimeDelta::try_seconds(<span class="number">3600 </span>+ <span class="number">60 </span>+ <span class="number">1</span>).unwrap()
);

<span class="comment">// July 8 is 190th day in the year 2016
</span><span class="kw">let </span>d0 = from_ymd(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    d.and_hms_milli_opt(<span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">500</span>)
        .unwrap()
        .signed_duration_since(d0.and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap()),
    TimeDelta::try_seconds(<span class="number">189 </span>* <span class="number">86_400 </span>+ <span class="number">7 </span>* <span class="number">60 </span>+ <span class="number">6</span>).unwrap()
        + TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()
);</code></pre></div>
<p>Leap seconds are handled, but the subtraction assumes that
there were no other leap seconds happened.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>leap = from_ymd(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>).and_hms_milli_opt(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">1_500</span>).unwrap();
<span class="macro">assert_eq!</span>(
    leap.signed_duration_since(from_ymd(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>).and_hms_opt(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap()),
    TimeDelta::try_seconds(<span class="number">3600</span>).unwrap() + TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    from_ymd(<span class="number">2015</span>, <span class="number">7</span>, <span class="number">1</span>).and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap().signed_duration_since(leap),
    TimeDelta::try_seconds(<span class="number">3600</span>).unwrap() - TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.format_with_items" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#857-863">Source</a><h4 class="code-header">pub fn <a href="#method.format_with_items" class="fn">format_with_items</a>&lt;'a, I, B&gt;(&amp;self, items: I) -&gt; <a class="struct" href="format/struct.DelayedFormat.html" title="struct chrono::format::DelayedFormat">DelayedFormat</a>&lt;I&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = B&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    B: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="enum" href="format/enum.Item.html" title="enum chrono::format::Item">Item</a>&lt;'a&gt;&gt;,</div></h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>alloc</code></strong> only.</div></span></summary><div class="docblock"><p>Formats the combined date and time with the specified formatting items.
Otherwise it is the same as the ordinary <a href="#method.format"><code>format</code></a> method.</p>
<p>The <code>Iterator</code> of items should be <code>Clone</code>able,
since the resulting <code>DelayedFormat</code> value may be formatted multiple times.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::format::strftime::StrftimeItems;
<span class="kw">use </span>chrono::NaiveDate;

<span class="kw">let </span>fmt = StrftimeItems::new(<span class="string">"%Y-%m-%d %H:%M:%S"</span>);
<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">5</span>).unwrap().and_hms_opt(<span class="number">23</span>, <span class="number">56</span>, <span class="number">4</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.format_with_items(fmt.clone()).to_string(), <span class="string">"2015-09-05 23:56:04"</span>);
<span class="macro">assert_eq!</span>(dt.format(<span class="string">"%Y-%m-%d %H:%M:%S"</span>).to_string(), <span class="string">"2015-09-05 23:56:04"</span>);</code></pre></div>
<p>The resulting <code>DelayedFormat</code> can be formatted directly via the <code>Display</code> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, dt.format_with_items(fmt)), <span class="string">"2015-09-05 23:56:04"</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.format" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#900-902">Source</a><h4 class="code-header">pub fn <a href="#method.format" class="fn">format</a>&lt;'a&gt;(&amp;self, fmt: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="format/struct.DelayedFormat.html" title="struct chrono::format::DelayedFormat">DelayedFormat</a>&lt;<a class="struct" href="format/strftime/struct.StrftimeItems.html" title="struct chrono::format::strftime::StrftimeItems">StrftimeItems</a>&lt;'a&gt;&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>alloc</code></strong> only.</div></span></summary><div class="docblock"><p>Formats the combined date and time with the specified format string.
See the <a href="format/strftime/index.html" title="mod chrono::format::strftime"><code>format::strftime</code> module</a>
on the supported escape sequences.</p>
<p>This returns a <code>DelayedFormat</code>,
which gets converted to a string only when actual formatting happens.
You may use the <code>to_string</code> method to get a <code>String</code>,
or just feed it into <code>print!</code> and other formatting macros.
(In this way it avoids the redundant memory allocation.)</p>
<p>A wrong format string does <em>not</em> issue an error immediately.
Rather, converting or formatting the <code>DelayedFormat</code> fails.
You are recommended to immediately use <code>DelayedFormat</code> for this reason.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::NaiveDate;

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">5</span>).unwrap().and_hms_opt(<span class="number">23</span>, <span class="number">56</span>, <span class="number">4</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.format(<span class="string">"%Y-%m-%d %H:%M:%S"</span>).to_string(), <span class="string">"2015-09-05 23:56:04"</span>);
<span class="macro">assert_eq!</span>(dt.format(<span class="string">"around %l %p on %b %-d"</span>).to_string(), <span class="string">"around 11 PM on Sep 5"</span>);</code></pre></div>
<p>The resulting <code>DelayedFormat</code> can be formatted directly via the <code>Display</code> trait.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, dt.format(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)), <span class="string">"2015-09-05 23:56:04"</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, dt.format(<span class="string">"around %l %p on %b %-d"</span>)), <span class="string">"around 11 PM on Sep 5"</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.and_local_timezone" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#922-924">Source</a><h4 class="code-header">pub fn <a href="#method.and_local_timezone" class="fn">and_local_timezone</a>&lt;Tz: <a class="trait" href="trait.TimeZone.html" title="trait chrono::TimeZone">TimeZone</a>&gt;(
    &amp;self,
    tz: Tz,
) -&gt; <a class="type" href="offset/type.MappedLocalTime.html" title="type chrono::offset::MappedLocalTime">MappedLocalTime</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct chrono::DateTime">DateTime</a>&lt;Tz&gt;&gt;</h4></section></summary><div class="docblock"><p>Converts the <code>NaiveDateTime</code> into a timezone-aware <code>DateTime&lt;Tz&gt;</code> with the provided
time zone.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{FixedOffset, NaiveDate};
<span class="kw">let </span>hour = <span class="number">3600</span>;
<span class="kw">let </span>tz = FixedOffset::east_opt(<span class="number">5 </span>* hour).unwrap();
<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">5</span>)
    .unwrap()
    .and_hms_opt(<span class="number">23</span>, <span class="number">56</span>, <span class="number">4</span>)
    .unwrap()
    .and_local_timezone(tz)
    .unwrap();
<span class="macro">assert_eq!</span>(dt.timezone(), tz);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.and_utc" class="method"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#937-939">Source</a><h4 class="code-header">pub const fn <a href="#method.and_utc" class="fn">and_utc</a>(&amp;self) -&gt; <a class="struct" href="struct.DateTime.html" title="struct chrono::DateTime">DateTime</a>&lt;<a class="struct" href="struct.Utc.html" title="struct chrono::Utc">Utc</a>&gt;</h4></section></summary><div class="docblock"><p>Converts the <code>NaiveDateTime</code> into the timezone-aware <code>DateTime&lt;Utc&gt;</code>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, Utc};
<span class="kw">let </span>dt =
    NaiveDate::from_ymd_opt(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">19</span>, <span class="number">32</span>, <span class="number">33</span>).unwrap().and_utc();
<span class="macro">assert_eq!</span>(dt.timezone(), Utc);</code></pre></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDays%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2002-2008">Source</a><a href="#impl-Add%3CDays%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Days.html" title="struct chrono::Days">Days</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add <code>Days</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><h4 id="panics-14"><a class="doc-anchor" href="#panics-14">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <code>checked_add_days</code> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-9" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2003">Source</a><a href="#associatedtype.Output-9" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-4" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2005-2007">Source</a><a href="#method.add-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, days: <a class="struct" href="struct.Days.html" title="struct chrono::Days">Days</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" title="type core::ops::arith::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1649-1658">Source</a><a href="#impl-Add%3CDuration%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add <code>std::time::Duration</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s [leap second handling], the addition assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap  second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_add_signed" title="method chrono::NaiveDateTime::checked_add_signed"><code>NaiveDateTime::checked_add_signed</code></a> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1650">Source</a><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1653-1657">Source</a><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CFixedOffset%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1700-1707">Source</a><a href="#impl-Add%3CFixedOffset%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.FixedOffset.html" title="struct chrono::FixedOffset">FixedOffset</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add <code>FixedOffset</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><h4 id="panics-6"><a class="doc-anchor" href="#panics-6">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <code>checked_add_offset</code> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1701">Source</a><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1704-1706">Source</a><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.FixedOffset.html" title="struct chrono::FixedOffset">FixedOffset</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CMonths%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1754-1760">Source</a><a href="#impl-Add%3CMonths%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.Months.html" title="struct chrono::Months">Months</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add <code>Months</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>The result will be clamped to valid days in the resulting month, see <code>checked_add_months</code> for
details.</p>
<h4 id="panics-7"><a class="doc-anchor" href="#panics-7">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <code>checked_add_months</code> to get an <code>Option</code> instead.</p>
<h4 id="example-40"><a class="doc-anchor" href="#example-40">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Months, NaiveDate};

<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap() + Months::new(<span class="number">1</span>),
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">2</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>).unwrap()
        + Months::new(<span class="number">11</span>),
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">12</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>).unwrap()
        + Months::new(<span class="number">12</span>),
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>).unwrap()
        + Months::new(<span class="number">13</span>),
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">2</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">31</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>).unwrap()
        + Months::new(<span class="number">1</span>),
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">2</span>, <span class="number">28</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">31</span>).unwrap().and_hms_opt(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap()
        + Months::new(<span class="number">1</span>),
    NaiveDate::from_ymd_opt(<span class="number">2020</span>, <span class="number">2</span>, <span class="number">29</span>).unwrap().and_hms_opt(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap()
);</code></pre></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1755">Source</a><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-3" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1757-1759">Source</a><a href="#method.add-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.Months.html" title="struct chrono::Months">Months</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" title="type core::ops::arith::Add::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CTimeDelta%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1630-1637">Source</a><a href="#impl-Add%3CTimeDelta%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add <code>TimeDelta</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s <a href="struct.NaiveTime.html#leap-second-handling" title="struct chrono::NaiveTime">leap second handling</a>, the addition assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap  second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_add_signed" title="method chrono::NaiveDateTime::checked_add_signed"><code>NaiveDateTime::checked_add_signed</code></a> to get an <code>Option</code> instead.</p>
<h4 id="example-39"><a class="doc-anchor" href="#example-39">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, TimeDelta};

<span class="kw">let </span>from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();

<span class="kw">let </span>d = from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>);
<span class="kw">let </span>hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) + TimeDelta::zero(), hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>));
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) + TimeDelta::try_seconds(<span class="number">1</span>).unwrap(), hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) + TimeDelta::try_seconds(-<span class="number">1</span>).unwrap(), hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>));
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) + TimeDelta::try_seconds(<span class="number">3600 </span>+ <span class="number">60</span>).unwrap(), hms(<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>));
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) + TimeDelta::try_seconds(<span class="number">86_400</span>).unwrap(),
    from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">9</span>).and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) + TimeDelta::try_days(<span class="number">365</span>).unwrap(),
    from_ymd(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">8</span>).and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap()
);

<span class="kw">let </span>hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();
<span class="macro">assert_eq!</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">980</span>) + TimeDelta::try_milliseconds(<span class="number">450</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">430</span>));</code></pre></div>
<p>Leap seconds are handled,
but the addition assumes that it is the only leap second happened.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>leap = hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>);
<span class="macro">assert_eq!</span>(leap + TimeDelta::zero(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>));
<span class="macro">assert_eq!</span>(leap + TimeDelta::try_milliseconds(-<span class="number">500</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">800</span>));
<span class="macro">assert_eq!</span>(leap + TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_800</span>));
<span class="macro">assert_eq!</span>(leap + TimeDelta::try_milliseconds(<span class="number">800</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">100</span>));
<span class="macro">assert_eq!</span>(leap + TimeDelta::try_seconds(<span class="number">10</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">300</span>));
<span class="macro">assert_eq!</span>(leap + TimeDelta::try_seconds(-<span class="number">10</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">300</span>));
<span class="macro">assert_eq!</span>(leap + TimeDelta::try_days(<span class="number">1</span>).unwrap(),
           from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">9</span>).and_hms_milli_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">300</span>).unwrap());</code></pre></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1631">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1634-1636">Source</a><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1687-1692">Source</a><a href="#impl-AddAssign%3CDuration%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add-assign <code>std::time::Duration</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s [leap second handling], the addition assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap  second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_add_signed" title="method chrono::NaiveDateTime::checked_add_signed"><code>NaiveDateTime::checked_add_signed</code></a> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1689-1691">Source</a><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CTimeDelta%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1670-1675">Source</a><a href="#impl-AddAssign%3CTimeDelta%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Add-assign <code>TimeDelta</code> to <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s [leap second handling], the addition assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap  second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_add_signed" title="method chrono::NaiveDateTime::checked_add_signed"><code>NaiveDateTime::checked_add_signed</code></a> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1672-1674">Source</a><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-Clone-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Datelike-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#972-1359">Source</a><a href="#impl-Datelike-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Datelike.html" title="trait chrono::Datelike">Datelike</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.year" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#987-989">Source</a><a href="#method.year" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.year" class="fn">year</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the year number in the <a href="./struct.NaiveDate.html#calendar-date">calendar date</a>.</p>
<p>See also the <a href="./struct.NaiveDate.html#method.year"><code>NaiveDate::year</code></a> method.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.year(), <span class="number">2015</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.month" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1007-1009">Source</a><a href="#method.month" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.month" class="fn">month</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the month number starting from 1.</p>
<p>The return value ranges from 1 to 12.</p>
<p>See also the <a href="./struct.NaiveDate.html#method.month"><code>NaiveDate::month</code></a> method.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.month(), <span class="number">9</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.month0" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1027-1029">Source</a><a href="#method.month0" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.month0" class="fn">month0</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the month number starting from 0.</p>
<p>The return value ranges from 0 to 11.</p>
<p>See also the <a href="struct.NaiveDate.html#method.month0" title="method chrono::NaiveDate::month0"><code>NaiveDate::month0</code></a> method.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.month0(), <span class="number">8</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1047-1049">Source</a><a href="#method.day" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.day" class="fn">day</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the day of month starting from 1.</p>
<p>The return value ranges from 1 to 31. (The last day of month differs by months.)</p>
<p>See also the <a href="./struct.NaiveDate.html#method.day"><code>NaiveDate::day</code></a> method.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.day(), <span class="number">25</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.day0" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1067-1069">Source</a><a href="#method.day0" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.day0" class="fn">day0</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the day of month starting from 0.</p>
<p>The return value ranges from 0 to 30. (The last day of month differs by months.)</p>
<p>See also the <a href="struct.NaiveDate.html#method.day0" title="method chrono::NaiveDate::day0"><code>NaiveDate::day0</code></a> method.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.day0(), <span class="number">24</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ordinal" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1087-1089">Source</a><a href="#method.ordinal" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.ordinal" class="fn">ordinal</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the day of year starting from 1.</p>
<p>The return value ranges from 1 to 366. (The last day of year differs by years.)</p>
<p>See also the <a href="./struct.NaiveDate.html#method.ordinal"><code>NaiveDate::ordinal</code></a> method.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.ordinal(), <span class="number">268</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.ordinal0" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1107-1109">Source</a><a href="#method.ordinal0" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.ordinal0" class="fn">ordinal0</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the day of year starting from 0.</p>
<p>The return value ranges from 0 to 365. (The last day of year differs by years.)</p>
<p>See also the <a href="struct.NaiveDate.html#method.ordinal0" title="method chrono::NaiveDate::ordinal0"><code>NaiveDate::ordinal0</code></a> method.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.ordinal0(), <span class="number">267</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.weekday" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1125-1127">Source</a><a href="#method.weekday" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.weekday" class="fn">weekday</a>(&amp;self) -&gt; <a class="enum" href="enum.Weekday.html" title="enum chrono::Weekday">Weekday</a></h4></section></summary><div class="docblock"><p>Returns the day of week.</p>
<p>See also the <a href="./struct.NaiveDate.html#method.weekday"><code>NaiveDate::weekday</code></a> method.</p>
<h5 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime, Weekday};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.weekday(), Weekday::Fri);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_year" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1162-1164">Source</a><a href="#method.with_year" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_year" class="fn">with_year</a>(&amp;self, year: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the year number changed, while keeping the same month and
day.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_year" title="method chrono::NaiveDate::with_year"><code>NaiveDate::with_year</code></a> method.</p>
<h5 id="errors-9"><a class="doc-anchor" href="#errors-9">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (February 29 in a non-leap year).</li>
<li>The year is out of range for a <code>NaiveDate</code>.</li>
</ul>
<h5 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_year(<span class="number">2016</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(
    dt.with_year(-<span class="number">308</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(-<span class="number">308</span>, <span class="number">9</span>, <span class="number">25</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_month" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1193-1195">Source</a><a href="#method.with_month" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_month" class="fn">with_month</a>(&amp;self, month: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the month number (starting from 1) changed.</p>
<p>Don’t combine multiple <code>Datelike::with_*</code> methods. The intermediate value may not exist.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_month" title="method chrono::NaiveDate::with_month"><code>NaiveDate::with_month</code></a> method.</p>
<h5 id="errors-10"><a class="doc-anchor" href="#errors-10">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (for example <code>month(4)</code> when day of the month is 31).</li>
<li>The value for <code>month</code> is invalid.</li>
</ul>
<h5 id="example-25"><a class="doc-anchor" href="#example-25">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_month(<span class="number">10</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(dt.with_month(<span class="number">13</span>), <span class="prelude-val">None</span>); <span class="comment">// No month 13
</span><span class="macro">assert_eq!</span>(dt.with_month(<span class="number">2</span>), <span class="prelude-val">None</span>); <span class="comment">// No February 30</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_month0" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1222-1224">Source</a><a href="#method.with_month0" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_month0" class="fn">with_month0</a>(&amp;self, month0: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the month number (starting from 0) changed.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_month0" title="method chrono::NaiveDate::with_month0"><code>NaiveDate::with_month0</code></a> method.</p>
<h5 id="errors-11"><a class="doc-anchor" href="#errors-11">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (for example <code>month0(3)</code> when day of the month is 31).</li>
<li>The value for <code>month0</code> is invalid.</li>
</ul>
<h5 id="example-26"><a class="doc-anchor" href="#example-26">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_month0(<span class="number">9</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">10</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(dt.with_month0(<span class="number">12</span>), <span class="prelude-val">None</span>); <span class="comment">// No month 13
</span><span class="macro">assert_eq!</span>(dt.with_month0(<span class="number">1</span>), <span class="prelude-val">None</span>); <span class="comment">// No February 30</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_day" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1250-1252">Source</a><a href="#method.with_day" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_day" class="fn">with_day</a>(&amp;self, day: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the day of month (starting from 1) changed.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_day" title="method chrono::NaiveDate::with_day"><code>NaiveDate::with_day</code></a> method.</p>
<h5 id="errors-12"><a class="doc-anchor" href="#errors-12">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (for example <code>day(31)</code> in April).</li>
<li>The value for <code>day</code> is invalid.</li>
</ul>
<h5 id="example-27"><a class="doc-anchor" href="#example-27">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_day(<span class="number">30</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(dt.with_day(<span class="number">31</span>), <span class="prelude-val">None</span>); <span class="comment">// no September 31</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_day0" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1278-1280">Source</a><a href="#method.with_day0" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_day0" class="fn">with_day0</a>(&amp;self, day0: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the day of month (starting from 0) changed.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_day0" title="method chrono::NaiveDate::with_day0"><code>NaiveDate::with_day0</code></a> method.</p>
<h5 id="errors-13"><a class="doc-anchor" href="#errors-13">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (for example <code>day(30)</code> in April).</li>
<li>The value for <code>day0</code> is invalid.</li>
</ul>
<h5 id="example-28"><a class="doc-anchor" href="#example-28">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_day0(<span class="number">29</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">30</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(dt.with_day0(<span class="number">30</span>), <span class="prelude-val">None</span>); <span class="comment">// no September 31</span></code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_ordinal" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1317-1319">Source</a><a href="#method.with_ordinal" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_ordinal" class="fn">with_ordinal</a>(&amp;self, ordinal: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the day of year (starting from 1) changed.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_ordinal" title="method chrono::NaiveDate::with_ordinal"><code>NaiveDate::with_ordinal</code></a> method.</p>
<h5 id="errors-14"><a class="doc-anchor" href="#errors-14">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (<code>with_ordinal(366)</code> in a non-leap year).</li>
<li>The value for <code>ordinal</code> is invalid.</li>
</ul>
<h5 id="example-29"><a class="doc-anchor" href="#example-29">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_ordinal(<span class="number">60</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">3</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(dt.with_ordinal(<span class="number">366</span>), <span class="prelude-val">None</span>); <span class="comment">// 2015 had only 365 days

</span><span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_ordinal(<span class="number">60</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">2</span>, <span class="number">29</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(
    dt.with_ordinal(<span class="number">366</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">12</span>, <span class="number">31</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_ordinal0" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1356-1358">Source</a><a href="#method.with_ordinal0" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.with_ordinal0" class="fn">with_ordinal0</a>(&amp;self, ordinal0: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the day of year (starting from 0) changed.</p>
<p>See also the <a href="struct.NaiveDate.html#method.with_ordinal0" title="method chrono::NaiveDate::with_ordinal0"><code>NaiveDate::with_ordinal0</code></a> method.</p>
<h5 id="errors-15"><a class="doc-anchor" href="#errors-15">§</a>Errors</h5>
<p>Returns <code>None</code> if:</p>
<ul>
<li>The resulting date does not exist (<code>with_ordinal0(365)</code> in a non-leap year).</li>
<li>The value for <code>ordinal0</code> is invalid.</li>
</ul>
<h5 id="example-30"><a class="doc-anchor" href="#example-30">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Datelike, NaiveDate, NaiveDateTime};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_ordinal0(<span class="number">59</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">3</span>, <span class="number">1</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(dt.with_ordinal0(<span class="number">365</span>), <span class="prelude-val">None</span>); <span class="comment">// 2015 had only 365 days

</span><span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_ordinal0(<span class="number">59</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">2</span>, <span class="number">29</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);
<span class="macro">assert_eq!</span>(
    dt.with_ordinal0(<span class="number">365</span>),
    <span class="prelude-val">Some</span>(NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">12</span>, <span class="number">31</span>).unwrap().and_hms_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>).unwrap())
);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.iso_week" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1130-1132">Source</a><a href="#method.iso_week" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#tymethod.iso_week" class="fn">iso_week</a>(&amp;self) -&gt; <a class="struct" href="naive/struct.IsoWeek.html" title="struct chrono::naive::IsoWeek">IsoWeek</a></h4></section></summary><div class='docblock'>Returns the ISO week.</div></details><details class="toggle method-toggle" open><summary><section id="method.year_ce" class="method trait-impl"><a class="src rightside" href="../src/chrono/traits.rs.html#38-41">Source</a><a href="#method.year_ce" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#method.year_ce" class="fn">year_ce</a>(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>)</h4></section></summary><div class='docblock'>Returns the absolute year number starting from 1 with a boolean flag,
which is false when the year predates the epoch (BCE/BC) and true otherwise (CE/AD).</div></details><details class="toggle method-toggle" open><summary><section id="method.quarter" class="method trait-impl"><a class="src rightside" href="../src/chrono/traits.rs.html#47-49">Source</a><a href="#method.quarter" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#method.quarter" class="fn">quarter</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class='docblock'>Returns the quarter number starting from 1. <a href="trait.Datelike.html#method.quarter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.num_days_from_ce" class="method trait-impl"><a class="src rightside" href="../src/chrono/traits.rs.html#252-267">Source</a><a href="#method.num_days_from_ce" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#method.num_days_from_ce" class="fn">num_days_from_ce</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></h4></section></summary><div class='docblock'>Counts the days in the proleptic Gregorian calendar, with January 1, Year 1 (CE) as day 1. <a href="trait.Datelike.html#method.num_days_from_ce">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.num_days_in_month" class="method trait-impl"><a class="src rightside" href="../src/chrono/traits.rs.html#270-279">Source</a><a href="#method.num_days_in_month" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Datelike.html#method.num_days_in_month" class="fn">num_days_in_month</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></h4></section></summary><div class='docblock'>Get the length in days of the month</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2052-2058">Source</a><a href="#impl-Debug-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>The <code>Debug</code> output of the naive date and time <code>dt</code> is the same as
<a href="format/strftime/index.html" title="mod chrono::format::strftime"><code>dt.format("%Y-%m-%dT%H:%M:%S%.f")</code></a>.</p>
</div></section></summary><div class="docblock"><p>The string printed can be readily parsed via the <code>parse</code> method on <code>str</code>.</p>
<p>It should be noted that, for leap seconds not on the minute boundary,
it may print a representation not distinguishable from non-leap seconds.
This doesn’t matter in practice, since such leap seconds never happened.
(By the time of the first leap second on 1972-06-30,
every time zone offset around the world has standardized to the 5-minute alignment.)</p>
<h4 id="example-44"><a class="doc-anchor" href="#example-44">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::NaiveDate;

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">11</span>, <span class="number">15</span>).unwrap().and_hms_opt(<span class="number">7</span>, <span class="number">39</span>, <span class="number">24</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{:?}"</span>, dt), <span class="string">"2016-11-15T07:39:24"</span>);</code></pre></div>
<p>Leap seconds may also be used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>dt =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>).unwrap().and_hms_milli_opt(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">1_500</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{:?}"</span>, dt), <span class="string">"2015-06-30T23:59:60.500"</span>);</code></pre></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2053-2057">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2146-2150">Source</a><a href="#impl-Default-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>The default value for a NaiveDateTime is 1st of January 1970 at 00:00:00.</p>
</div></section></summary><div class="docblock"><p>Note that while this may look like the UNIX epoch, it is missing the
time zone. The actual UNIX epoch cannot be expressed by this type,
however it is available as <a href="struct.DateTime.html#associatedconstant.UNIX_EPOCH" title="associated constant chrono::DateTime::UNIX_EPOCH"><code>DateTime::UNIX_EPOCH</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2147-2149">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2086-2092">Source</a><a href="#impl-Display-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>The <code>Display</code> output of the naive date and time <code>dt</code> is the same as
<a href="format/strftime/index.html" title="mod chrono::format::strftime"><code>dt.format("%Y-%m-%d %H:%M:%S%.f")</code></a>.</p>
</div></section></summary><div class="docblock"><p>It should be noted that, for leap seconds not on the minute boundary,
it may print a representation not distinguishable from non-leap seconds.
This doesn’t matter in practice, since such leap seconds never happened.
(By the time of the first leap second on 1972-06-30,
every time zone offset around the world has standardized to the 5-minute alignment.)</p>
<h4 id="example-45"><a class="doc-anchor" href="#example-45">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::NaiveDate;

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">11</span>, <span class="number">15</span>).unwrap().and_hms_opt(<span class="number">7</span>, <span class="number">39</span>, <span class="number">24</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, dt), <span class="string">"2016-11-15 07:39:24"</span>);</code></pre></div>
<p>Leap seconds may also be used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>dt =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>).unwrap().and_hms_milli_opt(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">1_500</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{}"</span>, dt), <span class="string">"2015-06-30 23:59:60.500"</span>);</code></pre></div></div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2087-2091">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DurationRound-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/round.rs.html#204-218">Source</a><a href="#impl-DurationRound-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="round/trait.DurationRound.html" title="trait chrono::round::DurationRound">DurationRound</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err-1" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/round.rs.html#205">Source</a><a href="#associatedtype.Err-1" class="anchor">§</a><h4 class="code-header">type <a href="round/trait.DurationRound.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="enum" href="round/enum.RoundingError.html" title="enum chrono::round::RoundingError">RoundingError</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>std</code></strong> only.</div></span><div class='docblock'>Error that can occur in rounding or truncating</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_round" class="method trait-impl"><a class="src rightside" href="../src/chrono/round.rs.html#207-209">Source</a><a href="#method.duration_round" class="anchor">§</a><h4 class="code-header">fn <a href="round/trait.DurationRound.html#tymethod.duration_round" class="fn">duration_round</a>(self, duration: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="round/trait.DurationRound.html#associatedtype.Err" title="type chrono::round::DurationRound::Err">Err</a>&gt;</h4></section></summary><div class='docblock'>Return a copy rounded by TimeDelta. <a href="round/trait.DurationRound.html#tymethod.duration_round">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.duration_trunc" class="method trait-impl"><a class="src rightside" href="../src/chrono/round.rs.html#211-213">Source</a><a href="#method.duration_trunc" class="anchor">§</a><h4 class="code-header">fn <a href="round/trait.DurationRound.html#tymethod.duration_trunc" class="fn">duration_trunc</a>(self, duration: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="round/trait.DurationRound.html#associatedtype.Err" title="type chrono::round::DurationRound::Err">Err</a>&gt;</h4></section></summary><div class='docblock'>Return a copy truncated by TimeDelta. <a href="round/trait.DurationRound.html#tymethod.duration_trunc">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.duration_round_up" class="method trait-impl"><a class="src rightside" href="../src/chrono/round.rs.html#215-217">Source</a><a href="#method.duration_round_up" class="anchor">§</a><h4 class="code-header">fn <a href="round/trait.DurationRound.html#tymethod.duration_round_up" class="fn">duration_round_up</a>(self, duration: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="round/trait.DurationRound.html#associatedtype.Err" title="type chrono::round::DurationRound::Err">Err</a>&gt;</h4></section></summary><div class='docblock'>Return a copy rounded <strong>up</strong> by TimeDelta. <a href="round/trait.DurationRound.html#tymethod.duration_round_up">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CNaiveDate%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#956-970">Source</a><a href="#impl-From%3CNaiveDate%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.NaiveDate.html" title="struct chrono::NaiveDate">NaiveDate</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#967-969">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(date: <a class="struct" href="struct.NaiveDate.html" title="struct chrono::NaiveDate">NaiveDate</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts a <code>NaiveDate</code> to a <code>NaiveDateTime</code> of the same date but at midnight.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime};

<span class="kw">let </span>nd = NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">28</span>).unwrap();
<span class="kw">let </span>ndt = NaiveDate::from_ymd_opt(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">28</span>).unwrap().and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap();
<span class="macro">assert_eq!</span>(ndt, NaiveDateTime::from(nd));</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CNaiveDateTime%3E-for-NaiveDate" class="impl"><a class="src rightside" href="../src/chrono/naive/date/mod.rs.html#2169-2173">Source</a><a href="#impl-From%3CNaiveDateTime%3E-for-NaiveDate" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt; for <a class="struct" href="struct.NaiveDate.html" title="struct chrono::NaiveDate">NaiveDate</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/date/mod.rs.html#2170-2172">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(naive_datetime: <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2110-2139">Source</a><a href="#impl-FromStr-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Parsing a <code>str</code> into a <code>NaiveDateTime</code> uses the same format,
<a href="format/strftime/index.html" title="mod chrono::format::strftime"><code>%Y-%m-%dT%H:%M:%S%.f</code></a>, as in <code>Debug</code>.</p>
</div></section></summary><div class="docblock"><h4 id="example-46"><a class="doc-anchor" href="#example-46">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDateTime, NaiveDate};

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">18</span>).unwrap().and_hms_opt(<span class="number">23</span>, <span class="number">56</span>, <span class="number">4</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"2015-09-18T23:56:04"</span>.parse::&lt;NaiveDateTime&gt;(), <span class="prelude-val">Ok</span>(dt));

<span class="kw">let </span>dt = NaiveDate::from_ymd_opt(<span class="number">12345</span>, <span class="number">6</span>, <span class="number">7</span>).unwrap().and_hms_milli_opt(<span class="number">7</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">1_500</span>).unwrap(); <span class="comment">// leap second
</span><span class="macro">assert_eq!</span>(<span class="string">"+12345-6-7T7:59:60.5"</span>.parse::&lt;NaiveDateTime&gt;(), <span class="prelude-val">Ok</span>(dt));

<span class="macro">assert!</span>(<span class="string">"foo"</span>.parse::&lt;NaiveDateTime&gt;().is_err());</code></pre></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2111">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="format/struct.ParseError.html" title="struct chrono::format::ParseError">ParseError</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2113-2138">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="type" href="format/type.ParseResult.html" title="type chrono::format::ParseResult">ParseResult</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-Hash-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut __H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-Ord-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1021-1023">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1060-1062">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1086-1088">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-PartialEq-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#264">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-PartialOrd-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1398">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1416">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1434">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1452">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDays%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2016-2022">Source</a><a href="#impl-Sub%3CDays%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Days.html" title="struct chrono::Days">Days</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract <code>Days</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><h4 id="panics-15"><a class="doc-anchor" href="#panics-15">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <code>checked_sub_days</code> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-10" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2017">Source</a><a href="#associatedtype.Output-10" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-5" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#2019-2021">Source</a><a href="#method.sub-5" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, days: <a class="struct" href="struct.Days.html" title="struct chrono::Days">Days</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" title="type core::ops::arith::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1837-1846">Source</a><a href="#impl-Sub%3CDuration%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract <code>std::time::Duration</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s [leap second handling] the subtraction assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-9"><a class="doc-anchor" href="#panics-9">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_sub_signed" title="method chrono::NaiveDateTime::checked_sub_signed"><code>NaiveDateTime::checked_sub_signed</code></a> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1838">Source</a><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1841-1845">Source</a><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CFixedOffset%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1890-1897">Source</a><a href="#impl-Sub%3CFixedOffset%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.FixedOffset.html" title="struct chrono::FixedOffset">FixedOffset</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract <code>FixedOffset</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><h4 id="panics-12"><a class="doc-anchor" href="#panics-12">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <code>checked_sub_offset</code> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1891">Source</a><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1894-1896">Source</a><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.FixedOffset.html" title="struct chrono::FixedOffset">FixedOffset</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CMonths%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1930-1936">Source</a><a href="#impl-Sub%3CMonths%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.Months.html" title="struct chrono::Months">Months</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract <code>Months</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>The result will be clamped to valid days in the resulting month, see
<a href="struct.NaiveDateTime.html#method.checked_sub_months" title="method chrono::NaiveDateTime::checked_sub_months"><code>NaiveDateTime::checked_sub_months</code></a> for details.</p>
<h4 id="panics-13"><a class="doc-anchor" href="#panics-13">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_sub_months" title="method chrono::NaiveDateTime::checked_sub_months"><code>NaiveDateTime::checked_sub_months</code></a> to get an <code>Option</code> instead.</p>
<h4 id="example-42"><a class="doc-anchor" href="#example-42">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{Months, NaiveDate};

<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">01</span>).unwrap().and_hms_opt(<span class="number">01</span>, <span class="number">00</span>, <span class="number">00</span>).unwrap()
        - Months::new(<span class="number">11</span>),
    NaiveDate::from_ymd_opt(<span class="number">2013</span>, <span class="number">02</span>, <span class="number">01</span>).unwrap().and_hms_opt(<span class="number">01</span>, <span class="number">00</span>, <span class="number">00</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">01</span>).unwrap().and_hms_opt(<span class="number">00</span>, <span class="number">02</span>, <span class="number">00</span>).unwrap()
        - Months::new(<span class="number">12</span>),
    NaiveDate::from_ymd_opt(<span class="number">2013</span>, <span class="number">01</span>, <span class="number">01</span>).unwrap().and_hms_opt(<span class="number">00</span>, <span class="number">02</span>, <span class="number">00</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    NaiveDate::from_ymd_opt(<span class="number">2014</span>, <span class="number">01</span>, <span class="number">01</span>).unwrap().and_hms_opt(<span class="number">00</span>, <span class="number">00</span>, <span class="number">03</span>).unwrap()
        - Months::new(<span class="number">13</span>),
    NaiveDate::from_ymd_opt(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">01</span>).unwrap().and_hms_opt(<span class="number">00</span>, <span class="number">00</span>, <span class="number">03</span>).unwrap()
);</code></pre></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1931">Source</a><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1933-1935">Source</a><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Months.html" title="struct chrono::Months">Months</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" title="type core::ops::arith::Sub::Output">Output</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CTimeDelta%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1818-1825">Source</a><a href="#impl-Sub%3CTimeDelta%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract <code>TimeDelta</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>This is the same as the addition with a negated <code>TimeDelta</code>.</p>
<p>As a part of Chrono’s <a href="struct.NaiveTime.html#leap-second-handling" title="struct chrono::NaiveTime">leap second handling</a> the subtraction assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-8"><a class="doc-anchor" href="#panics-8">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_sub_signed" title="method chrono::NaiveDateTime::checked_sub_signed"><code>NaiveDateTime::checked_sub_signed</code></a> to get an <code>Option</code> instead.</p>
<h4 id="example-41"><a class="doc-anchor" href="#example-41">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, TimeDelta};

<span class="kw">let </span>from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();

<span class="kw">let </span>d = from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>);
<span class="kw">let </span>hms = |h, m, s| d.and_hms_opt(h, m, s).unwrap();
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) - TimeDelta::zero(), hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>));
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) - TimeDelta::try_seconds(<span class="number">1</span>).unwrap(), hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>));
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) - TimeDelta::try_seconds(-<span class="number">1</span>).unwrap(), hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) - TimeDelta::try_seconds(<span class="number">3600 </span>+ <span class="number">60</span>).unwrap(), hms(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>));
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) - TimeDelta::try_seconds(<span class="number">86_400</span>).unwrap(),
    from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">7</span>).and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    hms(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>) - TimeDelta::try_days(<span class="number">365</span>).unwrap(),
    from_ymd(<span class="number">2015</span>, <span class="number">7</span>, <span class="number">9</span>).and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap()
);

<span class="kw">let </span>hmsm = |h, m, s, milli| d.and_hms_milli_opt(h, m, s, milli).unwrap();
<span class="macro">assert_eq!</span>(hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">450</span>) - TimeDelta::try_milliseconds(<span class="number">670</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">780</span>));</code></pre></div>
<p>Leap seconds are handled,
but the subtraction assumes that it is the only leap second happened.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>leap = hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>);
<span class="macro">assert_eq!</span>(leap - TimeDelta::zero(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_300</span>));
<span class="macro">assert_eq!</span>(leap - TimeDelta::try_milliseconds(<span class="number">200</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">1_100</span>));
<span class="macro">assert_eq!</span>(leap - TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">59</span>, <span class="number">800</span>));
<span class="macro">assert_eq!</span>(leap - TimeDelta::try_seconds(<span class="number">60</span>).unwrap(), hmsm(<span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">300</span>));
<span class="macro">assert_eq!</span>(leap - TimeDelta::try_days(<span class="number">1</span>).unwrap(),
           from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">7</span>).and_hms_milli_opt(<span class="number">3</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">300</span>).unwrap());</code></pre></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1819">Source</a><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1822-1824">Source</a><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>) -&gt; <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1987-1994">Source</a><a href="#impl-Sub-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtracts another <code>NaiveDateTime</code> from the current date and time.
This does not overflow or underflow at all.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s <a href="./struct.NaiveTime.html#leap-second-handling">leap second handling</a>,
the subtraction assumes that <strong>there is no leap second ever</strong>,
except when any of the <code>NaiveDateTime</code>s themselves represents a leap second
in which case the assumption becomes that
<strong>there are exactly one (or two) leap second(s) ever</strong>.</p>
<p>The implementation is a wrapper around <a href="struct.NaiveDateTime.html#method.signed_duration_since" title="method chrono::NaiveDateTime::signed_duration_since"><code>NaiveDateTime::signed_duration_since</code></a>.</p>
<h4 id="example-43"><a class="doc-anchor" href="#example-43">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, TimeDelta};

<span class="kw">let </span>from_ymd = |y, m, d| NaiveDate::from_ymd_opt(y, m, d).unwrap();

<span class="kw">let </span>d = from_ymd(<span class="number">2016</span>, <span class="number">7</span>, <span class="number">8</span>);
<span class="macro">assert_eq!</span>(
    d.and_hms_opt(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>).unwrap() - d.and_hms_opt(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>).unwrap(),
    TimeDelta::try_seconds(<span class="number">3600 </span>+ <span class="number">60 </span>+ <span class="number">1</span>).unwrap()
);

<span class="comment">// July 8 is 190th day in the year 2016
</span><span class="kw">let </span>d0 = from_ymd(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    d.and_hms_milli_opt(<span class="number">0</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">500</span>).unwrap() - d0.and_hms_opt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap(),
    TimeDelta::try_seconds(<span class="number">189 </span>* <span class="number">86_400 </span>+ <span class="number">7 </span>* <span class="number">60 </span>+ <span class="number">6</span>).unwrap()
        + TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()
);</code></pre></div>
<p>Leap seconds are handled, but the subtraction assumes that no other leap
seconds happened.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>leap = from_ymd(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>).and_hms_milli_opt(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">1_500</span>).unwrap();
<span class="macro">assert_eq!</span>(
    leap - from_ymd(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">30</span>).and_hms_opt(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap(),
    TimeDelta::try_seconds(<span class="number">3600</span>).unwrap() + TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()
);
<span class="macro">assert_eq!</span>(
    from_ymd(<span class="number">2015</span>, <span class="number">7</span>, <span class="number">1</span>).and_hms_opt(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>).unwrap() - leap,
    TimeDelta::try_seconds(<span class="number">3600</span>).unwrap() - TimeDelta::try_milliseconds(<span class="number">500</span>).unwrap()
);</code></pre></div></div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1988">Source</a><a href="#associatedtype.Output-8" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-4" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1991-1993">Source</a><a href="#method.sub-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>) -&gt; <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1877-1882">Source</a><a href="#impl-SubAssign%3CDuration%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract-assign <code>std::time::Duration</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>As a part of Chrono’s [leap second handling], the addition assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap  second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-11"><a class="doc-anchor" href="#panics-11">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_sub_signed" title="method chrono::NaiveDateTime::checked_sub_signed"><code>NaiveDateTime::checked_sub_signed</code></a> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1879-1881">Source</a><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CTimeDelta%3E-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1860-1865">Source</a><a href="#impl-SubAssign%3CTimeDelta%3E-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>&gt; for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3><div class="docblock"><p>Subtract-assign <code>TimeDelta</code> from <code>NaiveDateTime</code>.</p>
</div></section></summary><div class="docblock"><p>This is the same as the addition with a negated <code>TimeDelta</code>.</p>
<p>As a part of Chrono’s [leap second handling], the addition assumes that <strong>there is no leap
second ever</strong>, except when the <code>NaiveDateTime</code> itself represents a leap  second in which case
the assumption becomes that <strong>there is exactly a single leap second ever</strong>.</p>
<h4 id="panics-10"><a class="doc-anchor" href="#panics-10">§</a>Panics</h4>
<p>Panics if the resulting date would be out of range.
Consider using <a href="struct.NaiveDateTime.html#method.checked_sub_signed" title="method chrono::NaiveDateTime::checked_sub_signed"><code>NaiveDateTime::checked_sub_signed</code></a> to get an <code>Option</code> instead.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1862-1864">Source</a><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Timelike-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1361-1572">Source</a><a href="#impl-Timelike-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Timelike.html" title="trait chrono::Timelike">Timelike</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hour" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1376-1378">Source</a><a href="#method.hour" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.hour" class="fn">hour</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the hour number from 0 to 23.</p>
<p>See also the <a href="struct.NaiveTime.html#method.hour" title="method chrono::NaiveTime::hour"><code>NaiveTime::hour</code></a> method.</p>
<h5 id="example-31"><a class="doc-anchor" href="#example-31">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.hour(), <span class="number">12</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1394-1396">Source</a><a href="#method.minute" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.minute" class="fn">minute</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the minute number from 0 to 59.</p>
<p>See also the <a href="struct.NaiveTime.html#method.minute" title="method chrono::NaiveTime::minute"><code>NaiveTime::minute</code></a> method.</p>
<h5 id="example-32"><a class="doc-anchor" href="#example-32">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.minute(), <span class="number">34</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1412-1414">Source</a><a href="#method.second" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.second" class="fn">second</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the second number from 0 to 59.</p>
<p>See also the <a href="struct.NaiveTime.html#method.second" title="method chrono::NaiveTime::second"><code>NaiveTime::second</code></a> method.</p>
<h5 id="example-33"><a class="doc-anchor" href="#example-33">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.second(), <span class="number">56</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1432-1434">Source</a><a href="#method.nanosecond" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.nanosecond" class="fn">nanosecond</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the number of nanoseconds since the whole non-leap second.
The range from 1,000,000,000 to 1,999,999,999 represents
the <a href="./struct.NaiveTime.html#leap-second-handling">leap second</a>.</p>
<p>See also the <a href="struct.NaiveTime.html#method.nanosecond" title="struct chrono::NaiveTime"><code>NaiveTime</code></a> method.</p>
<h5 id="example-34"><a class="doc-anchor" href="#example-34">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(dt.nanosecond(), <span class="number">789_000_000</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_hour" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1460-1462">Source</a><a href="#method.with_hour" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.with_hour" class="fn">with_hour</a>(&amp;self, hour: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the hour number changed.</p>
<p>See also the <a href="struct.NaiveTime.html#method.with_hour" title="method chrono::NaiveTime::with_hour"><code>NaiveTime::with_hour</code></a> method.</p>
<h5 id="errors-16"><a class="doc-anchor" href="#errors-16">§</a>Errors</h5>
<p>Returns <code>None</code> if the value for <code>hour</code> is invalid.</p>
<h5 id="example-35"><a class="doc-anchor" href="#example-35">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_hour(<span class="number">7</span>),
    <span class="prelude-val">Some</span>(
        NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">7</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap()
    )
);
<span class="macro">assert_eq!</span>(dt.with_hour(<span class="number">24</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_minute" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1491-1493">Source</a><a href="#method.with_minute" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.with_minute" class="fn">with_minute</a>(&amp;self, min: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the minute number changed.</p>
<p>See also the <a href="struct.NaiveTime.html#method.with_minute" title="method chrono::NaiveTime::with_minute"><code>NaiveTime::with_minute</code></a> method.</p>
<h5 id="errors-17"><a class="doc-anchor" href="#errors-17">§</a>Errors</h5>
<p>Returns <code>None</code> if the value for <code>minute</code> is invalid.</p>
<h5 id="example-36"><a class="doc-anchor" href="#example-36">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_minute(<span class="number">45</span>),
    <span class="prelude-val">Some</span>(
        NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>)
            .unwrap()
            .and_hms_milli_opt(<span class="number">12</span>, <span class="number">45</span>, <span class="number">56</span>, <span class="number">789</span>)
            .unwrap()
    )
);
<span class="macro">assert_eq!</span>(dt.with_minute(<span class="number">60</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_second" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1525-1527">Source</a><a href="#method.with_second" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.with_second" class="fn">with_second</a>(&amp;self, sec: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with the second number changed.</p>
<p>As with the <a href="#method.second"><code>second</code></a> method,
the input range is restricted to 0 through 59.</p>
<p>See also the <a href="struct.NaiveTime.html#method.with_second" title="method chrono::NaiveTime::with_second"><code>NaiveTime::with_second</code></a> method.</p>
<h5 id="errors-18"><a class="doc-anchor" href="#errors-18">§</a>Errors</h5>
<p>Returns <code>None</code> if the value for <code>second</code> is invalid.</p>
<h5 id="example-37"><a class="doc-anchor" href="#example-37">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_second(<span class="number">17</span>),
    <span class="prelude-val">Some</span>(
        NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>)
            .unwrap()
            .and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">17</span>, <span class="number">789</span>)
            .unwrap()
    )
);
<span class="macro">assert_eq!</span>(dt.with_second(<span class="number">60</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_nanosecond" class="method trait-impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#1569-1571">Source</a><a href="#method.with_nanosecond" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#tymethod.with_nanosecond" class="fn">with_nanosecond</a>(&amp;self, nano: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a>&gt;</h4></section></summary><div class="docblock"><p>Makes a new <code>NaiveDateTime</code> with nanoseconds since the whole non-leap second changed.</p>
<p>Returns <code>None</code> when the resulting <code>NaiveDateTime</code> would be invalid.
As with the <a href="struct.NaiveDateTime.html#method.nanosecond" title="method chrono::NaiveDateTime::nanosecond"><code>NaiveDateTime::nanosecond</code></a> method,
the input range can exceed 1,000,000,000 for leap seconds.</p>
<p>See also the <a href="struct.NaiveTime.html#method.with_nanosecond" title="method chrono::NaiveTime::with_nanosecond"><code>NaiveTime::with_nanosecond</code></a> method.</p>
<h5 id="errors-19"><a class="doc-anchor" href="#errors-19">§</a>Errors</h5>
<p>Returns <code>None</code> if <code>nanosecond &gt;= 2,000,000,000</code>.</p>
<h5 id="example-38"><a class="doc-anchor" href="#example-38">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>chrono::{NaiveDate, NaiveDateTime, Timelike};

<span class="kw">let </span>dt: NaiveDateTime =
    NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>).unwrap().and_hms_milli_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">59</span>, <span class="number">789</span>).unwrap();
<span class="macro">assert_eq!</span>(
    dt.with_nanosecond(<span class="number">333_333_333</span>),
    <span class="prelude-val">Some</span>(
        NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>)
            .unwrap()
            .and_hms_nano_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">59</span>, <span class="number">333_333_333</span>)
            .unwrap()
    )
);
<span class="macro">assert_eq!</span>(
    dt.with_nanosecond(<span class="number">1_333_333_333</span>), <span class="comment">// leap second
    </span><span class="prelude-val">Some</span>(
        NaiveDate::from_ymd_opt(<span class="number">2015</span>, <span class="number">9</span>, <span class="number">8</span>)
            .unwrap()
            .and_hms_nano_opt(<span class="number">12</span>, <span class="number">34</span>, <span class="number">59</span>, <span class="number">1_333_333_333</span>)
            .unwrap()
    )
);
<span class="macro">assert_eq!</span>(dt.with_nanosecond(<span class="number">2_000_000_000</span>), <span class="prelude-val">None</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.hour12" class="method trait-impl"><a class="src rightside" href="../src/chrono/traits.rs.html#290-297">Source</a><a href="#method.hour12" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#method.hour12" class="fn">hour12</a>(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>)</h4></section></summary><div class='docblock'>Returns the hour number from 1 to 12 with a boolean flag,
which is false for AM and true for PM.</div></details><details class="toggle method-toggle" open><summary><section id="method.num_seconds_from_midnight" class="method trait-impl"><a class="src rightside" href="../src/chrono/traits.rs.html#341-343">Source</a><a href="#method.num_seconds_from_midnight" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Timelike.html#method.num_seconds_from_midnight" class="fn">num_seconds_from_midnight</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class='docblock'>Returns the number of non-leap seconds past the last midnight. <a href="trait.Timelike.html#method.num_seconds_from_midnight">Read more</a></div></details></div></details><section id="impl-Copy-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-Copy-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-Eq-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-Eq-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-StructuralPartialEq-for-NaiveDateTime" class="impl"><a class="src rightside" href="../src/chrono/naive/datetime/mod.rs.html#67">Source</a><a href="#impl-StructuralPartialEq-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-NaiveDateTime" class="impl"><a href="#impl-Freeze-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-RefUnwindSafe-for-NaiveDateTime" class="impl"><a href="#impl-RefUnwindSafe-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-Send-for-NaiveDateTime" class="impl"><a href="#impl-Send-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-Sync-for-NaiveDateTime" class="impl"><a href="#impl-Sync-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-Unpin-for-NaiveDateTime" class="impl"><a href="#impl-Unpin-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section><section id="impl-UnwindSafe-for-NaiveDateTime" class="impl"><a href="#impl-UnwindSafe-for-NaiveDateTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.NaiveDateTime.html" title="struct chrono::NaiveDateTime">NaiveDateTime</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#515">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#517">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-SubsecRound-for-T" class="impl"><a class="src rightside" href="../src/chrono/round.rs.html#52-80">Source</a><a href="#impl-SubsecRound-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="round/trait.SubsecRound.html" title="trait chrono::round::SubsecRound">SubsecRound</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>, Output = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.TimeDelta.html" title="struct chrono::TimeDelta">TimeDelta</a>, Output = T&gt; + <a class="trait" href="trait.Timelike.html" title="trait chrono::Timelike">Timelike</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.round_subsecs" class="method trait-impl"><a class="src rightside" href="../src/chrono/round.rs.html#56-69">Source</a><a href="#method.round_subsecs" class="anchor">§</a><h4 class="code-header">fn <a href="round/trait.SubsecRound.html#tymethod.round_subsecs" class="fn">round_subsecs</a>(self, digits: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>) -&gt; T</h4></section></summary><div class='docblock'>Return a copy rounded to the specified number of subsecond digits. With
9 or more digits, self is returned unmodified. Halfway values are
rounded up (away from zero). <a href="round/trait.SubsecRound.html#tymethod.round_subsecs">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.trunc_subsecs" class="method trait-impl"><a class="src rightside" href="../src/chrono/round.rs.html#71-79">Source</a><a href="#method.trunc_subsecs" class="anchor">§</a><h4 class="code-header">fn <a href="round/trait.SubsecRound.html#tymethod.trunc_subsecs" class="fn">trunc_subsecs</a>(self, digits: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>) -&gt; T</h4></section></summary><div class='docblock'>Return a copy truncated to the specified number of subsecond
digits. With 9 or more digits, self is returned unmodified. <a href="round/trait.SubsecRound.html#tymethod.trunc_subsecs">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-86">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2796">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2798">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>