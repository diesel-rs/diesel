<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="github crates-io docs-rs"><title>syn - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="syn" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (975e6c8fe 2025-09-23)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate syn</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../syn/index.html">syn</a><span class="version">2.0.106</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example-of-a-derive-macro" title="Example of a derive macro">Example of a derive macro</a></li><li><a href="#spans-and-error-reporting" title="Spans and error reporting">Spans and error reporting</a></li><li><a href="#parsing-a-custom-syntax" title="Parsing a custom syntax">Parsing a custom syntax</a></li><li><a href="#testing" title="Testing">Testing</a></li><li><a href="#debugging" title="Debugging">Debugging</a></li><li><a href="#optional-features" title="Optional features">Optional features</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>syn</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/syn/lib.rs.html#1-1011">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="https://github.com/dtolnay/syn"><img src="https://img.shields.io/badge/github-8da0cb?style=for-the-badge&amp;labelColor=555555&amp;logo=github" alt="github" /></a> <a href="https://crates.io/crates/syn"><img src="https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&amp;labelColor=555555&amp;logo=rust" alt="crates-io" /></a> <a href="index.html" title="mod syn"><img src="https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&amp;labelColor=555555&amp;logo=docs.rs" alt="docs-rs" /></a></p>
<br>
<p>Syn is a parsing library for parsing a stream of Rust tokens into a syntax
tree of Rust source code.</p>
<p>Currently this library is geared toward use in Rust procedural macros, but
contains some APIs that may be useful more generally.</p>
<ul>
<li>
<p><strong>Data structures</strong> — Syn provides a complete syntax tree that can
represent any valid Rust source code. The syntax tree is rooted at
<a href="struct.File.html" title="struct syn::File"><code>syn::File</code></a> which represents a full source file, but there are other
entry points that may be useful to procedural macros including
<a href="enum.Item.html" title="enum syn::Item"><code>syn::Item</code></a>, <a href="enum.Expr.html" title="enum syn::Expr"><code>syn::Expr</code></a> and <a href="enum.Type.html" title="enum syn::Type"><code>syn::Type</code></a>.</p>
</li>
<li>
<p><strong>Derives</strong> — Of particular interest to derive macros is
<a href="struct.DeriveInput.html" title="struct syn::DeriveInput"><code>syn::DeriveInput</code></a> which is any of the three legal input items to a
derive macro. An example below shows using this type in a library that can
derive implementations of a user-defined trait.</p>
</li>
<li>
<p><strong>Parsing</strong> — Parsing in Syn is built around <a href="parse/index.html" title="mod syn::parse">parser functions</a> with the
signature <code>fn(ParseStream) -&gt; Result&lt;T&gt;</code>. Every syntax tree node defined
by Syn is individually parsable and may be used as a building block for
custom syntaxes, or you may dream up your own brand new syntax without
involving any of our syntax tree types.</p>
</li>
<li>
<p><strong>Location information</strong> — Every token parsed by Syn is associated with a
<code>Span</code> that tracks line and column information back to the source of that
token. These spans allow a procedural macro to display detailed error
messages pointing to all the right places in the user’s code. There is an
example of this below.</p>
</li>
<li>
<p><strong>Feature flags</strong> — Functionality is aggressively feature gated so your
procedural macros enable only what they need, and do not pay in compile
time for all the rest.</p>
</li>
</ul>
<br>
<h2 id="example-of-a-derive-macro"><a class="doc-anchor" href="#example-of-a-derive-macro">§</a>Example of a derive macro</h2>
<p>The canonical derive macro using Syn looks like this. We write an ordinary
Rust function tagged with a <code>proc_macro_derive</code> attribute and the name of
the trait we are deriving. Any time that derive appears in the user’s code,
the Rust compiler passes their data structure as tokens into our macro. We
get to execute arbitrary Rust code to figure out what to do with those
tokens, then hand some tokens back to the compiler to compile into the
user’s crate.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
syn = &quot;2.0&quot;
quote = &quot;1.0&quot;

[lib]
proc-macro = true</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro::TokenStream;
<span class="kw">use </span>quote::quote;
<span class="kw">use </span>syn::{parse_macro_input, DeriveInput};

<span class="attr">#[proc_macro_derive(MyMacro)]
</span><span class="kw">pub fn </span>my_macro(input: TokenStream) -&gt; TokenStream {
    <span class="comment">// Parse the input tokens into a syntax tree
    </span><span class="kw">let </span>input = <span class="macro">parse_macro_input!</span>(input <span class="kw">as </span>DeriveInput);

    <span class="comment">// Build the output, possibly using quasi-quotation
    </span><span class="kw">let </span>expanded = <span class="macro">quote!</span> {
        <span class="comment">// ...
    </span>};

    <span class="comment">// Hand the output tokens back to the compiler
    </span>TokenStream::from(expanded)
}</code></pre></div>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/heapsize"><code>heapsize</code></a> example directory shows a complete working implementation
of a derive macro. The example derives a <code>HeapSize</code> trait which computes an
estimate of the amount of heap memory owned by a value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub trait </span>HeapSize {
    <span class="doccomment">/// Total number of bytes of heap memory owned by `self`.
    </span><span class="kw">fn </span>heap_size_of_children(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize;
}</code></pre></div>
<p>The derive macro allows users to write <code>#[derive(HeapSize)]</code> on data
structures in their program.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(HeapSize)]
</span><span class="kw">struct </span>Demo&lt;<span class="lifetime">'a</span>, T: <span class="question-mark">?</span>Sized&gt; {
    a: Box&lt;T&gt;,
    b: u8,
    c: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str,
    d: String,
}</code></pre></div><p><br></p>
<h2 id="spans-and-error-reporting"><a class="doc-anchor" href="#spans-and-error-reporting">§</a>Spans and error reporting</h2>
<p>The token-based procedural macro API provides great control over where the
compiler’s error messages are displayed in user code. Consider the error the
user sees if one of their field types does not implement <code>HeapSize</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(HeapSize)]
</span><span class="kw">struct </span>Broken {
    ok: String,
    bad: std::thread::Thread,
}</code></pre></div>
<p>By tracking span information all the way through the expansion of a
procedural macro as shown in the <code>heapsize</code> example, token-based macros in
Syn are able to trigger errors that directly pinpoint the source of the
problem.</p>
<div class="example-wrap"><pre class="language-text"><code>error[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied
 --&gt; src/main.rs:7:5
  |
7 |     bad: std::thread::Thread,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`</code></pre></div><br>
<h2 id="parsing-a-custom-syntax"><a class="doc-anchor" href="#parsing-a-custom-syntax">§</a>Parsing a custom syntax</h2>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/lazy-static"><code>lazy-static</code></a> example directory shows the implementation of a
<code>functionlike!(...)</code> procedural macro in which the input tokens are parsed
using Syn’s parsing API.</p>
<p>The example reimplements the popular <code>lazy_static</code> crate from crates.io as a
procedural macro.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">lazy_static!</span> {
    <span class="kw">static </span><span class="kw-2">ref </span>USERNAME: Regex = Regex::new(<span class="string">"^[a-z0-9_-]{3,16}$"</span>).unwrap();
}</code></pre></div>
<p>The implementation shows how to trigger custom warnings and error messages
on the macro input.</p>
<div class="example-wrap"><pre class="language-text"><code>warning: come on, pick a more creative name
  --&gt; src/main.rs:10:16
   |
10 |     static ref FOO: String = &quot;lazy_static&quot;.to_owned();
   |                ^^^</code></pre></div><br>
<h2 id="testing"><a class="doc-anchor" href="#testing">§</a>Testing</h2>
<p>When testing macros, we often care not just that the macro can be used
successfully but also that when the macro is provided with invalid input it
produces maximally helpful error messages. Consider using the <a href="https://github.com/dtolnay/trybuild"><code>trybuild</code></a>
crate to write tests for errors that are emitted by your macro or errors
detected by the Rust compiler in the expanded code following misuse of the
macro. Such tests help avoid regressions from later refactors that
mistakenly make an error no longer trigger or be less helpful than it used
to be.</p>
<br>
<h2 id="debugging"><a class="doc-anchor" href="#debugging">§</a>Debugging</h2>
<p>When developing a procedural macro it can be helpful to look at what the
generated code looks like. Use <code>cargo rustc -- -Zunstable-options --pretty=expanded</code> or the <a href="https://github.com/dtolnay/cargo-expand"><code>cargo expand</code></a> subcommand.</p>
<p>To show the expanded code for some crate that uses your procedural macro,
run <code>cargo expand</code> from that crate. To show the expanded code for one of
your own test cases, run <code>cargo expand --test the_test_case</code> where the last
argument is the name of the test file without the <code>.rs</code> extension.</p>
<p>This write-up by Brandon W Maister discusses debugging in more detail:
<a href="https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/">Debugging Rust’s new Custom Derive system</a>.</p>
<br>
<h2 id="optional-features"><a class="doc-anchor" href="#optional-features">§</a>Optional features</h2>
<p>Syn puts a lot of functionality behind optional features in order to
optimize compile time for the most common use cases. The following features
are available.</p>
<ul>
<li><strong><code>derive</code></strong> <em>(enabled by default)</em> — Data structures for representing the
possible input to a derive macro, including structs and enums and types.</li>
<li><strong><code>full</code></strong> — Data structures for representing the syntax tree of all valid
Rust source code, including items and expressions.</li>
<li><strong><code>parsing</code></strong> <em>(enabled by default)</em> — Ability to parse input tokens into
a syntax tree node of a chosen type.</li>
<li><strong><code>printing</code></strong> <em>(enabled by default)</em> — Ability to print a syntax tree
node as tokens of Rust source code.</li>
<li><strong><code>visit</code></strong> — Trait for traversing a syntax tree.</li>
<li><strong><code>visit-mut</code></strong> — Trait for traversing and mutating in place a syntax
tree.</li>
<li><strong><code>fold</code></strong> — Trait for transforming an owned syntax tree.</li>
<li><strong><code>clone-impls</code></strong> <em>(enabled by default)</em> — Clone impls for all syntax tree
types.</li>
<li><strong><code>extra-traits</code></strong> — Debug, Eq, PartialEq, Hash impls for all syntax tree
types.</li>
<li><strong><code>proc-macro</code></strong> <em>(enabled by default)</em> — Runtime dependency on the
dynamic library libproc_macro from rustc toolchain.</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="buffer/index.html" title="mod syn::buffer">buffer</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>A stably addressed token buffer supporting efficient traversal based on a
cheaply copyable cursor.</dd><dt><a class="mod" href="ext/index.html" title="mod syn::ext">ext</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Extension traits to provide parsing methods on foreign types.</dd><dt><a class="mod" href="fold/index.html" title="mod syn::fold">fold</a><wbr><span class="stab portability" title="Available on crate feature `fold` only"><code>fold</code></span></dt><dd>Syntax tree traversal to transform the nodes of an owned syntax tree.</dd><dt><a class="mod" href="meta/index.html" title="mod syn::meta">meta</a><wbr><span class="stab portability" title="Available on crate feature `parsing` and (crate features `full` or `derive`) only"><code>parsing</code> and (<code>full</code> or <code>derive</code>)</span></dt><dd>Facility for interpreting structured content inside of an <code>Attribute</code>.</dd><dt><a class="mod" href="parse/index.html" title="mod syn::parse">parse</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Parsing interface for parsing a token stream into a syntax tree node.</dd><dt><a class="mod" href="punctuated/index.html" title="mod syn::punctuated">punctuated</a></dt><dd>A punctuated sequence of syntax tree nodes separated by punctuation.</dd><dt><a class="mod" href="spanned/index.html" title="mod syn::spanned">spanned</a><wbr><span class="stab portability" title="Available on crate features `parsing` and `printing` only"><code>parsing</code> and <code>printing</code></span></dt><dd>A trait that can provide the <code>Span</code> of the complete contents of a syntax
tree node.</dd><dt><a class="mod" href="token/index.html" title="mod syn::token">token</a></dt><dd>Tokens representing Rust punctuation, keywords, and delimiters.</dd><dt><a class="mod" href="visit/index.html" title="mod syn::visit">visit</a><wbr><span class="stab portability" title="Available on crate feature `visit` only"><code>visit</code></span></dt><dd>Syntax tree traversal to walk a shared borrow of a syntax tree.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.Token.html" title="macro syn::Token">Token</a></dt><dd>A type-macro that expands to the name of the Rust type representation of a
given token.</dd><dt><a class="macro" href="macro.braced.html" title="macro syn::braced">braced</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Parse a set of curly braces and expose their content to subsequent parsers.</dd><dt><a class="macro" href="macro.bracketed.html" title="macro syn::bracketed">bracketed</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Parse a set of square brackets and expose their content to subsequent
parsers.</dd><dt><a class="macro" href="macro.custom_keyword.html" title="macro syn::custom_keyword">custom_<wbr>keyword</a></dt><dd>Define a type that supports parsing and printing a given identifier as if it
were a keyword.</dd><dt><a class="macro" href="macro.custom_punctuation.html" title="macro syn::custom_punctuation">custom_<wbr>punctuation</a></dt><dd>Define a type that supports parsing and printing a multi-character symbol
as if it were a punctuation token.</dd><dt><a class="macro" href="macro.parenthesized.html" title="macro syn::parenthesized">parenthesized</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Parse a set of parentheses and expose their content to subsequent parsers.</dd><dt><a class="macro" href="macro.parse_macro_input.html" title="macro syn::parse_macro_input">parse_<wbr>macro_<wbr>input</a><wbr><span class="stab portability" title="Available on crate features `parsing` and `proc-macro` only"><code>parsing</code> and <code>proc-macro</code></span></dt><dd>Parse the input TokenStream of a macro, triggering a compile error if the
tokens fail to parse.</dd><dt><a class="macro" href="macro.parse_quote.html" title="macro syn::parse_quote">parse_<wbr>quote</a><wbr><span class="stab portability" title="Available on crate features `parsing` and `printing` only"><code>parsing</code> and <code>printing</code></span></dt><dd>Quasi-quotation macro that accepts input like the <a href="https://docs.rs/quote/1.0/quote/index.html"><code>quote!</code></a> macro but uses
type inference to figure out a return type for those tokens.</dd><dt><a class="macro" href="macro.parse_quote_spanned.html" title="macro syn::parse_quote_spanned">parse_<wbr>quote_<wbr>spanned</a><wbr><span class="stab portability" title="Available on crate features `parsing` and `printing` only"><code>parsing</code> and <code>printing</code></span></dt><dd>This macro is <a href="macro.parse_quote.html" title="macro syn::parse_quote"><code>parse_quote!</code></a> + <a href="../quote/macro.quote_spanned.html" title="macro quote::quote_spanned"><code>quote_spanned!</code></a>.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Abi.html" title="struct syn::Abi">Abi</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The binary interface of a function: <code>extern "C"</code>.</dd><dt><a class="struct" href="struct.AngleBracketedGenericArguments.html" title="struct syn::AngleBracketedGenericArguments">Angle<wbr>Bracketed<wbr>Generic<wbr>Arguments</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Angle bracketed arguments of a path segment: the <code>&lt;K, V&gt;</code> in <code>HashMap&lt;K, V&gt;</code>.</dd><dt><a class="struct" href="struct.Arm.html" title="struct syn::Arm">Arm</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>One arm of a <code>match</code> expression: <code>0..=10 =&gt; { return true; }</code>.</dd><dt><a class="struct" href="struct.AssocConst.html" title="struct syn::AssocConst">Assoc<wbr>Const</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An equality constraint on an associated constant: the <code>PANIC = false</code> in
<code>Trait&lt;PANIC = false&gt;</code>.</dd><dt><a class="struct" href="struct.AssocType.html" title="struct syn::AssocType">Assoc<wbr>Type</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A binding (equality constraint) on an associated type: the <code>Item = u8</code>
in <code>Iterator&lt;Item = u8&gt;</code>.</dd><dt><a class="struct" href="struct.Attribute.html" title="struct syn::Attribute">Attribute</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An attribute, like <code>#[repr(transparent)]</code>.</dd><dt><a class="struct" href="struct.BareFnArg.html" title="struct syn::BareFnArg">Bare<wbr>FnArg</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An argument in a function type: the <code>usize</code> in <code>fn(usize) -&gt; bool</code>.</dd><dt><a class="struct" href="struct.BareVariadic.html" title="struct syn::BareVariadic">Bare<wbr>Variadic</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The variadic argument of a function pointer like <code>fn(usize, ...)</code>.</dd><dt><a class="struct" href="struct.Block.html" title="struct syn::Block">Block</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A braced block containing Rust statements.</dd><dt><a class="struct" href="struct.BoundLifetimes.html" title="struct syn::BoundLifetimes">Bound<wbr>Lifetimes</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A set of bound lifetimes: <code>for&lt;'a, 'b, 'c&gt;</code>.</dd><dt><a class="struct" href="struct.ConstParam.html" title="struct syn::ConstParam">Const<wbr>Param</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A const generic parameter: <code>const LENGTH: usize</code>.</dd><dt><a class="struct" href="struct.Constraint.html" title="struct syn::Constraint">Constraint</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An associated type bound: <code>Iterator&lt;Item: Display&gt;</code>.</dd><dt><a class="struct" href="struct.DataEnum.html" title="struct syn::DataEnum">Data<wbr>Enum</a><wbr><span class="stab portability" title="Available on crate feature `derive` only"><code>derive</code></span></dt><dd>An enum input to a <code>proc_macro_derive</code> macro.</dd><dt><a class="struct" href="struct.DataStruct.html" title="struct syn::DataStruct">Data<wbr>Struct</a><wbr><span class="stab portability" title="Available on crate feature `derive` only"><code>derive</code></span></dt><dd>A struct input to a <code>proc_macro_derive</code> macro.</dd><dt><a class="struct" href="struct.DataUnion.html" title="struct syn::DataUnion">Data<wbr>Union</a><wbr><span class="stab portability" title="Available on crate feature `derive` only"><code>derive</code></span></dt><dd>An untagged union input to a <code>proc_macro_derive</code> macro.</dd><dt><a class="struct" href="struct.DeriveInput.html" title="struct syn::DeriveInput">Derive<wbr>Input</a><wbr><span class="stab portability" title="Available on crate feature `derive` only"><code>derive</code></span></dt><dd>Data structure sent to a <code>proc_macro_derive</code> macro.</dd><dt><a class="struct" href="struct.Error.html" title="struct syn::Error">Error</a></dt><dd>Error returned when a Syn parser cannot parse the input tokens.</dd><dt><a class="struct" href="struct.ExprArray.html" title="struct syn::ExprArray">Expr<wbr>Array</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A slice literal expression: <code>[a, b, c, d]</code>.</dd><dt><a class="struct" href="struct.ExprAssign.html" title="struct syn::ExprAssign">Expr<wbr>Assign</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An assignment expression: <code>a = compute()</code>.</dd><dt><a class="struct" href="struct.ExprAsync.html" title="struct syn::ExprAsync">Expr<wbr>Async</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An async block: <code>async { ... }</code>.</dd><dt><a class="struct" href="struct.ExprAwait.html" title="struct syn::ExprAwait">Expr<wbr>Await</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An await expression: <code>fut.await</code>.</dd><dt><a class="struct" href="struct.ExprBinary.html" title="struct syn::ExprBinary">Expr<wbr>Binary</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A binary operation: <code>a + b</code>, <code>a += b</code>.</dd><dt><a class="struct" href="struct.ExprBlock.html" title="struct syn::ExprBlock">Expr<wbr>Block</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A blocked scope: <code>{ ... }</code>.</dd><dt><a class="struct" href="struct.ExprBreak.html" title="struct syn::ExprBreak">Expr<wbr>Break</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A <code>break</code>, with an optional label to break and an optional
expression.</dd><dt><a class="struct" href="struct.ExprCall.html" title="struct syn::ExprCall">Expr<wbr>Call</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A function call expression: <code>invoke(a, b)</code>.</dd><dt><a class="struct" href="struct.ExprCast.html" title="struct syn::ExprCast">Expr<wbr>Cast</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A cast expression: <code>foo as f64</code>.</dd><dt><a class="struct" href="struct.ExprClosure.html" title="struct syn::ExprClosure">Expr<wbr>Closure</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A closure expression: <code>|a, b| a + b</code>.</dd><dt><a class="struct" href="struct.ExprConst.html" title="struct syn::ExprConst">Expr<wbr>Const</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A const block: <code>const { ... }</code>.</dd><dt><a class="struct" href="struct.ExprContinue.html" title="struct syn::ExprContinue">Expr<wbr>Continue</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A <code>continue</code>, with an optional label.</dd><dt><a class="struct" href="struct.ExprField.html" title="struct syn::ExprField">Expr<wbr>Field</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Access of a named struct field (<code>obj.k</code>) or unnamed tuple struct
field (<code>obj.0</code>).</dd><dt><a class="struct" href="struct.ExprForLoop.html" title="struct syn::ExprForLoop">Expr<wbr>ForLoop</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A for loop: <code>for pat in expr { ... }</code>.</dd><dt><a class="struct" href="struct.ExprGroup.html" title="struct syn::ExprGroup">Expr<wbr>Group</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An expression contained within invisible delimiters.</dd><dt><a class="struct" href="struct.ExprIf.html" title="struct syn::ExprIf">ExprIf</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An <code>if</code> expression with an optional <code>else</code> block: <code>if expr { ... } else { ... }</code>.</dd><dt><a class="struct" href="struct.ExprIndex.html" title="struct syn::ExprIndex">Expr<wbr>Index</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A square bracketed indexing expression: <code>vector[2]</code>.</dd><dt><a class="struct" href="struct.ExprInfer.html" title="struct syn::ExprInfer">Expr<wbr>Infer</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>The inferred value of a const generic argument, denoted <code>_</code>.</dd><dt><a class="struct" href="struct.ExprLet.html" title="struct syn::ExprLet">ExprLet</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A <code>let</code> guard: <code>let Some(x) = opt</code>.</dd><dt><a class="struct" href="struct.ExprLit.html" title="struct syn::ExprLit">ExprLit</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A literal in place of an expression: <code>1</code>, <code>"foo"</code>.</dd><dt><a class="struct" href="struct.ExprLoop.html" title="struct syn::ExprLoop">Expr<wbr>Loop</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Conditionless loop: <code>loop { ... }</code>.</dd><dt><a class="struct" href="struct.ExprMacro.html" title="struct syn::ExprMacro">Expr<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A macro invocation expression: <code>format!("{}", q)</code>.</dd><dt><a class="struct" href="struct.ExprMatch.html" title="struct syn::ExprMatch">Expr<wbr>Match</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.</dd><dt><a class="struct" href="struct.ExprMethodCall.html" title="struct syn::ExprMethodCall">Expr<wbr>Method<wbr>Call</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.</dd><dt><a class="struct" href="struct.ExprParen.html" title="struct syn::ExprParen">Expr<wbr>Paren</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A parenthesized expression: <code>(a + b)</code>.</dd><dt><a class="struct" href="struct.ExprPath.html" title="struct syn::ExprPath">Expr<wbr>Path</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A path like <code>std::mem::replace</code> possibly containing generic
parameters and a qualified self-type.</dd><dt><a class="struct" href="struct.ExprRange.html" title="struct syn::ExprRange">Expr<wbr>Range</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.</dd><dt><a class="struct" href="struct.ExprRawAddr.html" title="struct syn::ExprRawAddr">Expr<wbr>RawAddr</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Address-of operation: <code>&amp;raw const place</code> or <code>&amp;raw mut place</code>.</dd><dt><a class="struct" href="struct.ExprReference.html" title="struct syn::ExprReference">Expr<wbr>Reference</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.</dd><dt><a class="struct" href="struct.ExprRepeat.html" title="struct syn::ExprRepeat">Expr<wbr>Repeat</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An array literal constructed from one repeated element: <code>[0u8; N]</code>.</dd><dt><a class="struct" href="struct.ExprReturn.html" title="struct syn::ExprReturn">Expr<wbr>Return</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A <code>return</code>, with an optional value to be returned.</dd><dt><a class="struct" href="struct.ExprStruct.html" title="struct syn::ExprStruct">Expr<wbr>Struct</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A struct literal expression: <code>Point { x: 1, y: 1 }</code>.</dd><dt><a class="struct" href="struct.ExprTry.html" title="struct syn::ExprTry">ExprTry</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A try-expression: <code>expr?</code>.</dd><dt><a class="struct" href="struct.ExprTryBlock.html" title="struct syn::ExprTryBlock">Expr<wbr>TryBlock</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A try block: <code>try { ... }</code>.</dd><dt><a class="struct" href="struct.ExprTuple.html" title="struct syn::ExprTuple">Expr<wbr>Tuple</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A tuple expression: <code>(a, b, c, d)</code>.</dd><dt><a class="struct" href="struct.ExprUnary.html" title="struct syn::ExprUnary">Expr<wbr>Unary</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A unary operation: <code>!x</code>, <code>*x</code>.</dd><dt><a class="struct" href="struct.ExprUnsafe.html" title="struct syn::ExprUnsafe">Expr<wbr>Unsafe</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An unsafe block: <code>unsafe { ... }</code>.</dd><dt><a class="struct" href="struct.ExprWhile.html" title="struct syn::ExprWhile">Expr<wbr>While</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A while loop: <code>while expr { ... }</code>.</dd><dt><a class="struct" href="struct.ExprYield.html" title="struct syn::ExprYield">Expr<wbr>Yield</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A yield expression: <code>yield expr</code>.</dd><dt><a class="struct" href="struct.Field.html" title="struct syn::Field">Field</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A field of a struct or enum variant.</dd><dt><a class="struct" href="struct.FieldPat.html" title="struct syn::FieldPat">Field<wbr>Pat</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A single field in a struct pattern.</dd><dt><a class="struct" href="struct.FieldValue.html" title="struct syn::FieldValue">Field<wbr>Value</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A field-value pair in a struct literal.</dd><dt><a class="struct" href="struct.FieldsNamed.html" title="struct syn::FieldsNamed">Fields<wbr>Named</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Named fields of a struct or struct variant such as <code>Point { x: f64, y: f64 }</code>.</dd><dt><a class="struct" href="struct.FieldsUnnamed.html" title="struct syn::FieldsUnnamed">Fields<wbr>Unnamed</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Unnamed fields of a tuple struct or tuple variant such as <code>Some(T)</code>.</dd><dt><a class="struct" href="struct.File.html" title="struct syn::File">File</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A complete file of Rust source code.</dd><dt><a class="struct" href="struct.ForeignItemFn.html" title="struct syn::ForeignItemFn">Foreign<wbr>Item<wbr>Fn</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A foreign function in an <code>extern</code> block.</dd><dt><a class="struct" href="struct.ForeignItemMacro.html" title="struct syn::ForeignItemMacro">Foreign<wbr>Item<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A macro invocation within an extern block.</dd><dt><a class="struct" href="struct.ForeignItemStatic.html" title="struct syn::ForeignItemStatic">Foreign<wbr>Item<wbr>Static</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A foreign static item in an <code>extern</code> block: <code>static ext: u8</code>.</dd><dt><a class="struct" href="struct.ForeignItemType.html" title="struct syn::ForeignItemType">Foreign<wbr>Item<wbr>Type</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A foreign type in an <code>extern</code> block: <code>type void</code>.</dd><dt><a class="struct" href="struct.Generics.html" title="struct syn::Generics">Generics</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Lifetimes and type parameters attached to a declaration of a function,
enum, trait, etc.</dd><dt><a class="struct" href="struct.Ident.html" title="struct syn::Ident">Ident</a></dt><dd>A word of Rust code, which may be a keyword or legal variable name.</dd><dt><a class="struct" href="struct.ImplGenerics.html" title="struct syn::ImplGenerics">Impl<wbr>Generics</a><wbr><span class="stab portability" title="Available on (crate features `full` or `derive`) and crate feature `printing` only">(<code>full</code> or <code>derive</code>) and <code>printing</code></span></dt><dd>Returned by <code>Generics::split_for_impl</code>.</dd><dt><a class="struct" href="struct.ImplItemConst.html" title="struct syn::ImplItemConst">Impl<wbr>Item<wbr>Const</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An associated constant within an impl block.</dd><dt><a class="struct" href="struct.ImplItemFn.html" title="struct syn::ImplItemFn">Impl<wbr>Item<wbr>Fn</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An associated function within an impl block.</dd><dt><a class="struct" href="struct.ImplItemMacro.html" title="struct syn::ImplItemMacro">Impl<wbr>Item<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A macro invocation within an impl block.</dd><dt><a class="struct" href="struct.ImplItemType.html" title="struct syn::ImplItemType">Impl<wbr>Item<wbr>Type</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An associated type within an impl block.</dd><dt><a class="struct" href="struct.Index.html" title="struct syn::Index">Index</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The index of an unnamed tuple struct field.</dd><dt><a class="struct" href="struct.ItemConst.html" title="struct syn::ItemConst">Item<wbr>Const</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A constant item: <code>const MAX: u16 = 65535</code>.</dd><dt><a class="struct" href="struct.ItemEnum.html" title="struct syn::ItemEnum">Item<wbr>Enum</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An enum definition: <code>enum Foo&lt;A, B&gt; { A(A), B(B) }</code>.</dd><dt><a class="struct" href="struct.ItemExternCrate.html" title="struct syn::ItemExternCrate">Item<wbr>Extern<wbr>Crate</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An <code>extern crate</code> item: <code>extern crate serde</code>.</dd><dt><a class="struct" href="struct.ItemFn.html" title="struct syn::ItemFn">ItemFn</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A free-standing function: <code>fn process(n: usize) -&gt; Result&lt;()&gt; { ... }</code>.</dd><dt><a class="struct" href="struct.ItemForeignMod.html" title="struct syn::ItemForeignMod">Item<wbr>Foreign<wbr>Mod</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A block of foreign items: <code>extern "C" { ... }</code>.</dd><dt><a class="struct" href="struct.ItemImpl.html" title="struct syn::ItemImpl">Item<wbr>Impl</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An impl block providing trait or associated items: <code>impl&lt;A&gt; Trait for Data&lt;A&gt; { ... }</code>.</dd><dt><a class="struct" href="struct.ItemMacro.html" title="struct syn::ItemMacro">Item<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A macro invocation, which includes <code>macro_rules!</code> definitions.</dd><dt><a class="struct" href="struct.ItemMod.html" title="struct syn::ItemMod">ItemMod</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A module or module declaration: <code>mod m</code> or <code>mod m { ... }</code>.</dd><dt><a class="struct" href="struct.ItemStatic.html" title="struct syn::ItemStatic">Item<wbr>Static</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A static item: <code>static BIKE: Shed = Shed(42)</code>.</dd><dt><a class="struct" href="struct.ItemStruct.html" title="struct syn::ItemStruct">Item<wbr>Struct</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A struct definition: <code>struct Foo&lt;A&gt; { x: A }</code>.</dd><dt><a class="struct" href="struct.ItemTrait.html" title="struct syn::ItemTrait">Item<wbr>Trait</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A trait definition: <code>pub trait Iterator { ... }</code>.</dd><dt><a class="struct" href="struct.ItemTraitAlias.html" title="struct syn::ItemTraitAlias">Item<wbr>Trait<wbr>Alias</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A trait alias: <code>pub trait SharableIterator = Iterator + Sync</code>.</dd><dt><a class="struct" href="struct.ItemType.html" title="struct syn::ItemType">Item<wbr>Type</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A type alias: <code>type Result&lt;T&gt; = std::result::Result&lt;T, MyError&gt;</code>.</dd><dt><a class="struct" href="struct.ItemUnion.html" title="struct syn::ItemUnion">Item<wbr>Union</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A union definition: <code>union Foo&lt;A, B&gt; { x: A, y: B }</code>.</dd><dt><a class="struct" href="struct.ItemUse.html" title="struct syn::ItemUse">ItemUse</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A use declaration: <code>use std::collections::HashMap</code>.</dd><dt><a class="struct" href="struct.Label.html" title="struct syn::Label">Label</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A lifetime labeling a <code>for</code>, <code>while</code>, or <code>loop</code>.</dd><dt><a class="struct" href="struct.Lifetime.html" title="struct syn::Lifetime">Lifetime</a></dt><dd>A Rust lifetime: <code>'a</code>.</dd><dt><a class="struct" href="struct.LifetimeParam.html" title="struct syn::LifetimeParam">Lifetime<wbr>Param</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A lifetime definition: <code>'a: 'b + 'c + 'd</code>.</dd><dt><a class="struct" href="struct.LitBool.html" title="struct syn::LitBool">LitBool</a></dt><dd>A boolean literal: <code>true</code> or <code>false</code>.</dd><dt><a class="struct" href="struct.LitByte.html" title="struct syn::LitByte">LitByte</a></dt><dd>A byte literal: <code>b'f'</code>.</dd><dt><a class="struct" href="struct.LitByteStr.html" title="struct syn::LitByteStr">LitByte<wbr>Str</a></dt><dd>A byte string literal: <code>b"foo"</code>.</dd><dt><a class="struct" href="struct.LitCStr.html" title="struct syn::LitCStr">LitCStr</a></dt><dd>A nul-terminated C-string literal: <code>c"foo"</code>.</dd><dt><a class="struct" href="struct.LitChar.html" title="struct syn::LitChar">LitChar</a></dt><dd>A character literal: <code>'a'</code>.</dd><dt><a class="struct" href="struct.LitFloat.html" title="struct syn::LitFloat">LitFloat</a></dt><dd>A floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.</dd><dt><a class="struct" href="struct.LitInt.html" title="struct syn::LitInt">LitInt</a></dt><dd>An integer literal: <code>1</code> or <code>1u16</code>.</dd><dt><a class="struct" href="struct.LitStr.html" title="struct syn::LitStr">LitStr</a></dt><dd>A UTF-8 string literal: <code>"foo"</code>.</dd><dt><a class="struct" href="struct.Local.html" title="struct syn::Local">Local</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A local <code>let</code> binding: <code>let x: u64 = s.parse()?;</code>.</dd><dt><a class="struct" href="struct.LocalInit.html" title="struct syn::LocalInit">Local<wbr>Init</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>The expression assigned in a local <code>let</code> binding, including optional
diverging <code>else</code> block.</dd><dt><a class="struct" href="struct.Macro.html" title="struct syn::Macro">Macro</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A macro invocation: <code>println!("{}", mac)</code>.</dd><dt><a class="struct" href="struct.MetaList.html" title="struct syn::MetaList">Meta<wbr>List</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A structured list within an attribute, like <code>derive(Copy, Clone)</code>.</dd><dt><a class="struct" href="struct.MetaNameValue.html" title="struct syn::MetaNameValue">Meta<wbr>Name<wbr>Value</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A name-value pair within an attribute, like <code>feature = "nightly"</code>.</dd><dt><a class="struct" href="struct.ParenthesizedGenericArguments.html" title="struct syn::ParenthesizedGenericArguments">Parenthesized<wbr>Generic<wbr>Arguments</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Arguments of a function path segment: the <code>(A, B) -&gt; C</code> in <code>Fn(A,B) -&gt; C</code>.</dd><dt><a class="struct" href="struct.PatConst.html" title="struct syn::PatConst">PatConst</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A const block: <code>const { ... }</code>.</dd><dt><a class="struct" href="struct.PatIdent.html" title="struct syn::PatIdent">PatIdent</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A pattern that binds a new variable: <code>ref mut binding @ SUBPATTERN</code>.</dd><dt><a class="struct" href="struct.PatLit.html" title="struct syn::PatLit">PatLit</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A literal in place of an expression: <code>1</code>, <code>"foo"</code>.</dd><dt><a class="struct" href="struct.PatMacro.html" title="struct syn::PatMacro">PatMacro</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A macro invocation expression: <code>format!("{}", q)</code>.</dd><dt><a class="struct" href="struct.PatOr.html" title="struct syn::PatOr">PatOr</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A pattern that matches any one of a set of cases.</dd><dt><a class="struct" href="struct.PatParen.html" title="struct syn::PatParen">PatParen</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A parenthesized pattern: <code>(A | B)</code>.</dd><dt><a class="struct" href="struct.PatPath.html" title="struct syn::PatPath">PatPath</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A path like <code>std::mem::replace</code> possibly containing generic
parameters and a qualified self-type.</dd><dt><a class="struct" href="struct.PatRange.html" title="struct syn::PatRange">PatRange</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.</dd><dt><a class="struct" href="struct.PatReference.html" title="struct syn::PatReference">PatReference</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A reference pattern: <code>&amp;mut var</code>.</dd><dt><a class="struct" href="struct.PatRest.html" title="struct syn::PatRest">PatRest</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>The dots in a tuple or slice pattern: <code>[0, 1, ..]</code>.</dd><dt><a class="struct" href="struct.PatSlice.html" title="struct syn::PatSlice">PatSlice</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A dynamically sized slice pattern: <code>[a, b, ref i @ .., y, z]</code>.</dd><dt><a class="struct" href="struct.PatStruct.html" title="struct syn::PatStruct">PatStruct</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A struct or struct variant pattern: <code>Variant { x, y, .. }</code>.</dd><dt><a class="struct" href="struct.PatTuple.html" title="struct syn::PatTuple">PatTuple</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A tuple pattern: <code>(a, b)</code>.</dd><dt><a class="struct" href="struct.PatTupleStruct.html" title="struct syn::PatTupleStruct">PatTuple<wbr>Struct</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A tuple struct or tuple variant pattern: <code>Variant(x, y, .., z)</code>.</dd><dt><a class="struct" href="struct.PatType.html" title="struct syn::PatType">PatType</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A type ascription pattern: <code>foo: f64</code>.</dd><dt><a class="struct" href="struct.PatWild.html" title="struct syn::PatWild">PatWild</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A pattern that matches any value: <code>_</code>.</dd><dt><a class="struct" href="struct.Path.html" title="struct syn::Path">Path</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A path at which a named item is exported (e.g. <code>std::collections::HashMap</code>).</dd><dt><a class="struct" href="struct.PathSegment.html" title="struct syn::PathSegment">Path<wbr>Segment</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A segment of a path together with any path arguments on that segment.</dd><dt><a class="struct" href="struct.PreciseCapture.html" title="struct syn::PreciseCapture">Precise<wbr>Capture</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Precise capturing bound: the ‘use&lt;…&gt;’ in <code>impl Trait + use&lt;'a, T&gt;</code>.</dd><dt><a class="struct" href="struct.PredicateLifetime.html" title="struct syn::PredicateLifetime">Predicate<wbr>Lifetime</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A lifetime predicate in a <code>where</code> clause: <code>'a: 'b + 'c</code>.</dd><dt><a class="struct" href="struct.PredicateType.html" title="struct syn::PredicateType">Predicate<wbr>Type</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A type predicate in a <code>where</code> clause: <code>for&lt;'c&gt; Foo&lt;'c&gt;: Trait&lt;'c&gt;</code>.</dd><dt><a class="struct" href="struct.QSelf.html" title="struct syn::QSelf">QSelf</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The explicit Self type in a qualified path: the <code>T</code> in <code>&lt;T as Display&gt;::fmt</code>.</dd><dt><a class="struct" href="struct.Receiver.html" title="struct syn::Receiver">Receiver</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>The <code>self</code> argument of an associated method.</dd><dt><a class="struct" href="struct.Signature.html" title="struct syn::Signature">Signature</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A function signature in a trait or implementation: <code>unsafe fn initialize(&amp;self)</code>.</dd><dt><a class="struct" href="struct.StmtMacro.html" title="struct syn::StmtMacro">Stmt<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A macro invocation in statement position.</dd><dt><a class="struct" href="struct.TraitBound.html" title="struct syn::TraitBound">Trait<wbr>Bound</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A trait used as a bound on a type parameter.</dd><dt><a class="struct" href="struct.TraitItemConst.html" title="struct syn::TraitItemConst">Trait<wbr>Item<wbr>Const</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An associated constant within the definition of a trait.</dd><dt><a class="struct" href="struct.TraitItemFn.html" title="struct syn::TraitItemFn">Trait<wbr>Item<wbr>Fn</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An associated function within the definition of a trait.</dd><dt><a class="struct" href="struct.TraitItemMacro.html" title="struct syn::TraitItemMacro">Trait<wbr>Item<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A macro invocation within the definition of a trait.</dd><dt><a class="struct" href="struct.TraitItemType.html" title="struct syn::TraitItemType">Trait<wbr>Item<wbr>Type</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An associated type within the definition of a trait.</dd><dt><a class="struct" href="struct.Turbofish.html" title="struct syn::Turbofish">Turbofish</a><wbr><span class="stab portability" title="Available on (crate features `full` or `derive`) and crate feature `printing` only">(<code>full</code> or <code>derive</code>) and <code>printing</code></span></dt><dd>Returned by <code>TypeGenerics::as_turbofish</code>.</dd><dt><a class="struct" href="struct.TypeArray.html" title="struct syn::TypeArray">Type<wbr>Array</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A fixed size array type: <code>[T; n]</code>.</dd><dt><a class="struct" href="struct.TypeBareFn.html" title="struct syn::TypeBareFn">Type<wbr>Bare<wbr>Fn</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A bare function type: <code>fn(usize) -&gt; bool</code>.</dd><dt><a class="struct" href="struct.TypeGenerics.html" title="struct syn::TypeGenerics">Type<wbr>Generics</a><wbr><span class="stab portability" title="Available on (crate features `full` or `derive`) and crate feature `printing` only">(<code>full</code> or <code>derive</code>) and <code>printing</code></span></dt><dd>Returned by <code>Generics::split_for_impl</code>.</dd><dt><a class="struct" href="struct.TypeGroup.html" title="struct syn::TypeGroup">Type<wbr>Group</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A type contained within invisible delimiters.</dd><dt><a class="struct" href="struct.TypeImplTrait.html" title="struct syn::TypeImplTrait">Type<wbr>Impl<wbr>Trait</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a trait or
a lifetime.</dd><dt><a class="struct" href="struct.TypeInfer.html" title="struct syn::TypeInfer">Type<wbr>Infer</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Indication that a type should be inferred by the compiler: <code>_</code>.</dd><dt><a class="struct" href="struct.TypeMacro.html" title="struct syn::TypeMacro">Type<wbr>Macro</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A macro in the type position.</dd><dt><a class="struct" href="struct.TypeNever.html" title="struct syn::TypeNever">Type<wbr>Never</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The never type: <code>!</code>.</dd><dt><a class="struct" href="struct.TypeParam.html" title="struct syn::TypeParam">Type<wbr>Param</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A generic type parameter: <code>T: Into&lt;String&gt;</code>.</dd><dt><a class="struct" href="struct.TypeParen.html" title="struct syn::TypeParen">Type<wbr>Paren</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A parenthesized type equivalent to the inner type.</dd><dt><a class="struct" href="struct.TypePath.html" title="struct syn::TypePath">Type<wbr>Path</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A path like <code>std::slice::Iter</code>, optionally qualified with a
self-type as in <code>&lt;Vec&lt;T&gt; as SomeTrait&gt;::Associated</code>.</dd><dt><a class="struct" href="struct.TypePtr.html" title="struct syn::TypePtr">TypePtr</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A raw pointer type: <code>*const T</code> or <code>*mut T</code>.</dd><dt><a class="struct" href="struct.TypeReference.html" title="struct syn::TypeReference">Type<wbr>Reference</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A reference type: <code>&amp;'a T</code> or <code>&amp;'a mut T</code>.</dd><dt><a class="struct" href="struct.TypeSlice.html" title="struct syn::TypeSlice">Type<wbr>Slice</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A dynamically sized slice type: <code>[T]</code>.</dd><dt><a class="struct" href="struct.TypeTraitObject.html" title="struct syn::TypeTraitObject">Type<wbr>Trait<wbr>Object</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A trait object type <code>dyn Bound1 + Bound2 + Bound3</code> where <code>Bound</code> is a
trait or a lifetime.</dd><dt><a class="struct" href="struct.TypeTuple.html" title="struct syn::TypeTuple">Type<wbr>Tuple</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A tuple type: <code>(A, B, C, String)</code>.</dd><dt><a class="struct" href="struct.UseGlob.html" title="struct syn::UseGlob">UseGlob</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A glob import in a <code>use</code> item: <code>*</code>.</dd><dt><a class="struct" href="struct.UseGroup.html" title="struct syn::UseGroup">UseGroup</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A braced group of imports in a <code>use</code> item: <code>{A, B, C}</code>.</dd><dt><a class="struct" href="struct.UseName.html" title="struct syn::UseName">UseName</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An identifier imported by a <code>use</code> item: <code>HashMap</code>.</dd><dt><a class="struct" href="struct.UsePath.html" title="struct syn::UsePath">UsePath</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A path prefix of imports in a <code>use</code> item: <code>std::...</code>.</dd><dt><a class="struct" href="struct.UseRename.html" title="struct syn::UseRename">UseRename</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An renamed identifier imported by a <code>use</code> item: <code>HashMap as Map</code>.</dd><dt><a class="struct" href="struct.Variadic.html" title="struct syn::Variadic">Variadic</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>The variadic argument of a foreign function.</dd><dt><a class="struct" href="struct.Variant.html" title="struct syn::Variant">Variant</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An enum variant.</dd><dt><a class="struct" href="struct.VisRestricted.html" title="struct syn::VisRestricted">VisRestricted</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A visibility level restricted to some path: <code>pub(self)</code> or
<code>pub(super)</code> or <code>pub(crate)</code> or <code>pub(in some::module)</code>.</dd><dt><a class="struct" href="struct.WhereClause.html" title="struct syn::WhereClause">Where<wbr>Clause</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A <code>where</code> clause in a definition: <code>where T: Deserialize&lt;'de&gt;, D: 'static</code>.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AttrStyle.html" title="enum syn::AttrStyle">Attr<wbr>Style</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Distinguishes between attributes that decorate an item and attributes
that are contained within an item.</dd><dt><a class="enum" href="enum.BinOp.html" title="enum syn::BinOp">BinOp</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A binary operator: <code>+</code>, <code>+=</code>, <code>&amp;</code>.</dd><dt><a class="enum" href="enum.CapturedParam.html" title="enum syn::CapturedParam">Captured<wbr>Param</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Single parameter in a precise capturing bound.</dd><dt><a class="enum" href="enum.Data.html" title="enum syn::Data">Data</a><wbr><span class="stab portability" title="Available on crate feature `derive` only"><code>derive</code></span></dt><dd>The storage of a struct, enum or union data structure.</dd><dt><a class="enum" href="enum.Expr.html" title="enum syn::Expr">Expr</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A Rust expression.</dd><dt><a class="enum" href="enum.FieldMutability.html" title="enum syn::FieldMutability">Field<wbr>Mutability</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Unused, but reserved for RFC 3323 restrictions.</dd><dt><a class="enum" href="enum.Fields.html" title="enum syn::Fields">Fields</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Data stored within an enum variant or struct.</dd><dt><a class="enum" href="enum.FnArg.html" title="enum syn::FnArg">FnArg</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An argument in a function signature: the <code>n: usize</code> in <code>fn f(n: usize)</code>.</dd><dt><a class="enum" href="enum.ForeignItem.html" title="enum syn::ForeignItem">Foreign<wbr>Item</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An item within an <code>extern</code> block.</dd><dt><a class="enum" href="enum.GenericArgument.html" title="enum syn::GenericArgument">Generic<wbr>Argument</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>An individual generic argument, like <code>'a</code>, <code>T</code>, or <code>Item = T</code>.</dd><dt><a class="enum" href="enum.GenericParam.html" title="enum syn::GenericParam">Generic<wbr>Param</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A generic type parameter, lifetime, or const generic: <code>T: Into&lt;String&gt;</code>,
<code>'a: 'b</code>, <code>const LEN: usize</code>.</dd><dt><a class="enum" href="enum.ImplItem.html" title="enum syn::ImplItem">Impl<wbr>Item</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An item within an impl block.</dd><dt><a class="enum" href="enum.ImplRestriction.html" title="enum syn::ImplRestriction">Impl<wbr>Restriction</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Unused, but reserved for RFC 3323 restrictions.</dd><dt><a class="enum" href="enum.Item.html" title="enum syn::Item">Item</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Things that can appear directly inside of a module or scope.</dd><dt><a class="enum" href="enum.Lit.html" title="enum syn::Lit">Lit</a></dt><dd>A Rust literal such as a string or integer or boolean.</dd><dt><a class="enum" href="enum.MacroDelimiter.html" title="enum syn::MacroDelimiter">Macro<wbr>Delimiter</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A grouping token that surrounds a macro body: <code>m!(...)</code> or <code>m!{...}</code> or <code>m![...]</code>.</dd><dt><a class="enum" href="enum.Member.html" title="enum syn::Member">Member</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A struct or tuple struct field accessed in a struct literal or field
expression.</dd><dt><a class="enum" href="enum.Meta.html" title="enum syn::Meta">Meta</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Content of a compile-time structured attribute.</dd><dt><a class="enum" href="enum.Pat.html" title="enum syn::Pat">Pat</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A pattern in a local binding, function signature, match expression, or
various other places.</dd><dt><a class="enum" href="enum.PathArguments.html" title="enum syn::PathArguments">Path<wbr>Arguments</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Angle bracketed or parenthesized arguments of a path segment.</dd><dt><a class="enum" href="enum.PointerMutability.html" title="enum syn::PointerMutability">Pointer<wbr>Mutability</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Mutability of a raw pointer (<code>*const T</code>, <code>*mut T</code>), in which non-mutable
isn’t the implicit default.</dd><dt><a class="enum" href="enum.RangeLimits.html" title="enum syn::RangeLimits">Range<wbr>Limits</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>Limit types of a range, inclusive or exclusive.</dd><dt><a class="enum" href="enum.ReturnType.html" title="enum syn::ReturnType">Return<wbr>Type</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>Return type of a function signature.</dd><dt><a class="enum" href="enum.StaticMutability.html" title="enum syn::StaticMutability">Static<wbr>Mutability</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>The mutability of an <code>Item::Static</code> or <code>ForeignItem::Static</code>.</dd><dt><a class="enum" href="enum.Stmt.html" title="enum syn::Stmt">Stmt</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A statement, usually ending in a semicolon.</dd><dt><a class="enum" href="enum.TraitBoundModifier.html" title="enum syn::TraitBoundModifier">Trait<wbr>Bound<wbr>Modifier</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A modifier on a trait bound, currently only used for the <code>?</code> in
<code>?Sized</code>.</dd><dt><a class="enum" href="enum.TraitItem.html" title="enum syn::TraitItem">Trait<wbr>Item</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>An item declaration within the definition of a trait.</dd><dt><a class="enum" href="enum.Type.html" title="enum syn::Type">Type</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The possible types that a Rust value could have.</dd><dt><a class="enum" href="enum.TypeParamBound.html" title="enum syn::TypeParamBound">Type<wbr>Param<wbr>Bound</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A trait or lifetime used as a bound on a type parameter.</dd><dt><a class="enum" href="enum.UnOp.html" title="enum syn::UnOp">UnOp</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A unary operator: <code>*</code>, <code>!</code>, <code>-</code>.</dd><dt><a class="enum" href="enum.UseTree.html" title="enum syn::UseTree">UseTree</a><wbr><span class="stab portability" title="Available on crate feature `full` only"><code>full</code></span></dt><dd>A suffix of an import tree in a <code>use</code> item: <code>Type as Renamed</code> or <code>*</code>.</dd><dt><a class="enum" href="enum.Visibility.html" title="enum syn::Visibility">Visibility</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>The visibility level of an item: inherited or <code>pub</code> or
<code>pub(restricted)</code>.</dd><dt><a class="enum" href="enum.WherePredicate.html" title="enum syn::WherePredicate">Where<wbr>Predicate</a><wbr><span class="stab portability" title="Available on crate features `full` or `derive` only"><code>full</code> or <code>derive</code></span></dt><dd>A single predicate in a <code>where</code> clause: <code>T: Deserialize&lt;'de&gt;</code>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.parse.html" title="fn syn::parse">parse</a><wbr><span class="stab portability" title="Available on crate features `parsing` and `proc-macro` only"><code>parsing</code> and <code>proc-macro</code></span></dt><dd>Parse tokens of source code into the chosen syntax tree node.</dd><dt><a class="fn" href="fn.parse2.html" title="fn syn::parse2">parse2</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Parse a proc-macro2 token stream into the chosen syntax tree node.</dd><dt><a class="fn" href="fn.parse_file.html" title="fn syn::parse_file">parse_<wbr>file</a><wbr><span class="stab portability" title="Available on crate features `parsing` and `full` only"><code>parsing</code> and <code>full</code></span></dt><dd>Parse the content of a file of Rust code.</dd><dt><a class="fn" href="fn.parse_str.html" title="fn syn::parse_str">parse_<wbr>str</a><wbr><span class="stab portability" title="Available on crate feature `parsing` only"><code>parsing</code></span></dt><dd>Parse a string of Rust code into the chosen syntax tree node.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.Result.html" title="type syn::Result">Result</a></dt><dd>The result of a Syn parser.</dd></dl></section></div></main></body></html>