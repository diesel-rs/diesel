use std::convert::TryInto;
use std::io::prelude::*;

use crate::deserialize::{self, FromSql};
use crate::pg::{Pg, PgValue};
use crate::serialize::{self, IsNull, Output, ToSql};
use crate::sql_types::MacAddr;

#[allow(dead_code)]
mod foreign_derives {
    use super::*;
    use crate::deserialize::FromSqlRow;
    use crate::expression::AsExpression;

    #[derive(AsExpression, FromSqlRow)]
    #[diesel(foreign_derive)]
    #[diesel(sql_type = MacAddr)]
    struct ByteArrayProxy([u8; 6]);
}

#[cfg(feature = "postgres_backend")]
impl FromSql<MacAddr, Pg> for [u8; 6] {
    fn from_sql(value: PgValue<'_>) -> deserialize::Result<Self> {
        value
            .as_bytes()
            .try_into()
            .map_err(|_| "invalid network address format: input isn't 6 bytes.".into())
    }
}

#[cfg(feature = "postgres_backend")]
impl ToSql<MacAddr, Pg> for [u8; 6] {
    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, Pg>) -> serialize::Result {
        out.write_all(&self[..])
            .map(|_| IsNull::No)
            .map_err(Into::into)
    }
}

#[cfg(all(feature = "macaddr", feature = "postgres_backend"))]
impl FromSql<MacAddr, Pg> for macaddr::MacAddr6 {
    fn from_sql(value: PgValue<'_>) -> deserialize::Result<Self> {
        <[u8; 6] as FromSql<MacAddr, Pg>>::from_sql(value).map(Into::into)
    }
}

#[cfg(all(feature = "macaddr", feature = "postgres_backend"))]
impl ToSql<MacAddr, Pg> for macaddr::MacAddr6 {
    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, Pg>) -> serialize::Result {
        let array_value = self.into_array();
        <[u8; 6] as ToSql<MacAddr, Pg>>::to_sql(&array_value, &mut out.reborrow())
    }
}

#[test]
fn macaddr_roundtrip() {
    use crate::query_builder::bind_collector::ByteWrapper;

    let mut buffer = Vec::new();
    let mut bytes = Output::test(ByteWrapper(&mut buffer));
    let input_address = [0x52, 0x54, 0x00, 0xfb, 0xc6, 0x16];
    ToSql::<MacAddr, Pg>::to_sql(&input_address, &mut bytes).unwrap();

    let output_address: [u8; 6] = FromSql::from_sql(PgValue::for_test(&buffer)).unwrap();
    assert_eq!(input_address, output_address);

    #[cfg(feature = "macaddr")]
    {
        use macaddr::MacAddr6;

        let input_address: MacAddr6 = input_address.into();
        let output_address: MacAddr6 = FromSql::from_sql(PgValue::for_test(&buffer)).unwrap();
        assert_eq!(input_address, output_address);
    }
}
