<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implements `QueryableByName` for untyped sql queries, such as that one generated by `sql_query`"><title>QueryableByName in diesel::deserialize - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="diesel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (6501e64fc 2025-10-23)" data-channel="nightly" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">QueryableByName</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../diesel/index.html">diesel</a><span class="version">2.3.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Queryable<wbr>ByName</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#attributes" title="Attributes">Attributes</a><ul><li><a href="#optional-container-attributes" title="Optional container attributes">Optional container attributes</a></li><li><a href="#optional-field-attributes" title="Optional field attributes">Optional field attributes</a></li></ul></li><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#expanded-code" title="Expanded Code">Expanded Code</a><ul><li><a href="#input" title="Input">Input</a></li><li><a href="#expanded-code-1" title="Expanded Code">Expanded Code</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In diesel::<wbr>deserialize</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">diesel</a>::<wbr><a href="index.html">deserialize</a></div><h1>Derive Macro <span class="derive">Queryable<wbr>ByName</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/diesel_derives/lib.rs.html#926">Source</a> </span></div><pre class="rust item-decl"><code>#[derive(QueryableByName)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[diesel]
    #[table_name]
    #[column_name]
    #[sql_type]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implements <code>QueryableByName</code> for untyped sql queries, such as that one generated
by <code>sql_query</code></p>
<p>To derive this trait, Diesel needs to know the SQL type of each field.
It can get the data from the corresponding table type.
It uses the <code>snake_case</code> type name with an added <code>s</code>.
It is possible to change this default by using <code>#[diesel(table_name = something)]</code>.
If you define use the table type, the SQL type will be
<code>diesel::dsl::SqlTypeOf&lt;table_name::column_name&gt;</code>. In cases which there are no table type,
you can do the same by annotating each field with <code>#[diesel(sql_type = SomeType)]</code>.</p>
<p>If the name of a field on your struct is different from the column in your
<code>table!</code> declaration, or if you’re deriving this trait on a tuple struct,
you can annotate the field with <code>#[diesel(column_name = some_column)]</code>. For tuple
structs, all fields must have this annotation.</p>
<p>If a field is another struct which implements <code>QueryableByName</code>,
instead of a column, you can annotate that with <code>#[diesel(embed)]</code>.
Then all fields contained by that inner struct are loaded into the embedded struct.</p>
<p>To provide custom deserialization behavior for a field, you can use
<code>#[diesel(deserialize_as = SomeType)]</code>. If this attribute is present, Diesel
will deserialize the corresponding field into <code>SomeType</code>, rather than the
actual field type on your struct and then call <code>.into</code> to convert it to the
actual field type. This can be used to add custom behavior for a
single field, or use types that are otherwise unsupported by Diesel.</p>
<h2 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h2><h3 id="optional-container-attributes"><a class="doc-anchor" href="#optional-container-attributes">§</a>Optional container attributes</h3>
<ul>
<li><code>#[diesel(table_name = path::to::table)]</code>, to specify that this type contains
columns for the specified table. The path is relative to the current module.
If no field attributes are specified the derive will use the sql type of
the corresponding column.</li>
<li><code>#[diesel(check_for_backend(diesel::pg::Pg, diesel::mysql::Mysql))]</code>, instructs
the derive to generate additional code to identify potential type mismatches.
It accepts a list of backend types to check the types against. Using this option
will result in much better error messages in cases where some types in your <code>QueryableByName</code>
struct don’t match. You need to specify the concrete database backend
this specific struct is indented to be used with, as otherwise rustc can’t correctly
identify the required deserialization implementation.</li>
</ul>
<h3 id="optional-field-attributes"><a class="doc-anchor" href="#optional-field-attributes">§</a>Optional field attributes</h3>
<ul>
<li><code>#[diesel(column_name = some_column)]</code>, overrides the column name for
a given field. If not set, the name of the field is used as a column
name. This attribute is required on tuple structs, if
<code>#[diesel(table_name = some_table)]</code> is used, otherwise it’s optional.</li>
<li><code>#[diesel(sql_type = SomeType)]</code>, assumes <code>SomeType</code> as sql type of the
corresponding field. These attributes have precedence over all other
variants to specify the sql type.</li>
<li><code>#[diesel(deserialize_as = Type)]</code>, instead of deserializing directly
into the field type, the implementation will deserialize into <code>Type</code>.
Then <code>Type</code> is converted via <code>.into()</code> into the field type. By default,
this derive will deserialize directly into the field type</li>
<li><code>#[diesel(embed)]</code>, specifies that the current field maps not only
a single database column, but it is a type that implements
<code>QueryableByName</code> on its own</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>If we just want to map a query to our struct, we can use <code>derive</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(QueryableByName, PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}

<span class="kw">let </span>first_user = sql_query(<span class="string">"SELECT * FROM users ORDER BY id LIMIT 1"</span>).get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User {
    id: <span class="number">1</span>,
    name: <span class="string">"Sean"</span>.into(),
};
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
<p>If we want to do additional work during deserialization, we can use
<code>deserialize_as</code> to use a different implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>LowercaseString(String);

<span class="kw">impl </span>Into&lt;String&gt; <span class="kw">for </span>LowercaseString {
    <span class="kw">fn </span>into(<span class="self">self</span>) -&gt; String {
        <span class="self">self</span>.<span class="number">0
    </span>}
}

<span class="kw">impl</span>&lt;DB, ST&gt; FromSql&lt;ST, DB&gt; <span class="kw">for </span>LowercaseString
<span class="kw">where
    </span>DB: Backend,
    String: FromSql&lt;ST, DB&gt;,
{
    <span class="kw">fn </span>from_sql(bytes: DB::RawValue&lt;<span class="lifetime">'_</span>&gt;) -&gt; deserialize::Result&lt;<span class="self">Self</span>&gt; {
        String::from_sql(bytes).map(|s| LowercaseString(s.to_lowercase()))
    }
}

<span class="attr">#[derive(QueryableByName, PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    <span class="attr">#[diesel(deserialize_as = LowercaseString)]
    </span>name: String,
}

<span class="kw">let </span>first_user = sql_query(<span class="string">"SELECT * FROM users ORDER BY id LIMIT 1"</span>).get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User {
    id: <span class="number">1</span>,
    name: <span class="string">"sean"</span>.into(),
};
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
<p>The custom derive generates impls similar to the following one</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}

<span class="kw">impl</span>&lt;DB&gt; QueryableByName&lt;DB&gt; <span class="kw">for </span>User
<span class="kw">where
    </span>DB: Backend,
    i32: FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::id&gt;, DB&gt;,
    String: FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::name&gt;, DB&gt;,
{
    <span class="kw">fn </span>build&lt;<span class="lifetime">'a</span>&gt;(row: <span class="kw-2">&amp;</span><span class="kw">impl </span>NamedRow&lt;<span class="lifetime">'a</span>, DB&gt;) -&gt; deserialize::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>id = NamedRow::get::&lt;diesel::dsl::SqlTypeOf&lt;users::id&gt;, <span class="kw">_</span>&gt;(row, <span class="string">"id"</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>name = NamedRow::get::&lt;diesel::dsl::SqlTypeOf&lt;users::name&gt;, <span class="kw">_</span>&gt;(row, <span class="string">"name"</span>)<span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{ id, name })
    }
}

<span class="kw">let </span>first_user = sql_query(<span class="string">"SELECT * FROM users ORDER BY id LIMIT 1"</span>).get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User {
    id: <span class="number">1</span>,
    name: <span class="string">"Sean"</span>.into(),
};
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div><h2 id="expanded-code"><a class="doc-anchor" href="#expanded-code">§</a>Expanded Code</h2><details>
<summary> Expanded Code </summary>
<h5 id="input"><a class="doc-anchor" href="#input">§</a>Input</h5>
<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(QueryableByName)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}
</code></pre></div><h5 id="expanded-code-1"><a class="doc-anchor" href="#expanded-code-1">§</a>Expanded Code</h5><div class="warning">Expanded code might use diesel internal API's and is only shown for educational purpose</div>
<p>The macro expands the input to the following Rust code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">const _</span>: () = {
    <span class="kw">use </span>diesel;
    <span class="kw">impl</span>&lt;__DB: diesel::backend::Backend&gt; diesel::deserialize::QueryableByName&lt;__DB&gt;
    <span class="kw">for </span>User
    <span class="kw">where
        </span>i32: diesel::deserialize::FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::r#id&gt;, __DB&gt;,
        String: diesel::deserialize::FromSql&lt;
            diesel::dsl::SqlTypeOf&lt;users::r#name&gt;,
            __DB,
        &gt;,
    {
        <span class="kw">fn </span>build&lt;<span class="lifetime">'__a</span>&gt;(
            row: <span class="kw-2">&amp;</span><span class="kw">impl </span>diesel::row::NamedRow&lt;<span class="lifetime">'__a</span>, __DB&gt;,
        ) -&gt; diesel::deserialize::Result&lt;<span class="self">Self</span>&gt; {
            <span class="kw">let </span><span class="kw-2">mut </span>id = {
                <span class="kw">let </span>field = diesel::row::NamedRow::get::&lt;
                    diesel::dsl::SqlTypeOf&lt;users::r#id&gt;,
                    i32,
                &gt;(row, <span class="string">"id"</span>)<span class="question-mark">?</span>;
                &lt;i32 <span class="kw">as </span>std::convert::Into&lt;i32&gt;&gt;::into(field)
            };
            <span class="kw">let </span><span class="kw-2">mut </span>name = {
                <span class="kw">let </span>field = diesel::row::NamedRow::get::&lt;
                    diesel::dsl::SqlTypeOf&lt;users::r#name&gt;,
                    String,
                &gt;(row, <span class="string">"name"</span>)<span class="question-mark">?</span>;
                &lt;String <span class="kw">as </span>std::convert::Into&lt;String&gt;&gt;::into(field)
            };
            diesel::deserialize::Result::Ok(<span class="self">Self </span>{ id: id, name: name })
        }
    }
};</code></pre></div></details></div></details></section></div></main></body></html>