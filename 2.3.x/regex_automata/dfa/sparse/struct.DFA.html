<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A sparse deterministic finite automaton (DFA) with variable sized states."><title>DFA in regex_automata::dfa::sparse - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-bbd8d786.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (39052daf9 2026-01-22)" data-channel="nightly" data-search-js="search-86d08462.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../../../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">DFA</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_<wbr>automata</a><span class="version">0.4.13</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">DFA</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#type-parameters" title="Type parameters">Type parameters</a></li><li><a href="#the-automaton-trait" title="The `Automaton` trait">The <code>Automaton</code> trait</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.always_match" title="always_match">always_match</a></li><li><a href="#method.as_ref" title="as_ref">as_ref</a></li><li><a href="#method.byte_classes" title="byte_classes">byte_classes</a></li><li><a href="#method.from_bytes" title="from_bytes">from_bytes</a></li><li><a href="#method.from_bytes_unchecked" title="from_bytes_unchecked">from_bytes_unchecked</a></li><li><a href="#method.memory_usage" title="memory_usage">memory_usage</a></li><li><a href="#method.never_match" title="never_match">never_match</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.new_many" title="new_many">new_many</a></li><li><a href="#method.set_prefilter" title="set_prefilter">set_prefilter</a></li><li><a href="#method.start_kind" title="start_kind">start_kind</a></li><li><a href="#method.starts_for_each_pattern" title="starts_for_each_pattern">starts_for_each_pattern</a></li><li><a href="#method.to_bytes_big_endian" title="to_bytes_big_endian">to_bytes_big_endian</a></li><li><a href="#method.to_bytes_little_endian" title="to_bytes_little_endian">to_bytes_little_endian</a></li><li><a href="#method.to_bytes_native_endian" title="to_bytes_native_endian">to_bytes_native_endian</a></li><li><a href="#method.to_owned" title="to_owned">to_owned</a></li><li><a href="#method.write_to_big_endian" title="write_to_big_endian">write_to_big_endian</a></li><li><a href="#method.write_to_len" title="write_to_len">write_to_len</a></li><li><a href="#method.write_to_little_endian" title="write_to_little_endian">write_to_little_endian</a></li><li><a href="#method.write_to_native_endian" title="write_to_native_endian">write_to_native_endian</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Automaton-for-DFA%3CT%3E" title="Automaton">Automaton</a></li><li><a href="#impl-Clone-for-DFA%3CT%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-DFA%3CT%3E" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-DFA%3CT%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-DFA%3CT%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-DFA%3CT%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-DFA%3CT%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-DFA%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-DFA%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In regex_<wbr>automata::<wbr>dfa::<wbr>sparse</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">sparse</a></div><h1>Struct <span class="struct">DFA</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/regex_automata/dfa/sparse.rs.html#112-130">Source</a> </span></div><pre class="rust item-decl"><code>pub struct DFA&lt;T&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A sparse deterministic finite automaton (DFA) with variable sized states.</p>
<p>In contrast to a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA">dense::DFA</a>, a sparse DFA uses a more space efficient
representation for its transitions. Consequently, sparse DFAs may use much
less memory than dense DFAs, but this comes at a price. In particular,
reading the more space efficient transitions takes more work, and
consequently, searching using a sparse DFA is typically slower than a dense
DFA.</p>
<p>A sparse DFA can be built using the default configuration via the
<a href="struct.DFA.html#method.new" title="associated function regex_automata::dfa::sparse::DFA::new"><code>DFA::new</code></a> constructor. Otherwise, one can configure various aspects of a
dense DFA via <a href="../dense/struct.Builder.html" title="struct regex_automata::dfa::dense::Builder"><code>dense::Builder</code></a>, and then convert a dense DFA to a sparse
DFA using <a href="../dense/struct.DFA.html#method.to_sparse" title="method regex_automata::dfa::dense::DFA::to_sparse"><code>dense::DFA::to_sparse</code></a>.</p>
<p>In general, a sparse DFA supports all the same search operations as a dense
DFA.</p>
<p>Making the choice between a dense and sparse DFA depends on your specific
work load. If you can sacrifice a bit of search time performance, then a
sparse DFA might be the best choice. In particular, while sparse DFAs are
probably always slower than dense DFAs, you may find that they are easily
fast enough for your purposes!</p>
<h2 id="type-parameters"><a class="doc-anchor" href="#type-parameters">§</a>Type parameters</h2>
<p>A <code>DFA</code> has one type parameter, <code>T</code>, which is used to represent the parts
of a sparse DFA. <code>T</code> is typically a <code>Vec&lt;u8&gt;</code> or a <code>&amp;[u8]</code>.</p>
<h2 id="the-automaton-trait"><a class="doc-anchor" href="#the-automaton-trait">§</a>The <code>Automaton</code> trait</h2>
<p>This type implements the <a href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton"><code>Automaton</code></a> trait, which means it can be used
for searching. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="kw">let </span>dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CVec%3Cu8%3E%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#133-184">Source</a><a href="#impl-DFA%3CVec%3Cu8%3E%3E" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#153-157">Source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expression using a default configuration and
return the corresponding sparse DFA.</p>
<p>If you want a non-default configuration, then use the
<a href="../dense/struct.Builder.html" title="struct regex_automata::dfa::dense::Builder"><code>dense::Builder</code></a> to set your own configuration, and then call
<a href="../dense/struct.DFA.html#method.to_sparse" title="method regex_automata::dfa::dense::DFA::to_sparse"><code>dense::DFA::to_sparse</code></a> to create a sparse DFA.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse}, HalfMatch, Input};

<span class="kw">let </span>dfa = sparse::DFA::new(<span class="string">"foo[0-9]+bar"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">11</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345bar"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.new_many" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#177-183">Source</a><h4 class="code-header">pub fn <a href="#method.new_many" class="fn">new_many</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;(
    patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[P]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the given regular expressions using a default configuration and
return the corresponding multi-DFA.</p>
<p>If you want a non-default configuration, then use the
<a href="../dense/struct.Builder.html" title="struct regex_automata::dfa::dense::Builder"><code>dense::Builder</code></a> to set your own configuration, and then call
<a href="../dense/struct.DFA.html#method.to_sparse" title="method regex_automata::dfa::dense::DFA::to_sparse"><code>dense::DFA::to_sparse</code></a> to create a sparse DFA.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse}, HalfMatch, Input};

<span class="kw">let </span>dfa = sparse::DFA::new_many(<span class="kw-2">&amp;</span>[<span class="string">"[0-9]+"</span>, <span class="string">"[a-z]+"</span>])<span class="question-mark">?</span>;
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">1</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345bar"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CVec%3Cu8%3E%3E-1" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#187-405">Source</a><a href="#impl-DFA%3CVec%3Cu8%3E%3E-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.always_match" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#205-207">Source</a><h4 class="code-header">pub fn <a href="#method.always_match" class="fn">always_match</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new DFA that matches every input.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse},
    HalfMatch, Input,
};

<span class="kw">let </span>dfa = sparse::DFA::always_match()<span class="question-mark">?</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">""</span>))<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.never_match" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#221-223">Source</a><h4 class="code-header">pub fn <a href="#method.never_match" class="fn">never_match</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;, <a class="struct" href="../dense/struct.BuildError.html" title="struct regex_automata::dfa::dense::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new sparse DFA that never matches any input.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse}, Input};

<span class="kw">let </span>dfa = sparse::DFA::never_match()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">""</span>))<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#407-489">Source</a><a href="#impl-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#410-419">Source</a><h4 class="code-header">pub fn <a href="#method.as_ref" class="fn">as_ref</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Cheaply return a borrowed version of this sparse DFA. Specifically, the
DFA returned always uses <code>&amp;[u8]</code> for its transitions.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#427-436">Source</a><h4 class="code-header">pub fn <a href="#method.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Return an owned version of this sparse DFA. Specifically, the DFA
returned always uses <code>Vec&lt;u8&gt;</code> for its transitions.</p>
<p>Effectively, this returns a sparse DFA whose transitions live on the
heap.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.start_kind" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#445-447">Source</a><h4 class="code-header">pub fn <a href="#method.start_kind" class="fn">start_kind</a>(&amp;self) -&gt; <a class="enum" href="../enum.StartKind.html" title="enum regex_automata::dfa::StartKind">StartKind</a></h4></section></summary><div class="docblock"><p>Returns the starting state configuration for this DFA.</p>
<p>The default is <a href="../enum.StartKind.html#variant.Both" title="variant regex_automata::dfa::StartKind::Both"><code>StartKind::Both</code></a>, which means the DFA supports both
unanchored and anchored searches. However, this can generally lead to
bigger DFAs. Therefore, a DFA might be compiled with support for just
unanchored or anchored searches. In that case, running a search with
an unsupported configuration will panic.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_for_each_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#458-460">Source</a><h4 class="code-header">pub fn <a href="#method.starts_for_each_pattern" class="fn">starts_for_each_pattern</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true only if this DFA has starting states for each pattern.</p>
<p>When a DFA has starting states for each pattern, then a search with the
DFA can be configured to only look for anchored matches of a specific
pattern. Specifically, APIs like <a href="../trait.Automaton.html#method.try_search_fwd" title="method regex_automata::dfa::Automaton::try_search_fwd"><code>Automaton::try_search_fwd</code></a> can
accept a <a href="../../enum.Anchored.html#variant.Pattern" title="variant regex_automata::Anchored::Pattern"><code>Anchored::Pattern</code></a> if and only if this method returns true.
Otherwise, an error will be returned.</p>
<p>Note that if the DFA is empty, this always returns false.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_classes" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#475-477">Source</a><h4 class="code-header">pub fn <a href="#method.byte_classes" class="fn">byte_classes</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct regex_automata::util::alphabet::ByteClasses">ByteClasses</a></h4></section></summary><div class="docblock"><p>Returns the equivalence classes that make up the alphabet for this DFA.</p>
<p>Unless <a href="../dense/struct.Config.html#method.byte_classes" title="method regex_automata::dfa::dense::Config::byte_classes"><code>dense::Config::byte_classes</code></a> was disabled, it is possible
that multiple distinct bytes are grouped into the same equivalence
class if it is impossible for them to discriminate between a match and
a non-match. This has the effect of reducing the overall alphabet size
and in turn potentially substantially reducing the size of the DFA’s
transition table.</p>
<p>The downside of using equivalence classes like this is that every state
transition will automatically use this map to convert an arbitrary
byte to its corresponding equivalence class. In practice this has a
negligible impact on performance.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#486-488">Source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the memory usage, in bytes, of this DFA.</p>
<p>The memory usage is computed based on the number of bytes used to
represent this DFA.</p>
<p>This does <strong>not</strong> include the stack size used up by this DFA. To
compute that, use <code>std::mem::size_of::&lt;sparse::DFA&gt;()</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E-1" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#493-849">Source</a><a href="#impl-DFA%3CT%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3><div class="docblock"><p>Routines for converting a sparse DFA to other representations, such as raw
bytes suitable for persistent storage.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_bytes_little_endian" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#531-533">Source</a><h4 class="code-header">pub fn <a href="#method.to_bytes_little_endian" class="fn">to_bytes_little_endian</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to a <code>Vec&lt;u8&gt;</code> in little endian
format.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Note that unlike a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>’s serialization methods, this does
not add any initial padding to the returned bytes. Padding isn’t
required for sparse DFAs since they have no alignment requirements.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>This example shows how to serialize and deserialize a DFA:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// N.B. We use native endianness here to make the example work, but
// using to_bytes_little_endian would work on a little endian target.
</span><span class="kw">let </span>buf = original_dfa.to_bytes_native_endian();
<span class="comment">// Even if buf has initial padding, DFA::from_bytes will automatically
// ignore it.
</span><span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf)<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_bytes_big_endian" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#572-574">Source</a><h4 class="code-header">pub fn <a href="#method.to_bytes_big_endian" class="fn">to_bytes_big_endian</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to a <code>Vec&lt;u8&gt;</code> in big endian
format.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Note that unlike a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>’s serialization methods, this does
not add any initial padding to the returned bytes. Padding isn’t
required for sparse DFAs since they have no alignment requirements.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>This example shows how to serialize and deserialize a DFA:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// N.B. We use native endianness here to make the example work, but
// using to_bytes_big_endian would work on a big endian target.
</span><span class="kw">let </span>buf = original_dfa.to_bytes_native_endian();
<span class="comment">// Even if buf has initial padding, DFA::from_bytes will automatically
// ignore it.
</span><span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf)<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.to_bytes_native_endian" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#620-622">Source</a><h4 class="code-header">pub fn <a href="#method.to_bytes_native_endian" class="fn">to_bytes_native_endian</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt; <a href="#" class="tooltip" data-notable-ty="Vec&lt;u8&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to a <code>Vec&lt;u8&gt;</code> in native endian
format.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Note that unlike a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>’s serialization methods, this does
not add any initial padding to the returned bytes. Padding isn’t
required for sparse DFAs since they have no alignment requirements.</p>
<p>Generally speaking, native endian format should only be used when
you know that the target you’re compiling the DFA for matches the
endianness of the target on which you’re compiling DFA. For example,
if serialization and deserialization happen in the same process or on
the same machine. Otherwise, when serializing a DFA for use in a
portable environment, you’ll almost certainly want to serialize <em>both</em>
a little endian and a big endian version and then load the correct one
based on the target’s configuration.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>This example shows how to serialize and deserialize a DFA:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>buf = original_dfa.to_bytes_native_endian();
<span class="comment">// Even if buf has initial padding, DFA::from_bytes will automatically
// ignore it.
</span><span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf)<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_little_endian" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#676-681">Source</a><h4 class="code-header">pub fn <a href="#method.write_to_little_endian" class="fn">write_to_little_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="../../util/wire/struct.SerializeError.html" title="struct regex_automata::util::wire::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in little endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="comment">// N.B. We use native endianness here to make the example work, but
// using write_to_little_endian would work on a little endian target.
</span><span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_big_endian" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#723-728">Source</a><h4 class="code-header">pub fn <a href="#method.write_to_big_endian" class="fn">write_to_big_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="../../util/wire/struct.SerializeError.html" title="struct regex_automata::util::wire::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in big endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="comment">// N.B. We use native endianness here to make the example work, but
// using write_to_big_endian would work on a big endian target.
</span><span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_native_endian" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#777-782">Source</a><h4 class="code-header">pub fn <a href="#method.write_to_native_endian" class="fn">write_to_native_endian</a>(
    &amp;self,
    dst: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="../../util/wire/struct.SerializeError.html" title="struct regex_automata::util::wire::SerializeError">SerializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Serialize this DFA as raw bytes to the given slice, in native endian
format. Upon success, the total number of bytes written to <code>dst</code> is
returned.</p>
<p>The written bytes are guaranteed to be deserialized correctly and
without errors in a semver compatible release of this crate by a
<code>DFA</code>’s deserialization APIs (assuming all other criteria for the
deserialization APIs has been satisfied):</p>
<ul>
<li><a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a></li>
<li><a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a></li>
</ul>
<p>Generally speaking, native endian format should only be used when
you know that the target you’re compiling the DFA for matches the
endianness of the target on which you’re compiling DFA. For example,
if serialization and deserialization happen in the same process or on
the same machine. Otherwise, when serializing a DFA for use in a
portable environment, you’ll almost certainly want to serialize <em>both</em>
a little endian and a big endian version and then load the correct one
based on the target’s configuration.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This returns an error if the given destination slice is not big enough
to contain the full serialized DFA. If an error occurs, then nothing
is written to <code>dst</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<p>This example shows how to serialize and deserialize a DFA without
dynamic memory allocation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// Create a 4KB buffer on the stack to store our serialized DFA.
</span><span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0u8</span>; <span class="number">4 </span>* (<span class="number">1</span>&lt;&lt;<span class="number">10</span>)];
<span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.write_to_len" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#838-848">Source</a><h4 class="code-header">pub fn <a href="#method.write_to_len" class="fn">write_to_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the total number of bytes required to serialize this DFA.</p>
<p>This is useful for determining the size of the buffer required to pass
to one of the serialization routines:</p>
<ul>
<li><a href="struct.DFA.html#method.write_to_little_endian" title="method regex_automata::dfa::sparse::DFA::write_to_little_endian"><code>DFA::write_to_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_big_endian" title="method regex_automata::dfa::sparse::DFA::write_to_big_endian"><code>DFA::write_to_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_native_endian" title="method regex_automata::dfa::sparse::DFA::write_to_native_endian"><code>DFA::write_to_native_endian</code></a></li>
</ul>
<p>Passing a buffer smaller than the size returned by this method will
result in a serialization error.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<p>This example shows how to dynamically allocate enough room to serialize
a sparse DFA.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="comment">// Compile our original DFA.
</span><span class="kw">let </span>original_dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="macro">vec!</span>[<span class="number">0</span>; original_dfa.write_to_len()];
<span class="kw">let </span>written = original_dfa.write_to_native_endian(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>buf[..written])<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3C%26%5Bu8%5D%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#851-1073">Source</a><a href="#impl-DFA%3C%26%5Bu8%5D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_bytes" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#985-997">Source</a><h4 class="code-header">pub fn <a href="#method.from_bytes" class="fn">from_bytes</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>), <a class="struct" href="../../util/wire/struct.DeserializeError.html" title="struct regex_automata::util::wire::DeserializeError">DeserializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Safely deserialize a sparse DFA with a specific state identifier
representation. Upon success, this returns both the deserialized DFA
and the number of bytes read from the given slice. Namely, the contents
of the slice beyond the DFA are not read.</p>
<p>Deserializing a DFA using this routine will never allocate heap memory.
For safety purposes, the DFA’s transitions will be verified such that
every transition points to a valid state. If this verification is too
costly, then a <a href="struct.DFA.html#method.from_bytes_unchecked" title="associated function regex_automata::dfa::sparse::DFA::from_bytes_unchecked"><code>DFA::from_bytes_unchecked</code></a> API is provided, which
will always execute in constant time.</p>
<p>The bytes given must be generated by one of the serialization APIs
of a <code>DFA</code> using a semver compatible release of this crate. Those
include:</p>
<ul>
<li><a href="struct.DFA.html#method.to_bytes_little_endian" title="method regex_automata::dfa::sparse::DFA::to_bytes_little_endian"><code>DFA::to_bytes_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.to_bytes_big_endian" title="method regex_automata::dfa::sparse::DFA::to_bytes_big_endian"><code>DFA::to_bytes_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.to_bytes_native_endian" title="method regex_automata::dfa::sparse::DFA::to_bytes_native_endian"><code>DFA::to_bytes_native_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_little_endian" title="method regex_automata::dfa::sparse::DFA::write_to_little_endian"><code>DFA::write_to_little_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_big_endian" title="method regex_automata::dfa::sparse::DFA::write_to_big_endian"><code>DFA::write_to_big_endian</code></a></li>
<li><a href="struct.DFA.html#method.write_to_native_endian" title="method regex_automata::dfa::sparse::DFA::write_to_native_endian"><code>DFA::write_to_native_endian</code></a></li>
</ul>
<p>The <code>to_bytes</code> methods allocate and return a <code>Vec&lt;u8&gt;</code> for you. The
<code>write_to</code> methods do not allocate and write to an existing slice
(which may be on the stack). Since deserialization always uses the
native endianness of the target platform, the serialization API you use
should match the endianness of the target platform. (It’s often a good
idea to generate serialized DFAs for both forms of endianness and then
load the correct one based on endianness.)</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>Generally speaking, it’s easier to state the conditions in which an
error is <em>not</em> returned. All of the following must be true:</p>
<ul>
<li>The bytes given must be produced by one of the serialization APIs
on this DFA, as mentioned above.</li>
<li>The endianness of the target platform matches the endianness used to
serialized the provided DFA.</li>
</ul>
<p>If any of the above are not true, then an error will be returned.</p>
<p>Note that unlike deserializing a <a href="../dense/struct.DFA.html" title="struct regex_automata::dfa::dense::DFA"><code>dense::DFA</code></a>, deserializing a sparse
DFA has no alignment requirements. That is, an alignment of <code>1</code> is
valid.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This routine will never panic for any input.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<p>This example shows how to serialize a DFA to raw bytes, deserialize it
and then use it for searching.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="kw">let </span>initial = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>bytes = initial.to_bytes_native_endian();
<span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = DFA::from_bytes(<span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>.<span class="number">0</span>;

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div><h5 id="example-loading-a-dfa-from-static-memory"><a class="doc-anchor" href="#example-loading-a-dfa-from-static-memory">§</a>Example: loading a DFA from static memory</h5>
<p>One use case this library supports is the ability to serialize a
DFA to disk and then use <code>include_bytes!</code> to store it in a compiled
Rust program. Those bytes can then be cheaply deserialized into a
<code>DFA</code> structure at runtime and used for searching without having to
re-compile the DFA (which can be quite costly).</p>
<p>We can show this in two parts. The first part is serializing the DFA to
a file:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::dfa::sparse::DFA;

<span class="kw">let </span>dfa = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;

<span class="comment">// Write a big endian serialized version of this DFA to a file.
</span><span class="kw">let </span>bytes = dfa.to_bytes_big_endian();
std::fs::write(<span class="string">"foo.bigendian.dfa"</span>, <span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>;

<span class="comment">// Do it again, but this time for little endian.
</span><span class="kw">let </span>bytes = dfa.to_bytes_little_endian();
std::fs::write(<span class="string">"foo.littleendian.dfa"</span>, <span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>;</code></pre></div>
<p>And now the second part is embedding the DFA into the compiled program
and deserializing it at runtime on first use. We use conditional
compilation to choose the correct endianness. We do not need to employ
any special tricks to ensure a proper alignment, since a sparse DFA has
no alignment requirements.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    dfa::{Automaton, sparse::DFA},
    util::lazy::Lazy,
    HalfMatch, Input,
};

<span class="comment">// This crate provides its own "lazy" type, kind of like
// lazy_static! or once_cell::sync::Lazy. But it works in no-alloc
// no-std environments and let's us write this using completely
// safe code.
</span><span class="kw">static </span>RE: Lazy&lt;DFA&lt;<span class="kw-2">&amp;</span><span class="lifetime">'static </span>[u8]&gt;&gt; = Lazy::new(|| {
    <span class="attr">#[cfg(target_endian = <span class="string">"big"</span>)]
    </span><span class="kw">static </span>BYTES: <span class="kw-2">&amp;</span>[u8] = <span class="macro">include_bytes!</span>(<span class="string">"foo.bigendian.dfa"</span>);
    <span class="attr">#[cfg(target_endian = <span class="string">"little"</span>)]
    </span><span class="kw">static </span>BYTES: <span class="kw-2">&amp;</span>[u8] = <span class="macro">include_bytes!</span>(<span class="string">"foo.littleendian.dfa"</span>);

    <span class="kw">let </span>(dfa, <span class="kw">_</span>) = DFA::from_bytes(BYTES)
        .expect(<span class="string">"serialized DFA should be valid"</span>);
    dfa
});

<span class="kw">let </span>expected = <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>)));
<span class="macro">assert_eq!</span>(expected, RE.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>)));</code></pre></div>
<p>Alternatively, consider using
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a>
or
<a href="https://crates.io/crates/once_cell"><code>once_cell</code></a>,
which will guarantee safety for you.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes_unchecked" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1037-1072">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_bytes_unchecked" class="fn">from_bytes_unchecked</a>(
    slice: &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>), <a class="struct" href="../../util/wire/struct.DeserializeError.html" title="struct regex_automata::util::wire::DeserializeError">DeserializeError</a>&gt;</h4></section></summary><div class="docblock"><p>Deserialize a DFA with a specific state identifier representation in
constant time by omitting the verification of the validity of the
sparse transitions.</p>
<p>This is just like <a href="struct.DFA.html#method.from_bytes" title="associated function regex_automata::dfa::sparse::DFA::from_bytes"><code>DFA::from_bytes</code></a>, except it can potentially return
a DFA that exhibits undefined behavior if its transitions contains
invalid state identifiers.</p>
<p>This routine is useful if you need to deserialize a DFA cheaply and
cannot afford the transition validation performed by <code>from_bytes</code>.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>This routine is not safe because it permits callers to provide
arbitrary transitions with possibly incorrect state identifiers. While
the various serialization routines will never return an incorrect
DFA, there is no guarantee that the bytes provided here are correct.
While <code>from_bytes_unchecked</code> will still do several forms of basic
validation, this routine does not check that the transitions themselves
are correct. Given an incorrect transition table, it is possible for
the search routines to access out-of-bounds memory because of explicit
bounds check elision.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{dfa::{Automaton, sparse::DFA}, HalfMatch, Input};

<span class="kw">let </span>initial = DFA::new(<span class="string">"foo[0-9]+"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>bytes = initial.to_bytes_native_endian();
<span class="comment">// SAFETY: This is guaranteed to be safe since the bytes given come
// directly from a compatible serialization routine.
</span><span class="kw">let </span>dfa: DFA&lt;<span class="kw-2">&amp;</span>[u8]&gt; = <span class="kw">unsafe </span>{ DFA::from_bytes_unchecked(<span class="kw-2">&amp;</span>bytes)<span class="question-mark">?</span>.<span class="number">0 </span>};

<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(HalfMatch::must(<span class="number">0</span>, <span class="number">8</span>));
<span class="macro">assert_eq!</span>(expected, dfa.try_search_fwd(<span class="kw-2">&amp;</span>Input::new(<span class="string">"foo12345"</span>))<span class="question-mark">?</span>);</code></pre></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DFA%3CT%3E-2" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1076-1086">Source</a><a href="#impl-DFA%3CT%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3><div class="docblock"><p>Other routines that work for all <code>T</code>.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.set_prefilter" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1083-1085">Source</a><h4 class="code-header">pub fn <a href="#method.set_prefilter" class="fn">set_prefilter</a>(&amp;mut self, prefilter: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../util/prefilter/struct.Prefilter.html" title="struct regex_automata::util::prefilter::Prefilter">Prefilter</a>&gt;)</h4></section></summary><div class="docblock"><p>Set or unset the prefilter attached to this DFA.</p>
<p>This is useful when one has deserialized a DFA from <code>&amp;[u8]</code>.
Deserialization does not currently include prefilters, so if you
want prefilter acceleration, you’ll need to rebuild it and attach
it here.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Automaton-for-DFA%3CT%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1119-1246">Source</a><a href="#impl-Automaton-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="trait" href="../trait.Automaton.html" title="trait regex_automata::dfa::Automaton">Automaton</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_special_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1121-1123">Source</a><a href="#method.is_special_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_special_state" class="fn">is_special_state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
“special” state. A special state is one or more of the following:
a dead state, a quit state, a match state, a start state or an
accelerated state. <a href="../trait.Automaton.html#tymethod.is_special_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_dead_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1126-1128">Source</a><a href="#method.is_dead_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_dead_state" class="fn">is_dead_state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave. That
is, every transition on a dead state by definition leads back to the
same dead state. <a href="../trait.Automaton.html#tymethod.is_dead_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_quit_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1131-1133">Source</a><a href="#method.is_quit_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_quit_state" class="fn">is_quit_state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a quit
state. A quit state is like a dead state (it has no transitions other
than to itself), except it indicates that the DFA failed to complete
the search. When this occurs, callers can neither accept or reject that
a match occurred. <a href="../trait.Automaton.html#tymethod.is_quit_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_match_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1136-1138">Source</a><a href="#method.is_match_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_match_state" class="fn">is_match_state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to a
match state. A match state is also referred to as a “final” state and
indicates that a match has been found. <a href="../trait.Automaton.html#tymethod.is_match_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_start_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1141-1143">Source</a><a href="#method.is_start_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_start_state" class="fn">is_start_state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true only if the given identifier corresponds to a start
state <a href="../trait.Automaton.html#tymethod.is_start_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_accel_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1146-1148">Source</a><a href="#method.is_accel_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_accel_state" class="fn">is_accel_state</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if the given identifier corresponds to an
accelerated state. <a href="../trait.Automaton.html#tymethod.is_accel_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1153-1156">Source</a><a href="#method.next_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.next_state" class="fn">next_state</a>(&amp;self, current: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></h4></section></summary><div class='docblock'>Transitions from the current state to the next state, given the next
byte of input. <a href="../trait.Automaton.html#tymethod.next_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state_unchecked" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1159-1165">Source</a><a href="#method.next_state_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../trait.Automaton.html#tymethod.next_state_unchecked" class="fn">next_state_unchecked</a>(&amp;self, current: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></h4></section></summary><div class='docblock'>Transitions from the current state to the next state, given the next
byte of input. <a href="../trait.Automaton.html#tymethod.next_state_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_eoi_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1168-1170">Source</a><a href="#method.next_eoi_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.next_eoi_state" class="fn">next_eoi_state</a>(&amp;self, current: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></h4></section></summary><div class='docblock'>Transitions from the current state to the next state for the special
EOI symbol. <a href="../trait.Automaton.html#tymethod.next_eoi_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_len" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1173-1175">Source</a><a href="#method.pattern_len" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.pattern_len" class="fn">pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns compiled into this DFA. <a href="../trait.Automaton.html#tymethod.pattern_len">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_len" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1178-1180">Source</a><a href="#method.match_len" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.match_len" class="fn">match_len</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns that match in this state. <a href="../trait.Automaton.html#tymethod.match_len">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_pattern" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1183-1193">Source</a><a href="#method.match_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, match_index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></h4></section></summary><div class='docblock'>Returns the pattern ID corresponding to the given match index in the
given state. <a href="../trait.Automaton.html#tymethod.match_pattern">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.has_empty" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1196-1198">Source</a><a href="#method.has_empty" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.has_empty" class="fn">has_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if this automaton can match the empty string.
When it returns false, all possible matches are guaranteed to have a
non-zero length. <a href="../trait.Automaton.html#tymethod.has_empty">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_utf8" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1201-1203">Source</a><a href="#method.is_utf8" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_utf8" class="fn">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Whether UTF-8 mode is enabled for this DFA or not. <a href="../trait.Automaton.html#tymethod.is_utf8">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_always_start_anchored" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1206-1208">Source</a><a href="#method.is_always_start_anchored" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.is_always_start_anchored" class="fn">is_always_start_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if and only if this DFA is limited to returning matches
whose start position is <code>0</code>. <a href="../trait.Automaton.html#tymethod.is_always_start_anchored">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1211-1226">Source</a><a href="#method.start_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#tymethod.start_state" class="fn">start_state</a>(&amp;self, config: &amp;<a class="struct" href="../../util/start/struct.Config.html" title="struct regex_automata::util::start::Config">Config</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="enum" href="../enum.StartError.html" title="enum regex_automata::dfa::StartError">StartError</a>&gt;</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA for the given starting
configuration. <a href="../trait.Automaton.html#tymethod.start_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.universal_start_state" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1229-1235">Source</a><a href="#method.universal_start_state" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.universal_start_state" class="fn">universal_start_state</a>(&amp;self, mode: <a class="enum" href="../../enum.Anchored.html" title="enum regex_automata::Anchored">Anchored</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</h4></section></summary><div class='docblock'>If this DFA has a universal starting state for the given anchor mode
and the DFA supports universal starting states, then this returns that
state’s identifier. <a href="../trait.Automaton.html#method.universal_start_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.accelerator" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1238-1240">Source</a><a href="#method.accelerator" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.accelerator" class="fn">accelerator</a>(&amp;self, id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class='docblock'>Return a slice of bytes to accelerate for the given state, if possible. <a href="../trait.Automaton.html#method.accelerator">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.get_prefilter" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1243-1245">Source</a><a href="#method.get_prefilter" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.get_prefilter" class="fn">get_prefilter</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../../util/prefilter/struct.Prefilter.html" title="struct regex_automata::util::prefilter::Prefilter">Prefilter</a>&gt;</h4></section></summary><div class='docblock'>Returns the prefilter associated with a DFA, if one exists. <a href="../trait.Automaton.html#method.get_prefilter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state_forward" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#281-298">Source</a><a href="#method.start_state_forward" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.start_state_forward" class="fn">start_state_forward</a>(&amp;self, input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA when executing a forward
search. <a href="../trait.Automaton.html#method.start_state_forward">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.start_state_reverse" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#315-329">Source</a><a href="#method.start_state_reverse" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.start_state_reverse" class="fn">start_state_reverse</a>(&amp;self, input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Return the ID of the start state for this DFA when executing a reverse
search. <a href="../trait.Automaton.html#method.start_state_reverse">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_search_fwd" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1297-1325">Source</a><a href="#method.try_search_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.try_search_fwd" class="fn">try_search_fwd</a>(
    &amp;self,
    input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a forward search and returns the end position of the leftmost
match that is found. If no match exists, then <code>None</code> is returned. <a href="../trait.Automaton.html#method.try_search_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_search_rev" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1486-1500">Source</a><a href="#method.try_search_rev" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.try_search_rev" class="fn">try_search_rev</a>(
    &amp;self,
    input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.HalfMatch.html" title="struct regex_automata::HalfMatch">HalfMatch</a>&gt;, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse search and returns the start of the position of the
leftmost match that is found. If no match exists, then <code>None</code> is
returned. <a href="../trait.Automaton.html#method.try_search_rev">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_search_overlapping_fwd" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1582-1600">Source</a><a href="#method.try_search_overlapping_fwd" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.try_search_overlapping_fwd" class="fn">try_search_overlapping_fwd</a>(
    &amp;self,
    input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes an overlapping forward search. Matches, if one exists, can be
obtained via the <a href="../struct.OverlappingState.html#method.get_match" title="method regex_automata::dfa::OverlappingState::get_match"><code>OverlappingState::get_match</code></a> method. <a href="../trait.Automaton.html#method.try_search_overlapping_fwd">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_search_overlapping_rev" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1719-1737">Source</a><a href="#method.try_search_overlapping_rev" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.try_search_overlapping_rev" class="fn">try_search_overlapping_rev</a>(
    &amp;self,
    input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
    state: &amp;mut <a class="struct" href="../struct.OverlappingState.html" title="struct regex_automata::dfa::OverlappingState">OverlappingState</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a reverse overlapping forward search. Matches, if one exists,
can be obtained via the <a href="../struct.OverlappingState.html#method.get_match" title="method regex_automata::dfa::OverlappingState::get_match"><code>OverlappingState::get_match</code></a> method. <a href="../trait.Automaton.html#method.try_search_overlapping_rev">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_which_overlapping_matches" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/automaton.rs.html#1808-1826">Source</a><a href="#method.try_which_overlapping_matches" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Automaton.html#method.try_which_overlapping_matches" class="fn">try_which_overlapping_matches</a>(
    &amp;self,
    input: &amp;<a class="struct" href="../../struct.Input.html" title="struct regex_automata::Input">Input</a>&lt;'_&gt;,
    patset: &amp;mut <a class="struct" href="../../struct.PatternSet.html" title="struct regex_automata::PatternSet">PatternSet</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../struct.MatchError.html" title="struct regex_automata::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Writes the set of patterns that match anywhere in the given search
configuration to <code>patset</code>. If multiple patterns match at the same
position and the underlying DFA supports overlapping matches, then all
matching patterns are written to the given set. <a href="../trait.Automaton.html#method.try_which_overlapping_matches">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-DFA%3CT%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#111">Source</a><a href="#impl-Clone-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#111">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#245-247">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-DFA%3CT%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1088-1116">Source</a><a href="#impl-Debug-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/sparse.rs.html#1089-1115">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-DFA%3CT%3E" class="impl"><a href="#impl-Freeze-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-DFA%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-DFA%3CT%3E" class="impl"><a href="#impl-Send-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-DFA%3CT%3E" class="impl"><a href="#impl-Sync-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-DFA%3CT%3E" class="impl"><a href="#impl-Unpin-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-DFA%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-DFA%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::sparse::DFA">DFA</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#547">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#549">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#72-74">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#76">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#77">Source</a><a href="#method.to_owned-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div>","Vec<u8>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>"}</script></section></div></main></body></html>