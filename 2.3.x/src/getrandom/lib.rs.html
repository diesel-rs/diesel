<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/getrandom-0.3.4/src/lib.rs`."><title>lib.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="getrandom" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (6501e64fc 2025-10-23)" data-channel="nightly" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../../static.files/src-script-813739b1.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://www.rust-lang.org/favicon.ico"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">getrandom/</div>lib.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="comment">// Overwrite links to crate items with intra-crate links
<a href=#2 id=2 data-nosnippet>2</a></span><span class="doccomment">//! [`Error::UNEXPECTED`]: Error::UNEXPECTED
<a href=#3 id=3 data-nosnippet>3</a>//! [`fill_uninit`]: fill_uninit
<a href=#4 id=4 data-nosnippet>4</a>
<a href=#5 id=5 data-nosnippet>5</a></span><span class="attr"><a href="#99">#![no_std]
<a href=#6 id=6 data-nosnippet>6</a>#![doc(
<a href=#7 id=7 data-nosnippet>7</a>    html_logo_url = </a><span class="string">"https://www.rust-lang.org/logos/rust-logo-128x128-blk.png"</span><a href="#99">,
<a href=#8 id=8 data-nosnippet>8</a>    html_favicon_url = </a><span class="string">"https://www.rust-lang.org/favicon.ico"
<a href=#9 id=9 data-nosnippet>9</a></span><a href="#99">)]
<a href=#10 id=10 data-nosnippet>10</a><span class=expansion><input id=expand-10 tabindex=0 type=checkbox aria-label="Collapse/expand macro" title=""Collapse/expand macro">#![doc = </a><span class=expanded><span class="string">"# getrandom: system\'s random number generator\n\n[![Build Status]][GitHub Actions]\n[![Crate]][crates.io]\n[![Documentation]][docs.rs]\n[![Dependency Status]][deps.rs]\n[![Downloads]][crates.io]\n[![License]][LICENSE-MIT]\n\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\n\nIt is assumed that the system always provides high-quality, cryptographically secure random\ndata, ideally backed by hardware entropy sources. This crate derives its name from\nthe Linux `getrandom` syscall but is cross-platform, roughly supporting the same set\nof platforms as Rust\'s `std` library.\n\nThis is a low-level API. Most users should prefer using a higher-level random-number\nlibrary like [`rand`].\n\n[`rand`]: https://crates.io/crates/rand\n\n## Usage\n\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n\n```toml\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n\n```rust\nfn get_random_u128() -&gt; Result&lt;u128, getrandom::Error&gt; {\n    let mut buf = [0u8; 16];\n    getrandom::fill(&amp;mut buf)?;\n    Ok(u128::from_ne_bytes(buf))\n}\n```\n\n## Supported targets\n\n| Target             | Target Triple      | Implementation\n| ------------------ | ------------------ | --------------\n| Linux, Android     | `*\u{2011}linux\u{2011}*`        | [`getrandom`][1] system call if available, otherwise [`/dev/urandom`][2] after successfully polling `/dev/random`\n| Windows 10+        | `*\u{2011}windows\u{2011}*`      | [`ProcessPrng`] on Rust 1.78+, [`RtlGenRandom`] otherwise\n| Windows 7, 8       | `*-win7\u{2011}windows\u{2011}*` | [`RtlGenRandom`]\n| macOS              | `*\u{2011}apple\u{2011}darwin`   | [`getentropy`][3]\n| iOS, tvOS, watchOS | `*\u{2011}apple\u{2011}{ios,tvos,watchos}` | [`CCRandomGenerateBytes`]\n| FreeBSD            | `*\u{2011}freebsd`        | [`getrandom`][5]\n| OpenBSD            | `*\u{2011}openbsd`        | [`getentropy`][7]\n| NetBSD             | `*\u{2011}netbsd`         | [`getrandom`][16] if available, otherwise [`kern.arandom`][8]\n| Dragonfly\u{a0}BSD      | `*\u{2011}dragonfly`      | [`getrandom`][9]\n| Solaris            | `*\u{2011}solaris`        | [`getrandom`][11] with `GRND_RANDOM`\n| illumos            | `*\u{2011}illumos`        | [`getrandom`][12]\n| Fuchsia\u{a0}OS         | `*\u{2011}fuchsia`        | [`cprng_draw`]\n| Redox              | `*\u{2011}redox`          | `/dev/urandom`\n| Haiku              | `*\u{2011}haiku`          | `/dev/urandom` (identical to `/dev/random`)\n| Hermit             | `*-hermit`         | [`sys_read_entropy`]\n| Hurd               | `*-hurd-*`         | [`getrandom`][17]\n| SGX                | `x86_64\u{2011}*\u{2011}sgx`     | [`RDRAND`]\n| VxWorks            | `*\u{2011}wrs\u{2011}vxworks\u{2011}*`  | `randABytes` after checking entropy pool initialization with `randSecure`\n| Emscripten         | `*\u{2011}emscripten`     | [`getentropy`][13]\n| WASI 0.1           | `wasm32\u{2011}wasip1`    | [`random_get`]\n| WASI 0.2           | `wasm32\u{2011}wasip2`    | [`get-random-u64`]\n| SOLID              | `*-kmc-solid_*`    | `SOLID_RNG_SampleRandomBytes`\n| Nintendo 3DS       | `*-nintendo-3ds`   | [`getrandom`][18]\n| ESP-IDF            | `*\u{2011}espidf`         | [`esp_fill_random`] WARNING: see \"Early Boot\" section below\n| PS Vita            | `*-vita-*`         | [`getentropy`][19]\n| QNX Neutrino       | `*\u{2011}nto-qnx*`       | [`/dev/urandom`][14] (identical to `/dev/random`)\n| AIX                | `*-ibm-aix`        | [`/dev/urandom`][15]\n| Cygwin             | `*-cygwin`         | [`getrandom`][20] (based on [`RtlGenRandom`])\n\nPull Requests that add support for new targets to `getrandom` are always welcome.\n\n### Opt-in backends\n\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source\nof randomness based on their specific needs:\n\n| Backend name      | Target               | Target Triple            | Implementation\n| ----------------- | -------------------- | ------------------------ | --------------\n| `linux_getrandom` | Linux, Android       | `*\u{2011}linux\u{2011}*`              | [`getrandom`][1] system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n| `linux_raw`       | Linux, Android       | `*\u{2011}linux\u{2011}*`              | Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.\n| `rdrand`          | x86, x86-64          | `x86_64-*`, `i686-*`     | [`RDRAND`] instruction\n| `rndr`            | AArch64              | `aarch64-*`              | [`RNDR`] register\n| `wasm_js`         | Web Browser, Node.js | `wasm32\u{2011}unknown\u{2011}unknown`, `wasm32v1-none` | [`Crypto.getRandomValues`]. Enabled by the `wasm_js` feature ([see below](#webassembly-support)).\n| `efi_rng`         | UEFI                 | `*-unknown\u{2011}uefi`         | [`EFI_RNG_PROTOCOL`] with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nightly compiler)\n| `windows_legacy`  | Windows              | `*-windows-*`            | [`RtlGenRandom`]\n| `custom`          | All targets          | `*`                      | User-provided custom implementation (see [custom backend])\n| `unsupported`     | All targets          | `*`                      | Always returns `Err(Error::UNSUPPORTED)` (see [unsupported backend])\n\nOpt-in backends can be enabled using the `getrandom_backend` configuration flag.\nThe flag can be set either by specifying the `rustflags` field in [`.cargo/config.toml`]:\n```toml\n# It\'s recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = [\'--cfg\', \'getrandom_backend=\"wasm_js\"\']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n\n```sh\nRUSTFLAGS=\'--cfg getrandom_backend=\"linux_getrandom\"\' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for\nan incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target)\nwill result in a compilation error. Be extremely careful while using opt-in backends,\nas incorrect configuration may result in vulnerable applications or applications\nthat always panic.\n\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks)\nWILL NOT have any effect on its downstream users.\n\n[`.cargo/config.toml`]: https://doc.rust-lang.org/cargo/reference/config.html\n\n### Raw Linux syscall support\n\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro,\ni.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\n\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`,\ne.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow\n`int 0x80` instruction to perform syscall.\n\n### WebAssembly support\n\nThis crate fully supports the [WASI] and [Emscripten] targets. However,\nthe `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`)\nis not automatically supported since, from the target name alone, we cannot deduce\nwhich JavaScript interface should be used (or if JavaScript is available at all).\n\nWe do not include support for this target in the default configuration because\nour JS backend (supporting web browsers, web workers and Node.js v19 or later)\nrequires [`wasm-bindgen`], **bloating `Cargo.lock`** and\n**potentially breaking builds** on non-web WASM platforms.\n\nTo enable `getrandom`\'s functionality on `wasm32-unknown-unknown` using the Web\nCrypto methods [described above][opt-in] via [`wasm-bindgen`], enable the\n`wasm_js` feature flag. Setting `RUSTFLAGS=\'--cfg getrandom_backend=\"wasm_js\"\'`\nis allowed but is no longer required and does nothing (it was required in a\nprior version of this crate).\n\nWARNING: enabling the `wasm_js` feature will bloat `Cargo.lock` on all platforms\n(where [`wasm-bindgen`] is not an existing dependency) and is known to cause\nbuild issues on some non-web WASM platforms, even when a different backend is\nselected via `getrandom_backend`.\n\n### Custom backend\n\nIf this crate does not support your target out of the box or you have to use\na non-default entropy source, then you can provide a custom implementation.\nYou need to enable the custom backend as described in the\n[opt-in backends][opt-in] section.\n\nNext, you need to define an `extern` function with the following signature:\n\n```rust\nuse getrandom::Error;\n\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n    dest: *mut u8,\n    len: usize,\n) -&gt; Result&lt;(), Error&gt; {\n    todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project,\ne.g. in your `main.rs`. This function MUST be defined only once for your\nproject, i.e. upstream library crates SHOULD NOT define it outside of\ntests and benchmarks. Improper configuration of this backend may result\nin linking errors.\n\nThe function accepts a pointer to a buffer that should be filled with random\ndata and its length in bytes. Note that the buffer MAY be uninitialized.\nOn success, the function should return `Ok(())` and fully fill the input buffer;\notherwise, it should return an error value.\n\nWhile wrapping functions which work with byte slices you should fully initialize\nthe buffer before passing it to the function:\n```rust\nuse getrandom::Error;\n\nfn my_entropy_source(buf: &amp;mut [u8]) -&gt; Result&lt;(), getrandom::Error&gt; {\n    // ...\n    Ok(())\n}\n\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n    dest: *mut u8,\n    len: usize,\n) -&gt; Result&lt;(), Error&gt; {\n    let buf = unsafe {\n        // fill the buffer with zeros\n        core::ptr::write_bytes(dest, 0, len);\n        // create mutable byte slice\n        core::slice::from_raw_parts_mut(dest, len)\n    };\n    my_entropy_source(buf)\n}\n```\n\n### Unsupported backend\n\nIn some rare scenarios, you might be compiling this crate for an unsupported\ntarget (e.g. `wasm32-unknown-unknown`), but this crate\'s functionality\nis not actually used by your code. If you are confident that `getrandom` is\nnot used in your project, but it gets pulled nevertheless by one of your\ndependencies, then you can enable the `unsupported` backend, which always\nreturns `Err(Error::UNSUPPORTED)`.\n\n### Platform Support\n\nThis crate generally supports the same operating system and platform versions\nthat the Rust standard library does. Additional targets may be supported using\nthe opt-in custom backend.\n\nThis means that as Rust drops support for old versions of operating systems\n(such as old Linux kernel versions, Android API levels, etc.) in stable releases,\n`getrandom` may create new patch releases that remove support for\noutdated platform versions.\n\n### `/dev/urandom` fallback on Linux and Android\n\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env`\nis `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`,\n`powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets [require][platform-support]\nkernel versions that support the `getrandom` system call, so the fallback is not needed.\n\nOn Android targets the fallback is present only for the following `target_arch`es:\n`aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require\nsufficiently high API levels.\n\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend.\nNote that doing so will bump minimum supported Linux kernel version to 3.17\nand Android API level to 23 (Marshmallow).\n\n### Early boot\n\nSometimes, early in the boot process, the OS has not collected enough\nentropy to securely seed its RNG. This is especially common on virtual\nmachines, where standard \"random\" events are hard to come by.\n\nSome operating system interfaces always block until the RNG is securely\nseeded. This can take anywhere from a few seconds to more than a minute.\nA few (Linux, NetBSD and Solaris) offer a choice between blocking and\ngetting an error; in these cases, we always choose to block.\n\nOn Linux (when the `getrandom` system call is not available), reading from\n`/dev/urandom` never blocks, even when the OS hasn\'t collected enough\nentropy yet. To avoid returning low-entropy bytes, we first poll\n`/dev/random` and only switch to `/dev/urandom` once this has succeeded.\n\nOn OpenBSD, this kind of entropy accounting isn\'t available, and on\nNetBSD, blocking on it is discouraged. On these platforms, nonblocking\ninterfaces are used, even when reliable entropy may not be available.\nOn the platforms where it is used, the reliability of entropy accounting\nitself isn\'t free from controversy. This library provides randomness\nsourced according to the platform\'s best practices, but each platform has\nits own limits on the grade of randomness it can promise in environments\nwith few sources of entropy.\n\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the\nvoltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded\nvia RC_FAST_CLK. This can occur during early boot unless\n`bootloader_random_enable()` is called. For more information see the\n[ESP-IDF RNG Docs][esp-idf-rng] or the\n[RNG section of the ESP32 Technical Reference Manual][esp-trng-docs].\n\n## Error handling\n\nWe always prioritize failure over returning known insecure \"random\" bytes.\nGenerally, on supported platforms, failure is highly unlikely, though not\nimpossible. If an error does occur, it is likely that it will occur\non every call to `getrandom`. Therefore, after the first successful call,\none can be reasonably confident that no errors will occur.\n\n## Panic handling\n\nWe strive to eliminate all potential panics from our backend implementations.\nIn other words, when compiled with optimizations enabled, the generated\nbinary code for `getrandom` functions should not contain any panic branches.\nEven if the platform misbehaves and returns an unexpected result,\nour code should correctly handle it and return an error, e.g.\n[`Error::UNEXPECTED`].\n\n## Sanitizer support\n\nIf your code uses [`fill_uninit`] and you enable\n[MemorySanitizer](https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer)\n(i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning\nof the destination buffer filled by `fill_uninit`.\n\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```sh\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n## Minimum Supported Rust Version\n\nThis crate requires Rust 1.63 or later.\n\n## License\n\nThe `getrandom` library is distributed under either of\n\n * [Apache License, Version 2.0][LICENSE-APACHE]\n * [MIT license][LICENSE-MIT]\n\nat your option.\n\n### Contribution\n\nUnless you explicitly state otherwise, any contribution intentionally submitted\nfor inclusion in the work by you, as defined in the Apache-2.0 license, shall be\ndual licensed as above, without any additional terms or conditions.\n\n[//]: # (badges)\n\n[GitHub Actions]: https://github.com/rust-random/getrandom/actions?query=branch:master\n[Build Status]: https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master\n[crates.io]: https://crates.io/crates/getrandom\n[Crate]: https://img.shields.io/crates/v/getrandom\n[docs.rs]: https://docs.rs/getrandom\n[Documentation]: https://docs.rs/getrandom/badge.svg\n[deps.rs]: https://deps.rs/repo/github/rust-random/getrandom\n[Dependency Status]: https://deps.rs/repo/github/rust-random/getrandom/status.svg\n[Downloads]: https://img.shields.io/crates/d/getrandom\n[License]: https://img.shields.io/crates/l/getrandom\n\n[//]: # (supported targets)\n\n[1]: https://manned.org/getrandom.2\n[2]: https://manned.org/urandom.4\n[3]: https://www.unix.com/man-page/mojave/2/getentropy/\n[4]: https://www.unix.com/man-page/mojave/4/urandom/\n[5]: https://www.freebsd.org/cgi/man.cgi?query=getrandom&amp;manpath=FreeBSD+12.0-stable\n[7]: https://man.openbsd.org/getentropy.2\n[8]: https://man.netbsd.org/sysctl.7\n[9]: https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom\n[11]: https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html\n[12]: https://illumos.org/man/2/getrandom\n[13]: https://github.com/emscripten-core/emscripten/pull/12240\n[14]: https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html\n[15]: https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices\n[16]: https://man.netbsd.org/getrandom.2\n[17]: https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom\n[18]: https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d\n[19]: https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c\n[20]: https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc\n\n[`ProcessPrng`]: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng\n[`RtlGenRandom`]: https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom\n[`Crypto.getRandomValues`]: https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues\n[`RDRAND`]: https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide\n[`RNDR`]: https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number\n[`CCRandomGenerateBytes`]: https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html\n[`cprng_draw`]: https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw\n[`esp_fill_random`]: https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions\n[esp-idf-rng]: https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html\n[esp-trng-docs]: https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng\n[`EFI_RNG_PROTOCOL`]: https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol\n[`random_get`]: https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno\n[`get-random-u64`]: https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28\n[configuration flags]: #configuration-flags\n[custom backend]: #custom-backend\n[unsupported backend]: #unsupported-backend\n[`wasm-bindgen`]: https://github.com/rustwasm/wasm-bindgen\n[`module`]: https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/module.html\n[`sys_read_entropy`]: https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55\n[platform-support]: https://doc.rust-lang.org/stable/rustc/platform-support.html\n[WASI]: https://github.com/WebAssembly/WASI\n[Emscripten]: https://emscripten.org\n[opt-in]: #opt-in-backends\n\n[//]: # (licenses)\n\n[LICENSE-APACHE]: https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE\n[LICENSE-MIT]: https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT\n\n[`Error::UNEXPECTED`]: https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED\n[`fill_uninit`]: https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html\n"</span></span><span class=original><span class="macro">include_str!</span>(<span class="string">"../README.md"</span><a href="#99">)</span></span>]
<a href=#11 id=11 data-nosnippet>11</a>#![warn(rust_2018_idioms, unused_lifetimes, missing_docs)]
<a href=#12 id=12 data-nosnippet>12</a>#![cfg_attr(docsrs, feature(doc_cfg))]
<a href=#13 id=13 data-nosnippet>13</a>#![cfg_attr(getrandom_backend = </a><span class="string">"efi_rng"</span>, feature(uefi_std))]
<a href=#14 id=14 data-nosnippet>14</a>#![deny(
<a href=#15 id=15 data-nosnippet>15</a>    clippy::cast_lossless,
<a href=#16 id=16 data-nosnippet>16</a>    clippy::cast_possible_truncation,
<a href=#17 id=17 data-nosnippet>17</a>    clippy::cast_possible_wrap,
<a href=#18 id=18 data-nosnippet>18</a>    clippy::cast_precision_loss,
<a href=#19 id=19 data-nosnippet>19</a>    clippy::cast_ptr_alignment,
<a href=#20 id=20 data-nosnippet>20</a>    clippy::cast_sign_loss,
<a href=#21 id=21 data-nosnippet>21</a>    clippy::char_lit_as_u8,
<a href=#22 id=22 data-nosnippet>22</a>    clippy::checked_conversions,
<a href=#23 id=23 data-nosnippet>23</a>    clippy::fn_to_numeric_cast,
<a href=#24 id=24 data-nosnippet>24</a>    clippy::fn_to_numeric_cast_with_truncation,
<a href=#25 id=25 data-nosnippet>25</a>    clippy::ptr_as_ptr,
<a href=#26 id=26 data-nosnippet>26</a>    clippy::unnecessary_cast,
<a href=#27 id=27 data-nosnippet>27</a>    clippy::useless_conversion
<a href=#28 id=28 data-nosnippet>28</a>)]
<a href=#29 id=29 data-nosnippet>29</a>
<a href=#30 id=30 data-nosnippet>30</a>#[macro_use]
<a href=#31 id=31 data-nosnippet>31</a></span><span class="kw">extern crate </span><a href="#99">cfg_if;
<a href=#32 id=32 data-nosnippet>32</a>
<a href=#33 id=33 data-nosnippet>33</a></a><span class="kw">use </span><a href="#99"><a href="https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html">core::mem::MaybeUninit</a>;
<a href=#34 id=34 data-nosnippet>34</a>
<a href=#35 id=35 data-nosnippet>35</a></a><span class="kw">mod </span><a href="#99"><a href="backends.rs.html#1-209">backends</a>;
<a href=#36 id=36 data-nosnippet>36</a></a><span class="kw">mod </span><a href="#99"><a href="error.rs.html#1-212">error</a>;
<a href=#37 id=37 data-nosnippet>37</a></a><span class="kw">mod </span><a href="#99"><a href="util.rs.html#1-84">util</a>;
<a href=#38 id=38 data-nosnippet>38</a>
<a href=#39 id=39 data-nosnippet>39</a></a><span class="attr"><a href="#99">#[cfg(feature = </a><span class="string">"std"</span>)]
<a href=#40 id=40 data-nosnippet>40</a></span><span class="kw">mod </span><a href="#99"><a href="error_std_impls.rs.html#1-15">error_std_impls</a>;
<a href=#41 id=41 data-nosnippet>41</a>
<a href=#42 id=42 data-nosnippet>42</a></a><span class="kw">pub use </span><a href="#99"><a href="error.rs.html#36"><span class="kw">crate</span>::error::Error</a>;
<a href=#43 id=43 data-nosnippet>43</a>
<a href=#44 id=44 data-nosnippet>44</a></a><span class="doccomment">/// Fill `dest` with random bytes from the system's preferred random number source.
<a href=#45 id=45 data-nosnippet>45</a>///
<a href=#46 id=46 data-nosnippet>46</a>/// This function returns an error on any failure, including partial reads. We
<a href=#47 id=47 data-nosnippet>47</a>/// make no guarantees regarding the contents of `dest` on error. If `dest` is
<a href=#48 id=48 data-nosnippet>48</a>/// empty, `getrandom` immediately returns success, making no calls to the
<a href=#49 id=49 data-nosnippet>49</a>/// underlying operating system.
<a href=#50 id=50 data-nosnippet>50</a>///
<a href=#51 id=51 data-nosnippet>51</a>/// Blocking is possible, at least during early boot; see module documentation.
<a href=#52 id=52 data-nosnippet>52</a>///
<a href=#53 id=53 data-nosnippet>53</a>/// In general, `getrandom` will be fast enough for interactive usage, though
<a href=#54 id=54 data-nosnippet>54</a>/// significantly slower than a user-space CSPRNG; for the latter consider
<a href=#55 id=55 data-nosnippet>55</a>/// [`rand::thread_rng`](https://docs.rs/rand/*/rand/fn.thread_rng.html).
<a href=#56 id=56 data-nosnippet>56</a>///
<a href=#57 id=57 data-nosnippet>57</a>/// # Examples
<a href=#58 id=58 data-nosnippet>58</a>///
<a href=#59 id=59 data-nosnippet>59</a>/// ```
<a href=#60 id=60 data-nosnippet>60</a>/// # fn main() -&gt; Result&lt;(), getrandom::Error&gt; {
<a href=#61 id=61 data-nosnippet>61</a>/// let mut buf = [0u8; 32];
<a href=#62 id=62 data-nosnippet>62</a>/// getrandom::fill(&amp;mut buf)?;
<a href=#63 id=63 data-nosnippet>63</a>/// # Ok(()) }
<a href=#64 id=64 data-nosnippet>64</a>/// ```
<a href=#65 id=65 data-nosnippet>65</a></span><span class="attr">#[inline]
<a href=#66 id=66 data-nosnippet>66</a></span><span class="kw">pub fn </span><a href="#99"><a href="../../getrandom/fn.fill.html">fill</a>(dest: </a><span class="kw-2">&amp;mut </span><a href="#99">[<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; </a><a class="prelude-ty" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a><a href="#99">&lt;(), <a href="error.rs.html#36">Error</a>&gt; {
<a href=#67 id=67 data-nosnippet>67</a>    </a><span class="comment">// SAFETY: The `&amp;mut MaybeUninit&lt;_&gt;` reference doesn't escape,
<a href=#68 id=68 data-nosnippet>68</a>    // and `fill_uninit` guarantees it will never de-initialize
<a href=#69 id=69 data-nosnippet>69</a>    // any part of `dest`.
<a href=#70 id=70 data-nosnippet>70</a>    </span><a href="#99"><a href="#97-110">fill_uninit</a>(</a><span class="kw">unsafe </span><a href="#99">{ util::<a href="util.rs.html#35-39">slice_as_uninit_mut</a>(<a href="#66">dest</a>) })</a><span class="question-mark">?</span>;
<a href=#71 id=71 data-nosnippet>71</a>    <a class="prelude-val" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok">Ok</a>(())
<a href=#72 id=72 data-nosnippet>72</a>}
<a href=#73 id=73 data-nosnippet>73</a>
<a href=#74 id=74 data-nosnippet>74</a><span class="doccomment">/// Fill potentially uninitialized buffer `dest` with random bytes from
<a href=#75 id=75 data-nosnippet>75</a>/// the system's preferred random number source and return a mutable
<a href=#76 id=76 data-nosnippet>76</a>/// reference to those bytes.
<a href=#77 id=77 data-nosnippet>77</a>///
<a href=#78 id=78 data-nosnippet>78</a>/// On successful completion this function is guaranteed to return a slice
<a href=#79 id=79 data-nosnippet>79</a>/// which points to the same memory as `dest` and has the same length.
<a href=#80 id=80 data-nosnippet>80</a>/// In other words, it's safe to assume that `dest` is initialized after
<a href=#81 id=81 data-nosnippet>81</a>/// this function has returned `Ok`.
<a href=#82 id=82 data-nosnippet>82</a>///
<a href=#83 id=83 data-nosnippet>83</a>/// No part of `dest` will ever be de-initialized at any point, regardless
<a href=#84 id=84 data-nosnippet>84</a>/// of what is returned.
<a href=#85 id=85 data-nosnippet>85</a>///
<a href=#86 id=86 data-nosnippet>86</a>/// # Examples
<a href=#87 id=87 data-nosnippet>87</a>///
<a href=#88 id=88 data-nosnippet>88</a>/// ```ignore
<a href=#89 id=89 data-nosnippet>89</a>/// # // We ignore this test since `uninit_array` is unstable.
<a href=#90 id=90 data-nosnippet>90</a>/// #![feature(maybe_uninit_uninit_array)]
<a href=#91 id=91 data-nosnippet>91</a>/// # fn main() -&gt; Result&lt;(), getrandom::Error&gt; {
<a href=#92 id=92 data-nosnippet>92</a>/// let mut buf = core::mem::MaybeUninit::uninit_array::&lt;1024&gt;();
<a href=#93 id=93 data-nosnippet>93</a>/// let buf: &amp;mut [u8] = getrandom::fill_uninit(&amp;mut buf)?;
<a href=#94 id=94 data-nosnippet>94</a>/// # Ok(()) }
<a href=#95 id=95 data-nosnippet>95</a>/// ```
<a href=#96 id=96 data-nosnippet>96</a></span><span class="attr">#[inline]
<a href=#97 id=97 data-nosnippet>97</a></span><span class="kw">pub fn </span><a href="#99"><a href="../../getrandom/fn.fill_uninit.html">fill_uninit</a>(dest: </a><span class="kw-2">&amp;mut </span><a href="#99">[<a href="https://doc.rust-lang.org/nightly/core/mem/maybe_uninit/union.MaybeUninit.html">MaybeUninit</a>&lt;<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;]) -&gt; </a><a class="prelude-ty" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a>&lt;<span class="kw-2">&amp;mut </span><a href="#99">[<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], <a href="error.rs.html#36">Error</a>&gt; {
<a href=#98 id=98 data-nosnippet>98</a>    </a><span class="kw">if </span><a href="#99">!<a href="#97">dest</a>.<a href="https://doc.rust-lang.org/nightly/core/foreigntype.slice.html#method.is_empty">is_empty</a>() {
<a href=#99 id=99 data-nosnippet>99</a>        backends::<a href="backends/linux_android_with_fallback.rs.html#79-103">fill_inner</a>(<a href="#97">dest</a>)</a><span class="question-mark">?</span>;
<a href=#100 id=100 data-nosnippet>100</a>    }
<a href=#101 id=101 data-nosnippet>101</a>
<a href=#102 id=102 data-nosnippet>102</a>    <span class="attr">#[cfg(getrandom_msan)]
<a href=#103 id=103 data-nosnippet>103</a>    </span><span class="kw">extern </span><span class="string">"C" </span>{
<a href=#104 id=104 data-nosnippet>104</a>        <span class="kw">fn </span><a href="#99">__msan_unpoison(a: </a><span class="kw-2">*mut </span><a href="#99">core::ffi::c_void, size: usize);
<a href=#105 id=105 data-nosnippet>105</a>    }
<a href=#106 id=106 data-nosnippet>106</a>
<a href=#107 id=107 data-nosnippet>107</a>    </a><span class="comment">// SAFETY: `dest` has been fully initialized by `imp::fill_inner`
<a href=#108 id=108 data-nosnippet>108</a>    // since it returned `Ok`.
<a href=#109 id=109 data-nosnippet>109</a>    </span><a class="prelude-val" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Ok">Ok</a>(<span class="kw">unsafe </span><a href="#99">{ util::<a href="util.rs.html#10-14">slice_assume_init_mut</a>(<a href="#97">dest</a>) })
<a href=#110 id=110 data-nosnippet>110</a>}
<a href=#111 id=111 data-nosnippet>111</a>
<a href=#112 id=112 data-nosnippet>112</a></a><span class="doccomment">/// Get random `u32` from the system's preferred random number source.
<a href=#113 id=113 data-nosnippet>113</a>///
<a href=#114 id=114 data-nosnippet>114</a>/// # Examples
<a href=#115 id=115 data-nosnippet>115</a>///
<a href=#116 id=116 data-nosnippet>116</a>/// ```
<a href=#117 id=117 data-nosnippet>117</a>/// # fn main() -&gt; Result&lt;(), getrandom::Error&gt; {
<a href=#118 id=118 data-nosnippet>118</a>/// let rng_seed = getrandom::u32()?;
<a href=#119 id=119 data-nosnippet>119</a>/// # Ok(()) }
<a href=#120 id=120 data-nosnippet>120</a>/// ```
<a href=#121 id=121 data-nosnippet>121</a></span><span class="attr">#[inline]
<a href=#122 id=122 data-nosnippet>122</a></span><span class="kw">pub fn </span><a href="#99"><a href="../../getrandom/fn.u32.html">u32</a>() -&gt; </a><a class="prelude-ty" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a><a href="#99">&lt;<a href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <a href="error.rs.html#36">Error</a>&gt; {
<a href=#123 id=123 data-nosnippet>123</a>    backends::<a href="util.rs.html#53-64">inner_u32</a>()
<a href=#124 id=124 data-nosnippet>124</a>}
<a href=#125 id=125 data-nosnippet>125</a>
<a href=#126 id=126 data-nosnippet>126</a></a><span class="doccomment">/// Get random `u64` from the system's preferred random number source.
<a href=#127 id=127 data-nosnippet>127</a>///
<a href=#128 id=128 data-nosnippet>128</a>/// # Examples
<a href=#129 id=129 data-nosnippet>129</a>///
<a href=#130 id=130 data-nosnippet>130</a>/// ```
<a href=#131 id=131 data-nosnippet>131</a>/// # fn main() -&gt; Result&lt;(), getrandom::Error&gt; {
<a href=#132 id=132 data-nosnippet>132</a>/// let rng_seed = getrandom::u64()?;
<a href=#133 id=133 data-nosnippet>133</a>/// # Ok(()) }
<a href=#134 id=134 data-nosnippet>134</a>/// ```
<a href=#135 id=135 data-nosnippet>135</a></span><span class="attr">#[inline]
<a href=#136 id=136 data-nosnippet>136</a></span><span class="kw">pub fn </span><a href="#99"><a href="../../getrandom/fn.u64.html">u64</a>() -&gt; </a><a class="prelude-ty" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a><a href="#99">&lt;<a href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, <a href="error.rs.html#36">Error</a>&gt; {
<a href=#137 id=137 data-nosnippet>137</a>    backends::<a href="util.rs.html#68-79">inner_u64</a>()
<a href=#138 id=138 data-nosnippet>138</a>}</a></code></pre></div></section></main></body></html>