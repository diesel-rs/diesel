<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `TinyAsciiStr` struct in crate `tinystr`."><title>TinyAsciiStr in tinystr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="tinystr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0-nightly (2a023bf80 2025-07-10)" data-channel="nightly" data-search-js="search-179e01a3.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-673ee1e0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../tinystr/index.html">tinystr</a><span class="version">0.8.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Tiny<wbr>Ascii<wbr>Str</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.all_bytes" title="all_bytes">all_bytes</a></li><li><a href="#method.as_str" title="as_str">as_str</a></li><li><a href="#method.as_utf8" title="as_utf8">as_utf8</a></li><li><a href="#method.concat" title="concat">concat</a></li><li><a href="#method.from_utf8_lossy" title="from_utf8_lossy">from_utf8_lossy</a></li><li><a href="#method.from_utf8_unchecked" title="from_utf8_unchecked">from_utf8_unchecked</a></li><li><a href="#method.from_utf16_lossy" title="from_utf16_lossy">from_utf16_lossy</a></li><li><a href="#method.is_ascii_alphabetic" title="is_ascii_alphabetic">is_ascii_alphabetic</a></li><li><a href="#method.is_ascii_alphabetic_lowercase" title="is_ascii_alphabetic_lowercase">is_ascii_alphabetic_lowercase</a></li><li><a href="#method.is_ascii_alphabetic_titlecase" title="is_ascii_alphabetic_titlecase">is_ascii_alphabetic_titlecase</a></li><li><a href="#method.is_ascii_alphabetic_uppercase" title="is_ascii_alphabetic_uppercase">is_ascii_alphabetic_uppercase</a></li><li><a href="#method.is_ascii_alphanumeric" title="is_ascii_alphanumeric">is_ascii_alphanumeric</a></li><li><a href="#method.is_ascii_lowercase" title="is_ascii_lowercase">is_ascii_lowercase</a></li><li><a href="#method.is_ascii_numeric" title="is_ascii_numeric">is_ascii_numeric</a></li><li><a href="#method.is_ascii_titlecase" title="is_ascii_titlecase">is_ascii_titlecase</a></li><li><a href="#method.is_ascii_uppercase" title="is_ascii_uppercase">is_ascii_uppercase</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.resize" title="resize">resize</a></li><li><a href="#method.to_ascii_lowercase" title="to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_titlecase" title="to_ascii_titlecase">to_ascii_titlecase</a></li><li><a href="#method.to_ascii_uppercase" title="to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_unvalidated" title="to_unvalidated">to_unvalidated</a></li><li><a href="#method.try_from_raw" title="try_from_raw">try_from_raw</a></li><li><a href="#method.try_from_str" title="try_from_str">try_from_str</a></li><li><a href="#method.try_from_utf8" title="try_from_utf8">try_from_utf8</a></li><li><a href="#method.try_from_utf16" title="try_from_utf16">try_from_utf16</a></li></ul><h3><a href="#deref-methods-str">Methods from Deref&lt;<wbr>Target=str&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.as_ascii" title="as_ascii">as_ascii</a></li><li><a href="#method.as_ascii_unchecked" title="as_ascii_unchecked">as_ascii_unchecked</a></li><li><a href="#method.as_bytes" title="as_bytes">as_bytes</a></li><li><a href="#method.as_ptr" title="as_ptr">as_ptr</a></li><li><a href="#method.as_str-1" title="as_str">as_str</a></li><li><a href="#method.bytes" title="bytes">bytes</a></li><li><a href="#method.ceil_char_boundary" title="ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices" title="char_indices">char_indices</a></li><li><a href="#method.chars" title="chars">chars</a></li><li><a href="#method.contains" title="contains">contains</a></li><li><a href="#method.encode_utf16" title="encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with" title="ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case" title="eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug" title="escape_debug">escape_debug</a></li><li><a href="#method.escape_default" title="escape_default">escape_default</a></li><li><a href="#method.escape_unicode" title="escape_unicode">escape_unicode</a></li><li><a href="#method.find" title="find">find</a></li><li><a href="#method.floor_char_boundary" title="floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_unchecked" title="get_unchecked">get_unchecked</a></li><li><a href="#method.is_ascii" title="is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary" title="is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty-1" title="is_empty">is_empty</a></li><li><a href="#method.len-1" title="len">len</a></li><li><a href="#method.lines" title="lines">lines</a></li><li><a href="#method.lines_any" title="lines_any">lines_any</a></li><li><a href="#method.match_indices" title="match_indices">match_indices</a></li><li><a href="#method.matches" title="matches">matches</a></li><li><a href="#method.parse" title="parse">parse</a></li><li><a href="#method.repeat" title="repeat">repeat</a></li><li><a href="#method.replace" title="replace">replace</a></li><li><a href="#method.replacen" title="replacen">replacen</a></li><li><a href="#method.rfind" title="rfind">rfind</a></li><li><a href="#method.rmatch_indices" title="rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches" title="rmatches">rmatches</a></li><li><a href="#method.rsplit" title="rsplit">rsplit</a></li><li><a href="#method.rsplit_once" title="rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator" title="rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn" title="rsplitn">rsplitn</a></li><li><a href="#method.slice_unchecked" title="slice_unchecked">slice_unchecked</a></li><li><a href="#method.split" title="split">split</a></li><li><a href="#method.split_ascii_whitespace" title="split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at" title="split_at">split_at</a></li><li><a href="#method.split_at_checked" title="split_at_checked">split_at_checked</a></li><li><a href="#method.split_inclusive" title="split_inclusive">split_inclusive</a></li><li><a href="#method.split_once" title="split_once">split_once</a></li><li><a href="#method.split_terminator" title="split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace" title="split_whitespace">split_whitespace</a></li><li><a href="#method.splitn" title="splitn">splitn</a></li><li><a href="#method.starts_with" title="starts_with">starts_with</a></li><li><a href="#method.strip_prefix" title="strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix" title="strip_suffix">strip_suffix</a></li><li><a href="#method.substr_range" title="substr_range">substr_range</a></li><li><a href="#method.to_ascii_lowercase-1" title="to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_uppercase-1" title="to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_lowercase" title="to_lowercase">to_lowercase</a></li><li><a href="#method.to_uppercase" title="to_uppercase">to_uppercase</a></li><li><a href="#method.trim" title="trim">trim</a></li><li><a href="#method.trim_ascii" title="trim_ascii">trim_ascii</a></li><li><a href="#method.trim_ascii_end" title="trim_ascii_end">trim_ascii_end</a></li><li><a href="#method.trim_ascii_start" title="trim_ascii_start">trim_ascii_start</a></li><li><a href="#method.trim_end" title="trim_end">trim_end</a></li><li><a href="#method.trim_end_matches" title="trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left" title="trim_left">trim_left</a></li><li><a href="#method.trim_left_matches" title="trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches" title="trim_matches">trim_matches</a></li><li><a href="#method.trim_prefix" title="trim_prefix">trim_prefix</a></li><li><a href="#method.trim_right" title="trim_right">trim_right</a></li><li><a href="#method.trim_right_matches" title="trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start" title="trim_start">trim_start</a></li><li><a href="#method.trim_start_matches" title="trim_start_matches">trim_start_matches</a></li><li><a href="#method.trim_suffix" title="trim_suffix">trim_suffix</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsULE-for-TinyAsciiStr%3CN%3E" title="AsULE">AsULE</a></li><li><a href="#impl-Borrow%3Cstr%3E-for-TinyAsciiStr%3CN%3E" title="Borrow&#60;str&#62;">Borrow&#60;str&#62;</a></li><li><a href="#impl-Clone-for-TinyAsciiStr%3CN%3E" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-TinyAsciiStr%3CN%3E" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-TinyAsciiStr%3CN%3E" title="Debug">Debug</a></li><li><a href="#impl-Deref-for-TinyAsciiStr%3CN%3E" title="Deref">Deref</a></li><li><a href="#impl-Display-for-TinyAsciiStr%3CN%3E" title="Display">Display</a></li><li><a href="#impl-Eq-for-TinyAsciiStr%3CN%3E" title="Eq">Eq</a></li><li><a href="#impl-From%3CTinyAsciiStr%3CN%3E%3E-for-UnvalidatedTinyAsciiStr%3CN%3E" title="From&#60;TinyAsciiStr&#60;N&#62;&#62;">From&#60;TinyAsciiStr&#60;N&#62;&#62;</a></li><li><a href="#impl-FromStr-for-TinyAsciiStr%3CN%3E" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-TinyAsciiStr%3CN%3E" title="Hash">Hash</a></li><li><a href="#impl-NicheBytes%3CN%3E-for-TinyAsciiStr%3CN%3E" title="NicheBytes&#60;N&#62;">NicheBytes&#60;N&#62;</a></li><li><a href="#impl-Ord-for-TinyAsciiStr%3CN%3E" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-TinyAsciiStr%3CN%3E" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-TinyAsciiStr%3CN%3E" title="PartialEq&#60;&#38;str&#62;">PartialEq&#60;&#38;str&#62;</a></li><li><a href="#impl-PartialEq%3CString%3E-for-TinyAsciiStr%3CN%3E" title="PartialEq&#60;String&#62;">PartialEq&#60;String&#62;</a></li><li><a href="#impl-PartialEq%3CTinyAsciiStr%3CN%3E%3E-for-String" title="PartialEq&#60;TinyAsciiStr&#60;N&#62;&#62;">PartialEq&#60;TinyAsciiStr&#60;N&#62;&#62;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-TinyAsciiStr%3CN%3E" title="PartialEq&#60;str&#62;">PartialEq&#60;str&#62;</a></li><li><a href="#impl-PartialOrd-for-TinyAsciiStr%3CN%3E" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-StructuralPartialEq-for-TinyAsciiStr%3CN%3E" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-ULE-for-TinyAsciiStr%3CN%3E" title="ULE">ULE</a></li><li><a href="#impl-ZeroMapKV%3C'a%3E-for-TinyAsciiStr%3CN%3E" title="ZeroMapKV&#60;&#39;a&#62;">ZeroMapKV&#60;&#39;a&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-TinyAsciiStr%3CN%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-TinyAsciiStr%3CN%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-TinyAsciiStr%3CN%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-TinyAsciiStr%3CN%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-TinyAsciiStr%3CN%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-TinyAsciiStr%3CN%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-ErasedDestructor-for-T" title="ErasedDestructor">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-Receiver-for-P" title="Receiver">Receiver</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate tinystr</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">tinystr</a></div><h1>Struct <span class="struct">TinyAsciiStr</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/tinystr/ascii.rs.html#15-17">Source</a> </span></div><pre class="rust item-decl"><code>pub struct TinyAsciiStr&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#19-337">Source</a><a href="#impl-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><section id="method.try_from_str" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#21-23">Source</a><h4 class="code-header">pub const fn <a href="#method.try_from_str" class="fn">try_from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="enum.ParseError.html" title="enum tinystr::ParseError">ParseError</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.try_from_utf8" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#28-30">Source</a><h4 class="code-header">pub const fn <a href="#method.try_from_utf8" class="fn">try_from_utf8</a>(code_units: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="enum.ParseError.html" title="enum tinystr::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a <code>TinyAsciiStr&lt;N&gt;</code> from the given UTF-8 slice.
<code>code_units</code> may contain at most <code>N</code> non-null ASCII code points.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from_utf16" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#35-37">Source</a><h4 class="code-header">pub const fn <a href="#method.try_from_utf16" class="fn">try_from_utf16</a>(code_units: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="enum.ParseError.html" title="enum tinystr::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a <code>TinyAsciiStr&lt;N&gt;</code> from the given UTF-16 slice.
<code>code_units</code> may contain at most <code>N</code> non-null ASCII code points.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf8_lossy" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#46-72">Source</a><h4 class="code-header">pub const fn <a href="#method.from_utf8_lossy" class="fn">from_utf8_lossy</a>(code_units: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], replacement: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a <code>TinyAsciiStr&lt;N&gt;</code> from a UTF-8 slice, replacing invalid code units.</p>
<p>Invalid code units, as well as null or non-ASCII code points
(i.e. those outside the range U+0001..=U+007F`)
will be replaced with the replacement byte.</p>
<p>The input slice will be truncated if its length exceeds <code>N</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf16_lossy" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#81-107">Source</a><h4 class="code-header">pub const fn <a href="#method.from_utf16_lossy" class="fn">from_utf16_lossy</a>(code_units: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>], replacement: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a <code>TinyAsciiStr&lt;N&gt;</code> from a UTF-16 slice, replacing invalid code units.</p>
<p>Invalid code units, as well as null or non-ASCII code points
(i.e. those outside the range U+0001..=U+007F`)
will be replaced with the replacement byte.</p>
<p>The input slice will be truncated if its length exceeds <code>N</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from_raw" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#129-131">Source</a><h4 class="code-header">pub const fn <a href="#method.try_from_raw" class="fn">try_from_raw</a>(raw: [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">N</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="enum.ParseError.html" title="enum tinystr::ParseError">ParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Attempts to parse a fixed-length byte array to a <code>TinyAsciiStr</code>.</p>
<p>The byte array may contain trailing NUL bytes.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::tinystr;
<span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="macro">assert_eq!</span>(
    TinyAsciiStr::&lt;<span class="number">3</span>&gt;::try_from_raw(<span class="kw-2">*</span><span class="string">b"GB\0"</span>),
    <span class="prelude-val">Ok</span>(<span class="macro">tinystr!</span>(<span class="number">3</span>, <span class="string">"GB"</span>))
);
<span class="macro">assert_eq!</span>(
    TinyAsciiStr::&lt;<span class="number">3</span>&gt;::try_from_raw(<span class="kw-2">*</span><span class="string">b"USD"</span>),
    <span class="prelude-val">Ok</span>(<span class="macro">tinystr!</span>(<span class="number">3</span>, <span class="string">"USD"</span>))
);
<span class="macro">assert!</span>(<span class="macro">matches!</span>(TinyAsciiStr::&lt;<span class="number">3</span>&gt;::try_from_raw(<span class="kw-2">*</span><span class="string">b"\0A\0"</span>), <span class="prelude-val">Err</span>(<span class="kw">_</span>)));</code></pre></div>
</div></details><section id="method.as_str" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#220-223">Source</a><h4 class="code-header">pub const fn <a href="#method.as_str" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section><section id="method.len" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#227-240">Source</a><h4 class="code-header">pub const fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section><section id="method.is_empty" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#244-246">Source</a><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section><section id="method.as_utf8" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#250-256">Source</a><h4 class="code-header">pub const fn <a href="#method.as_utf8" class="fn">as_utf8</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section><section id="method.all_bytes" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#260-263">Source</a><h4 class="code-header">pub const fn <a href="#method.all_bytes" class="fn">all_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">N</a>]</h4></section><details class="toggle method-toggle" open><summary><section id="method.resize" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#271-283">Source</a><h4 class="code-header">pub const fn <a href="#method.resize" class="fn">resize</a>&lt;const M: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;M&gt;</h4></section></summary><div class="docblock"><p>Resizes a <code>TinyAsciiStr&lt;N&gt;</code> to a <code>TinyAsciiStr&lt;M&gt;</code>.</p>
<p>If <code>M &lt; len()</code> the string gets truncated, otherwise only the
memory representation changes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.concat" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#311-326">Source</a><h4 class="code-header">pub const fn <a href="#method.concat" class="fn">concat</a>&lt;const M: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, const Q: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;(
    self,
    other: <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;M&gt;,
) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;Q&gt;</h4></section></summary><div class="docblock"><p>Returns a <code>TinyAsciiStr&lt;Q&gt;</code> with the concatenation of this string,
<code>TinyAsciiStr&lt;N&gt;</code>, and another string, <code>TinyAsciiStr&lt;M&gt;</code>.</p>
<p>If <code>Q &lt; N + M</code>, the string gets truncated.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::tinystr;
<span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>abc = <span class="macro">tinystr!</span>(<span class="number">6</span>, <span class="string">"abc"</span>);
<span class="kw">let </span>defg = <span class="macro">tinystr!</span>(<span class="number">6</span>, <span class="string">"defg"</span>);

<span class="comment">// The concatenation is successful if Q is large enough...
</span><span class="macro">assert_eq!</span>(abc.concat(defg), <span class="macro">tinystr!</span>(<span class="number">16</span>, <span class="string">"abcdefg"</span>));
<span class="macro">assert_eq!</span>(abc.concat(defg), <span class="macro">tinystr!</span>(<span class="number">12</span>, <span class="string">"abcdefg"</span>));
<span class="macro">assert_eq!</span>(abc.concat(defg), <span class="macro">tinystr!</span>(<span class="number">8</span>, <span class="string">"abcdefg"</span>));
<span class="macro">assert_eq!</span>(abc.concat(defg), <span class="macro">tinystr!</span>(<span class="number">7</span>, <span class="string">"abcdefg"</span>));

<span class="doccomment">/// ...but it truncates of Q is too small.
</span><span class="macro">assert_eq!</span>(abc.concat(defg), <span class="macro">tinystr!</span>(<span class="number">6</span>, <span class="string">"abcdef"</span>));
<span class="macro">assert_eq!</span>(abc.concat(defg), <span class="macro">tinystr!</span>(<span class="number">2</span>, <span class="string">"ab"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_utf8_unchecked" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#332-336">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.from_utf8_unchecked" class="fn">from_utf8_unchecked</a>(code_units: [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">N</a>]) -&gt; Self</h4></section></summary><div class="docblock"><h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>Must be called with a bytes array made of valid ASCII bytes, with no null bytes
between ASCII characters</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E-1" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#404-649">Source</a><a href="#impl-TinyAsciiStr%3CN%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#423-425">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic" class="fn">is_ascii_alphabetic</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic characters:</p>
<ul>
<li>U+0041 ‘A’ ..= U+005A ‘Z’, or</li>
<li>U+0061 ‘a’ ..= U+007A ‘z’.</li>
</ul>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Te3t"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(s1.is_ascii_alphabetic());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphanumeric" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#446-448">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphanumeric" class="fn">is_ascii_alphanumeric</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphanumeric characters:</p>
<ul>
<li>U+0041 ‘A’ ..= U+005A ‘Z’, or</li>
<li>U+0061 ‘a’ ..= U+007A ‘z’, or</li>
<li>U+0030 ‘0’ ..= U+0039 ‘9’.</li>
</ul>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"A15b"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"[3@w"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(s1.is_ascii_alphanumeric());
<span class="macro">assert!</span>(!s2.is_ascii_alphanumeric());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_numeric" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#467-469">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_numeric" class="fn">is_ascii_numeric</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII decimal digits:</p>
<ul>
<li>U+0030 ‘0’ ..= U+0039 ‘9’.</li>
</ul>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"312"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"3d"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(s1.is_ascii_numeric());
<span class="macro">assert!</span>(!s2.is_ascii_numeric());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_lowercase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#490-497">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_lowercase" class="fn">is_ascii_lowercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is in ASCII lower case.</p>
<p>All letter characters are checked for case. Non-letter characters are ignored.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"001z"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(!s1.is_ascii_lowercase());
<span class="macro">assert!</span>(s2.is_ascii_lowercase());
<span class="macro">assert!</span>(s3.is_ascii_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_titlecase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#519-526">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_titlecase" class="fn">is_ascii_titlecase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is in ASCII title case.</p>
<p>This verifies that the first character is ASCII uppercase and all others ASCII lowercase.
Non-letter characters are ignored.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"001z"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(!s1.is_ascii_titlecase());
<span class="macro">assert!</span>(s2.is_ascii_titlecase());
<span class="macro">assert!</span>(s3.is_ascii_titlecase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_uppercase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#547-554">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_uppercase" class="fn">is_ascii_uppercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is in ASCII upper case.</p>
<p>All letter characters are checked for case. Non-letter characters are ignored.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"TEST"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"001z"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(!s1.is_ascii_uppercase());
<span class="macro">assert!</span>(s2.is_ascii_uppercase());
<span class="macro">assert!</span>(!s3.is_ascii_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic_lowercase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#579-586">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic_lowercase" class="fn">is_ascii_alphabetic_lowercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic lower case characters:</p>
<ul>
<li>U+0061 ‘a’ ..= U+007A ‘z’,</li>
</ul>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Te3t"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s4: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s5: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"001z"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(!s1.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(!s3.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(s4.is_ascii_alphabetic_lowercase());
<span class="macro">assert!</span>(!s5.is_ascii_alphabetic_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic_titlecase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#609-616">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic_titlecase" class="fn">is_ascii_alphabetic_titlecase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic, with the first character being ASCII uppercase, and all others ASCII lowercase.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Te3t"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s4: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s5: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"001z"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(s1.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s3.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s4.is_ascii_alphabetic_titlecase());
<span class="macro">assert!</span>(!s5.is_ascii_alphabetic_titlecase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii_alphabetic_uppercase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#641-648">Source</a><h4 class="code-header">pub const fn <a href="#method.is_ascii_alphabetic_uppercase" class="fn">is_ascii_alphabetic_uppercase</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the value is composed of ASCII alphabetic upper case characters:</p>
<ul>
<li>U+0041 ‘A’ ..= U+005A ‘Z’,</li>
</ul>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Test"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s2: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Te3t"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s3: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s4: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"TEST"</span>.parse().expect(<span class="string">"Failed to parse."</span>);
<span class="kw">let </span>s5: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"001z"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert!</span>(!s1.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(!s2.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(!s3.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(s4.is_ascii_alphabetic_uppercase());
<span class="macro">assert!</span>(!s5.is_ascii_alphabetic_uppercase());</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E-2" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#693-756">Source</a><a href="#impl-TinyAsciiStr%3CN%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#709-711">Source</a><h4 class="code-header">pub const fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts this type to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, other characters are unchanged.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"TeS3"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>s1.to_ascii_lowercase(), <span class="string">"tes3"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_titlecase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#729-736">Source</a><h4 class="code-header">pub const fn <a href="#method.to_ascii_titlecase" class="fn">to_ascii_titlecase</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts this type to its ASCII title case equivalent in-place.</p>
<p>The first character is converted to ASCII uppercase; the remaining characters
are converted to ASCII lowercase.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"teSt"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>s1.to_ascii_titlecase(), <span class="string">"Test"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase" class="method"><a class="src rightside" href="../src/tinystr/ascii.rs.html#753-755">Source</a><h4 class="code-header">pub const fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts this type to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, other characters are unchanged.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tinystr::TinyAsciiStr;

<span class="kw">let </span>s1: TinyAsciiStr&lt;<span class="number">4</span>&gt; = <span class="string">"Tes3"</span>.parse().expect(<span class="string">"Failed to parse."</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;*</span>s1.to_ascii_uppercase(), <span class="string">"TES3"</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TinyAsciiStr%3CN%3E-3" class="impl"><a class="src rightside" href="../src/tinystr/unvalidated.rs.html#43-49">Source</a><a href="#impl-TinyAsciiStr%3CN%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><section id="method.to_unvalidated" class="method"><a class="src rightside" href="../src/tinystr/unvalidated.rs.html#46-48">Source</a><h4 class="code-header">pub const fn <a href="#method.to_unvalidated" class="fn">to_unvalidated</a>(self) -&gt; <a class="struct" href="struct.UnvalidatedTinyAsciiStr.html" title="struct tinystr::UnvalidatedTinyAsciiStr">UnvalidatedTinyAsciiStr</a>&lt;N&gt;</h4></section></div></details></div><details class="toggle big-toggle" open><summary><h2 id="deref-methods-str" class="section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</span><a href="#deref-methods-str" class="anchor">§</a></h2></summary><div id="deref-methods-str-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#141">Source</a></span><h4 class="code-header">pub fn <a href="#method.len-1" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>len = <span class="string">"foo"</span>.len();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, len);

<span class="macro">assert_eq!</span>(<span class="string">"ƒoo"</span>.len(), <span class="number">4</span>); <span class="comment">// fancy f!
</span><span class="macro">assert_eq!</span>(<span class="string">"ƒoo"</span>.chars().count(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#161">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_empty-1" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">""</span>;
<span class="macro">assert!</span>(s.is_empty());

<span class="kw">let </span>s = <span class="string">"not empty"</span>;
<span class="macro">assert!</span>(!s.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#361">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fn">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard"</span>;
<span class="macro">assert!</span>(s.is_char_boundary(<span class="number">0</span>));
<span class="comment">// start of `老`
</span><span class="macro">assert!</span>(s.is_char_boundary(<span class="number">6</span>));
<span class="macro">assert!</span>(s.is_char_boundary(s.len()));

<span class="comment">// second byte of `ö`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">2</span>));

<span class="comment">// third byte of `老`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">8</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#410">Source</a><h4 class="code-header">pub fn <a href="#method.floor_char_boundary" class="fn">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p>
<p>This method can help you truncate a string so that it’s still valid UTF-8, but doesn’t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters aren’t
split. For example, the emoji 🧑‍🔬 (scientist) could be split so that the string only
includes 🧑 (person) instead.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">"❤️🧡💛💚💙💜"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.floor_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"❤️🧡"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#448">Source</a><h4 class="code-header">pub fn <a href="#method.ceil_char_boundary" class="fn">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p>
<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>
<p>This method is the natural complement to <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">"❤️🧡💛💚💙💜"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.ceil_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"❤️🧡💛"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#474">Source</a></span><h4 class="code-header">pub fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="https://doc.rust-lang.org/nightly/core/str/converts/fn.from_utf8.html" title="fn core::str::converts::from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="string">"bors"</span>.as_bytes();
<span class="macro">assert_eq!</span>(<span class="string">b"bors"</span>, bytes);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#550">Source</a></span><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Hello"</span>;
<span class="kw">let </span>ptr = s.as_ptr();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#593">Source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/slice/index/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::index::SliceIndex::Output">Output</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = String::from(<span class="string">"🗻∈🌏"</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"🗻"</span>), v.get(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries
</span><span class="macro">assert!</span>(v.get(<span class="number">1</span>..).is_none());
<span class="macro">assert!</span>(v.get(..<span class="number">8</span>).is_none());

<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get(..<span class="number">42</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#657">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/slice/index/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::index::SliceIndex::Output">Output</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="string">"🗻∈🌏"</span>;
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"🗻"</span>, v.get_unchecked(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"∈"</span>, v.get_unchecked(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"🌏"</span>, v.get_unchecked(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#743">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fn">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html" title="primitive str"><code>str</code></a> and <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"Löwe 老虎 Léopard"</span>, s.slice_unchecked(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let </span>s = <span class="string">"Hello, world!"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"world"</span>, s.slice_unchecked(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#817">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divides one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past
the end of the last code point of the string slice.  For a non-panicking
alternative see <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a>.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-Löf"</span>;

<span class="kw">let </span>(first, last) = s.split_at(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-Löf"</span>, last);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#898">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_at_checked" class="fn">split_at_checked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt;</h4></section></summary><div class="docblock"><p>Divides one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point. The
method returns <code>None</code> if that’s not the case.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>
method.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-Löf"</span>;

<span class="kw">let </span>(first, last) = s.split_at_checked(<span class="number">3</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-Löf"</span>, last);

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">13</span>));  <span class="comment">// Inside “ö”
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">16</span>));  <span class="comment">// Beyond the string length</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1035">Source</a></span><h4 class="code-header">pub fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.Chars.html" title="struct core::str::iter::Chars">Chars</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p>
<p>It’s important to remember that <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a ‘character’ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rust’s standard library, check crates.io instead.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.chars().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>chars = word.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'g'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'d'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'b'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'e'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>y = <span class="string">"y̆"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>chars = y.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next()); <span class="comment">// not 'y̆'
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'\u{0306}'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1092">Source</a></span><h4 class="code-header">pub fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.CharIndices.html" title="struct core::str::iter::CharIndices">CharIndices</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both
these <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a> is
second.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.char_indices().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = word.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'g'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'d'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'b'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">'y'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">'e'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>yes = <span class="string">"y̆es"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = yes.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'y'</span>)), char_indices.next()); <span class="comment">// not (0, 'y̆')
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'\u{0306}'</span>)), char_indices.next());

<span class="comment">// note the 3 here - the previous character took up two bytes
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'e'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'s'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1115">Source</a></span><h4 class="code-header">pub fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.Bytes.html" title="struct core::str::iter::Bytes">Bytes</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="string">"bors"</span>.bytes();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'b'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'o'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'r'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b's'</span>), bytes.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, bytes.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1167">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fn">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.SplitWhitespace.html" title="struct core::str::iter::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta\u{2009}little  \n\t lamb"</span>.split_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1218">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fn">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.SplitAsciiWhitespace.html" title="struct core::str::iter::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>This uses the same definition as <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.is_ascii_whitespace" title="method char::is_ascii_whitespace"><code>char::is_ascii_whitespace</code></a>.
To split by Unicode <code>Whitespace</code> instead, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_ascii_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>Various kinds of ASCII whitespace are considered
(see <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.is_ascii_whitespace" title="method char::is_ascii_whitespace"><code>char::is_ascii_whitespace</code></a>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta little  \n\t lamb"</span>.split_ascii_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1271">Source</a></span><h4 class="code-header">pub fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.Lines.html" title="struct core::str::iter::Lines">Lines</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the lines of a string, as string slices.</p>
<p>Lines are split at line endings that are either newlines (<code>\n</code>) or
sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p>
<p>Line terminators are not included in the lines returned by the iterator.</p>
<p>Note that any carriage return (<code>\r</code>) not immediately followed by a
line feed (<code>\n</code>) does not split a line. These carriage returns are
thereby included in the produced lines.</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\r\nbar\n\nbaz\r"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="comment">// Trailing carriage return is included in the last line
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz\r"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
<p>The final line does not require any ending:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\nbar\n\r\nbaz"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1280">Source</a></span><h4 class="code-header">pub fn <a href="#method.lines_any" class="fn">lines_any</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.LinesAny.html" title="struct core::str::iter::LinesAny">LinesAny</a>&lt;'_&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class="docblock"><p>Returns an iterator over the lines of a string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1300">Source</a></span><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fn">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.EncodeUtf16.html" title="struct core::str::iter::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded
as native endian UTF-16 (without byte-order mark).</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"Zażółć gęślą jaźń"</span>;

<span class="kw">let </span>utf8_len = text.len();
<span class="kw">let </span>utf16_len = text.encode_utf16().count();

<span class="macro">assert!</span>(utf16_len &lt;= utf8_len);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1325">Source</a></span><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.contains(<span class="string">"nana"</span>));
<span class="macro">assert!</span>(!bananas.contains(<span class="string">"apples"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1363">Source</a></span><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, in which case this function will return true if
the <code>&amp;str</code> is a prefix of this string slice.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can also be a <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.
These will only be checked against the first character of this string slice.
Look at the second example below regarding behavior for slices of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.starts_with(<span class="string">"bana"</span>));
<span class="macro">assert!</span>(!bananas.starts_with(<span class="string">"nana"</span>));</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="comment">// Note that both of these assert successfully.
</span><span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'a'</span>]));
<span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1388-1390">Source</a></span><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.ends_with(<span class="string">"anas"</span>));
<span class="macro">assert!</span>(!bananas.ends_with(<span class="string">"nana"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1439">Source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesn’t match.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.find(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">'é'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard"</span>;

<span class="macro">assert_eq!</span>(s.find(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(s.find(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| (c &lt; <span class="string">'o'</span>) &amp;&amp; (c &gt; <span class="string">'a'</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.find(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1485-1487">Source</a></span><h4 class="code-header">pub fn <a href="#method.rfind" class="fn">rfind</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the last match of the pattern in
this string slice.</p>
<p>Returns <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesn’t match.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'é'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard"</span>;

<span class="macro">assert_eq!</span>(s.rfind(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(s.rfind(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Löwe 老虎 Léopard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.rfind(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1613">Source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.Split.html" title="struct core::str::iter::Split">Split</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>If there are no matches the full string slice is returned as the only
item in the iterator.</p>
<h5 id="iterator-behavior"><a class="doc-anchor" href="#iterator-behavior">§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.split(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a"</span>, <span class="string">"little"</span>, <span class="string">"lamb"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.split(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"AABBCC"</span>.split(<span class="string">"DD"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"AABBCC"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1def2ghi"</span>.split(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXtigerXleopard"</span>.split(char::is_uppercase).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);</code></pre></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"2020-11-03 23:59"</span>.split(<span class="kw-2">&amp;</span>[<span class="string">'-'</span>, <span class="string">' '</span>, <span class="string">':'</span>, <span class="string">'@'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"2020"</span>, <span class="string">"11"</span>, <span class="string">"03"</span>, <span class="string">"23"</span>, <span class="string">"59"</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.split(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"||||a||b|c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'|'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"(///)"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'/'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"("</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">")"</span>]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"010"</span>.split(<span class="string">"0"</span>).collect();
<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">""</span>]);</code></pre></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"rust"</span>.split(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(f, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"r"</span>, <span class="string">"u"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">""</span>]);</code></pre></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"    a  b c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">' '</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre></div>
<p>It does <em>not</em> give you:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre></div>
<p>Use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1654">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.SplitInclusive.html" title="struct core::str::iter::SplitInclusive">SplitInclusive</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code>
leaves the matched part as the terminator of the substring.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb."
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb."</span>]);</code></pre></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb.\n"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1709-1711">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.RSplit.html" title="struct core::str::iter::RSplit">RSplit</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a class="doc-anchor" href="#iterator-behavior-1">§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplit(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"a"</span>, <span class="string">"had"</span>, <span class="string">"Mary"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">""</span>, <span class="string">"lion"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplit(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplit(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"def"</span>, <span class="string">"abc"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1758">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fn">split_terminator</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.SplitTerminator.html" title="struct core::str::iter::SplitTerminator">SplitTerminator</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by characters matched by a pattern.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a class="doc-anchor" href="#iterator-behavior-2">§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.split_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.split_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.split_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1804-1806">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fn">rsplit_terminator</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.RSplitTerminator.html" title="struct core::str::iter::RSplitTerminator">RSplitTerminator</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a class="doc-anchor" href="#iterator-behavior-3">§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.rsplit_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"B"</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.rsplit_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.rsplit_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1859">Source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;P&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.SplitN.html" title="struct core::str::iter::SplitN">SplitN</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by a pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a class="doc-anchor" href="#iterator-behavior-4">§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lambda"</span>.splitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a little lambda"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.splitn(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tigerXleopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXdef"</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abcXdef"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.splitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"defXghi"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1908-1910">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;P&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.RSplitN.html" title="struct core::str::iter::RSplitN">RSplitN</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning at
most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a class="doc-anchor" href="#iterator-behavior-5">§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"Mary had a"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplitn(<span class="number">3</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lionX"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplitn(<span class="number">2</span>, <span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"lion::tiger"</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"abc1def"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1928">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_once" class="fn">split_once</a>&lt;P&gt;(&amp;self, delimiter: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg="</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">""</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo=bar"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1946-1948">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fn">rsplit_once</a>&lt;P&gt;(&amp;self, delimiter: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg=foo"</span>, <span class="string">"bar"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1986">Source</a></span><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.Matches.html" title="struct core::str::iter::Matches">Matches</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within the
given string slice.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a class="doc-anchor" href="#iterator-behavior-6">§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.matches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.matches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2020-2022">Source</a></span><h4 class="code-header">pub fn <a href="#method.rmatches" class="fn">rmatches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.RMatches.html" title="struct core::str::iter::RMatches">RMatches</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within this
string slice, yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a class="doc-anchor" href="#iterator-behavior-7">§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.rmatches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"1"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2064">Source</a></span><h4 class="code-header">pub fn <a href="#method.match_indices" class="fn">match_indices</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.MatchIndices.html" title="struct core::str::iter::MatchIndices">MatchIndices</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a class="doc-anchor" href="#iterator-behavior-8">§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">12</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">1</span>, <span class="string">"abc"</span>), (<span class="number">4</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.match_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the first `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2104-2106">Source</a></span><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fn">rmatch_indices</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.RMatchIndices.html" title="struct core::str::iter::RMatchIndices">RMatchIndices</a>&lt;'_, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a class="doc-anchor" href="#iterator-behavior-9">§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">12</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">0</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">4</span>, <span class="string">"abc"</span>), (<span class="number">1</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.rmatch_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">2</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the last `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2128">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld"</span>, s.trim());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2167">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a class="doc-anchor" href="#text-directionality">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t\n"</span>, s.trim_start());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_start().chars().next());

<span class="kw">let </span>s = <span class="string">"  עברית  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'ע'</span>) == s.trim_start().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2206">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a class="doc-anchor" href="#text-directionality-1">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"\n Hello\tworld"</span>, s.trim_end());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_end().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"  עברית  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'ת'</span>) == s.trim_end().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2246">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left" class="fn">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a class="doc-anchor" href="#text-directionality-2">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. ‘Left’ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t"</span>, s.trim_left());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_left().chars().next());

<span class="kw">let </span>s = <span class="string">"  עברית"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'ע'</span>) == s.trim_left().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2286">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right" class="fn">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>‘Whitespace’ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a class="doc-anchor" href="#text-directionality-3">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. ‘Right’ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">" Hello\tworld"</span>, s.trim_right());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_right().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"עברית  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'ת'</span>) == s.trim_right().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2319-2321">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fn">trim_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_matches(<span class="string">'1'</span>), <span class="string">"foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_matches(char::is_numeric), <span class="string">"foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_matches(x), <span class="string">"foo1bar"</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1foo1barXX"</span>.trim_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"foo1bar"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2366">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fn">trim_start_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a class="doc-anchor" href="#text-directionality-4">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_start_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_start_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_start_matches(x), <span class="string">"foo1bar12"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2400">Source</a></span><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;P&gt;(&amp;self, prefix: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix,
wrapped in <code>Some</code>. Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_start_matches" title="method str::trim_start_matches"><code>trim_start_matches</code></a>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"foo:"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_prefix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2428-2430">Source</a></span><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;P&gt;(&amp;self, suffix: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_end_matches" title="method str::trim_end_matches"><code>trim_end_matches</code></a>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-58"><a class="doc-anchor" href="#examples-58">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">":foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_suffix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_prefix" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2468">Source</a><h4 class="code-header">pub fn <a href="#method.trim_prefix" class="fn">trim_prefix</a>&lt;P&gt;(&amp;self, prefix: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>trim_prefix_suffix</code>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the optional prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix.
Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.strip_prefix" title="method str::strip_prefix"><code>strip_prefix</code></a>, this method always returns <code>&amp;str</code> for easy method chaining,
instead of returning <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;&amp;str&gt;</code></a>.</p>
<p>If the string does not start with <code>prefix</code>, returns the original string unchanged.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-59"><a class="doc-anchor" href="#examples-59">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(trim_prefix_suffix)]

</span><span class="comment">// Prefix present - removes it
</span><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.trim_prefix(<span class="string">"foo:"</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.trim_prefix(<span class="string">"foo"</span>), <span class="string">"foo"</span>);

<span class="comment">// Prefix absent - returns original string
</span><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.trim_prefix(<span class="string">"bar"</span>), <span class="string">"foo:bar"</span>);

<span class="comment">// Method chaining example
</span><span class="macro">assert_eq!</span>(<span class="string">"&lt;https://example.com/&gt;"</span>.trim_prefix(<span class="string">'&lt;'</span>).trim_suffix(<span class="string">'&gt;'</span>), <span class="string">"https://example.com/"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_suffix" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2505-2507">Source</a><h4 class="code-header">pub fn <a href="#method.trim_suffix" class="fn">trim_suffix</a>&lt;P&gt;(&amp;self, suffix: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>trim_prefix_suffix</code>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the optional suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix.
Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.strip_suffix" title="method str::strip_suffix"><code>strip_suffix</code></a>, this method always returns <code>&amp;str</code> for easy method chaining,
instead of returning <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option"><code>Option&lt;&amp;str&gt;</code></a>.</p>
<p>If the string does not end with <code>suffix</code>, returns the original string unchanged.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-60"><a class="doc-anchor" href="#examples-60">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(trim_prefix_suffix)]

</span><span class="comment">// Suffix present - removes it
</span><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.trim_suffix(<span class="string">":foo"</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.trim_suffix(<span class="string">"foo"</span>), <span class="string">"foo"</span>);

<span class="comment">// Suffix absent - returns original string
</span><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.trim_suffix(<span class="string">"bar"</span>), <span class="string">"bar:foo"</span>);

<span class="comment">// Method chaining example
</span><span class="macro">assert_eq!</span>(<span class="string">"&lt;https://example.com/&gt;"</span>.trim_prefix(<span class="string">'&lt;'</span>).trim_suffix(<span class="string">'&gt;'</span>), <span class="string">"https://example.com/"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2548-2550">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fn">trim_end_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a class="doc-anchor" href="#text-directionality-5">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-61"><a class="doc-anchor" href="#examples-61">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_end_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_end_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_end_matches(x), <span class="string">"12foo1bar"</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_end_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2592">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fn">trim_left_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a class="doc-anchor" href="#text-directionality-6">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. ‘Left’ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-62"><a class="doc-anchor" href="#examples-62">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_left_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_left_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_left_matches(x), <span class="string">"foo1bar12"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2635-2637">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fn">trim_right_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a class="doc-anchor" href="#text-directionality-7">§</a>Text directionality</h5>
<p>A string is a sequence of bytes. ‘Right’ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are ‘right to left’ rather than ‘left to right’, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-63"><a class="doc-anchor" href="#examples-63">§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_right_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_right_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_right_matches(x), <span class="string">"12foo1bar"</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_right_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2687">Source</a></span><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>,</div></h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times you’ll see
the syntax affectionately known as the ‘turbofish’: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
you’re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>Will return <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" title="associated type core::str::traits::FromStr::Err"><code>Err</code></a> if it’s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-64"><a class="doc-anchor" href="#examples-64">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four: u32 = <span class="string">"4"</span>.parse().unwrap();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, four);</code></pre></div>
<p>Using the ‘turbofish’ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four = <span class="string">"4"</span>.parse::&lt;u32&gt;();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), four);</code></pre></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nope = <span class="string">"j"</span>.parse::&lt;u32&gt;();

<span class="macro">assert!</span>(nope.is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2706">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-65"><a class="doc-anchor" href="#examples-65">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ascii = <span class="string">"hello!\n"</span>;
<span class="kw">let </span>non_ascii = <span class="string">"Grüße, Jürgen ❤"</span>;

<span class="macro">assert!</span>(ascii.is_ascii());
<span class="macro">assert!</span>(!non_ascii.is_ascii());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2718">Source</a><h4 class="code-header">pub fn <a href="#method.as_ascii" class="fn">as_ascii</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="enum" href="https://doc.rust-lang.org/nightly/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">AsciiChar</a>]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class="docblock"><p>If this string slice <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice
of <a href="https://doc.rust-lang.org/nightly/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">ASCII characters</a>, otherwise returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2732">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.as_ascii_unchecked" class="fn">as_ascii_unchecked</a>(&amp;self) -&gt; &amp;[<a class="enum" href="https://doc.rust-lang.org/nightly/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">AsciiChar</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class="docblock"><p>Converts this string slice into a slice of <a href="https://doc.rust-lang.org/nightly/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">ASCII characters</a>,
without checking whether they are valid.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>Every character in this string must be ASCII, or else this is UB.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2760">Source</a></span><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-66"><a class="doc-anchor" href="#examples-66">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">"Ferris"</span>.eq_ignore_ascii_case(<span class="string">"FERRIS"</span>));
<span class="macro">assert!</span>(<span class="string">"Ferrös"</span>.eq_ignore_ascii_case(<span class="string">"FERRöS"</span>));
<span class="macro">assert!</span>(!<span class="string">"Ferrös"</span>.eq_ignore_ascii_case(<span class="string">"FERRÖS"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2839">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_ascii_start" class="fn">trim_ascii_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading ASCII whitespace removed.</p>
<p>‘Whitespace’ refers to the definition used by
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-67"><a class="doc-anchor" href="#examples-67">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">" \t \u{3000}hello world\n"</span>.trim_ascii_start(), <span class="string">"\u{3000}hello world\n"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_start(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_start(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2864">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_ascii_end" class="fn">trim_ascii_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing ASCII whitespace removed.</p>
<p>‘Whitespace’ refers to the definition used by
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-68"><a class="doc-anchor" href="#examples-68">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\u{3000}\n "</span>.trim_ascii_end(), <span class="string">"\r hello world\u{3000}"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_end(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_end(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2890">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_ascii" class="fn">trim_ascii</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing ASCII whitespace
removed.</p>
<p>‘Whitespace’ refers to the definition used by
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-69"><a class="doc-anchor" href="#examples-69">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\n "</span>.trim_ascii(), <span class="string">"hello world"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2933">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fn">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.EscapeDebug.html" title="struct core::str::iter::EscapeDebug">EscapeDebug</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-70"><a class="doc-anchor" href="#examples-70">§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"❤\n!"</span>.escape_debug() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"❤\n!"</span>.escape_debug());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"❤\\n!"</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"❤\n!"</span>.escape_debug().to_string(), <span class="string">"❤\\n!"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2979">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_default" class="fn">escape_default</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.EscapeDefault.html" title="struct core::str::iter::EscapeDefault">EscapeDefault</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-71"><a class="doc-anchor" href="#examples-71">§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"❤\n!"</span>.escape_default() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"❤\n!"</span>.escape_default());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\n!"</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"❤\n!"</span>.escape_default().to_string(), <span class="string">"\\u{2764}\\n!"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3017">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fn">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/str/iter/struct.EscapeUnicode.html" title="struct core::str::iter::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-72"><a class="doc-anchor" href="#examples-72">§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"❤\n!"</span>.escape_unicode() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"❤\n!"</span>.escape_unicode());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\u{{a}}\\u{{21}}"</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"❤\n!"</span>.escape_unicode().to_string(), <span class="string">"\\u{2764}\\u{a}\\u{21}"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.substr_range" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3050">Source</a><h4 class="code-header">pub fn <a href="#method.substr_range" class="fn">substr_range</a>(&amp;self, substr: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>substr_range</code>)</span></div></span></summary><div class="docblock"><p>Returns the range that a substring points to.</p>
<p>Returns <code>None</code> if <code>substr</code> does not point within <code>self</code>.</p>
<p>Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.find" title="method str::find"><code>str::find</code></a>, <strong>this does not search through the string</strong>.
Instead, it uses pointer arithmetic to find where in the string
<code>substr</code> is derived from.</p>
<p>This is useful for extending <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>str::split</code></a> and similar methods.</p>
<p>Note that this method may return false positives (typically either
<code>Some(0..0)</code> or <code>Some(self.len()..self.len())</code>) if <code>substr</code> is a
zero-length <code>str</code> that points at the beginning or end of another,
independent, <code>str</code>.</p>
<h5 id="examples-73"><a class="doc-anchor" href="#examples-73">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(substr_range)]

</span><span class="kw">let </span>data = <span class="string">"a, b, b, a"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>iter = data.split(<span class="string">", "</span>).map(|s| data.substr_range(s).unwrap());

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">0</span>..<span class="number">1</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">3</span>..<span class="number">4</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">6</span>..<span class="number">7</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">9</span>..<span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_str-1" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3061">Source</a><h4 class="code-header">pub fn <a href="#method.as_str-1" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>str_as_str</code>)</span></div></span></summary><div class="docblock"><p>Returns the same string as a string slice <code>&amp;str</code>.</p>
<p>This method is redundant when used directly on <code>&amp;str</code>, but
it helps dereferencing other string-like types to string slices,
for example references to <code>Box&lt;str&gt;</code> or <code>Arc&lt;str&gt;</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#268">Source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;P&gt;(&amp;self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h5 id="examples-74"><a class="doc-anchor" href="#examples-74">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"this is new"</span>, s.replace(<span class="string">"old"</span>, <span class="string">"new"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"than an old"</span>, s.replace(<span class="string">"is"</span>, <span class="string">"an"</span>));</code></pre></div>
<p>When the pattern doesn’t match, it returns this string slice as <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;
<span class="macro">assert_eq!</span>(s, s.replace(<span class="string">"cookie monster"</span>, <span class="string">"little lamb"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#323">Source</a></span><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;P&gt;(&amp;self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a><div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h5 id="examples-75"><a class="doc-anchor" href="#examples-75">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"foo foo 123 foo"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"new new 123 foo"</span>, s.replacen(<span class="string">"foo"</span>, <span class="string">"new"</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">"faa fao 123 foo"</span>, s.replacen(<span class="string">'o'</span>, <span class="string">"a"</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo foo new23 foo"</span>, s.replacen(char::is_numeric, <span class="string">"new"</span>, <span class="number">1</span>));</code></pre></div>
<p>When the pattern doesn’t match, it returns this string slice as <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;
<span class="macro">assert_eq!</span>(s, s.replacen(<span class="string">"cookie monster"</span>, <span class="string">"little lamb"</span>, <span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#380">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_lowercase" class="fn">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the lowercase equivalent of this string slice, as a new <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<p>‘Lowercase’ is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-76"><a class="doc-anchor" href="#examples-76">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"HELLO"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"hello"</span>, s.to_lowercase());</code></pre></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sigma = <span class="string">"Σ"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"σ"</span>, sigma.to_lowercase());

<span class="comment">// but at the end of a word, it's ς, not σ:
</span><span class="kw">let </span>odysseus = <span class="string">"ὈΔΥΣΣΕΎΣ"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"ὀδυσσεύς"</span>, odysseus.to_lowercase());</code></pre></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">"农历新年"</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#467">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_uppercase" class="fn">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the uppercase equivalent of this string slice, as a new <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<p>‘Uppercase’ is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-77"><a class="doc-anchor" href="#examples-77">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"hello"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"HELLO"</span>, s.to_uppercase());</code></pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">"农历新年"</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_uppercase());</code></pre></div>
<p>One character can become multiple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"tschüß"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"TSCHÜSS"</span>, s.to_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#531">Source</a></span><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Creates a new <a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-78"><a class="doc-anchor" href="#examples-78">§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"abc"</span>.repeat(<span class="number">4</span>), String::from(<span class="string">"abcabcabcabc"</span>));</code></pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="comment">// this will panic at runtime
</span><span class="kw">let </span>huge = <span class="string">"0123456789abcdef"</span>.repeat(usize::MAX);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#561">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_uppercase-1" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’,
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h5 id="examples-79"><a class="doc-anchor" href="#examples-79">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Grüße, Jürgen ❤"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"GRüßE, JüRGEN ❤"</span>, s.to_ascii_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#593">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_lowercase-1" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’,
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h5 id="examples-80"><a class="doc-anchor" href="#examples-80">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Grüße, Jürgen ❤"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"grüße, jürgen ❤"</span>, s.to_ascii_lowercase());</code></pre></div>
</div></details></div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsULE-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#41-53">Source</a><a href="#impl-AsULE-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="../zerovec/ule/trait.AsULE.html" title="trait zerovec::ule::AsULE">AsULE</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.ULE" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#42">Source</a><a href="#associatedtype.ULE" class="anchor">§</a><h4 class="code-header">type <a href="../zerovec/ule/trait.AsULE.html#associatedtype.ULE" class="associatedtype">ULE</a> = <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>The ULE type corresponding to <code>Self</code>. <a href="../zerovec/ule/trait.AsULE.html#associatedtype.ULE">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.to_unaligned" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#45-47">Source</a><a href="#method.to_unaligned" class="anchor">§</a><h4 class="code-header">fn <a href="../zerovec/ule/trait.AsULE.html#tymethod.to_unaligned" class="fn">to_unaligned</a>(self) -&gt; Self::<a class="associatedtype" href="../zerovec/ule/trait.AsULE.html#associatedtype.ULE" title="type zerovec::ule::AsULE::ULE">ULE</a></h4></section></summary><div class='docblock'>Converts from <code>Self</code> to <code>Self::ULE</code>. <a href="../zerovec/ule/trait.AsULE.html#tymethod.to_unaligned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.from_unaligned" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#50-52">Source</a><a href="#method.from_unaligned" class="anchor">§</a><h4 class="code-header">fn <a href="../zerovec/ule/trait.AsULE.html#tymethod.from_unaligned" class="fn">from_unaligned</a>(unaligned: Self::<a class="associatedtype" href="../zerovec/ule/trait.AsULE.html#associatedtype.ULE" title="type zerovec::ule::AsULE::ULE">ULE</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts from <code>Self::ULE</code> to <code>Self</code>. <a href="../zerovec/ule/trait.AsULE.html#tymethod.from_unaligned">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Borrow%3Cstr%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#778-783">Source</a><a href="#impl-Borrow%3Cstr%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#780-782">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-Clone-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#213-215">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#758-762">Source</a><a href="#impl-Debug-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#759-761">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#770-776">Source</a><a href="#impl-Deref-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#771">Source</a><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#773-775">Source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#764-768">Source</a><a href="#impl-Display-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#765-767">Source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTinyAsciiStr%3CN%3E%3E-for-UnvalidatedTinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/unvalidated.rs.html#51-55">Source</a><a href="#impl-From%3CTinyAsciiStr%3CN%3E%3E-for-UnvalidatedTinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;&gt; for <a class="struct" href="struct.UnvalidatedTinyAsciiStr.html" title="struct tinystr::UnvalidatedTinyAsciiStr">UnvalidatedTinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/tinystr/unvalidated.rs.html#52-54">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(other: <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#785-791">Source</a><a href="#impl-FromStr-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#786">Source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="enum" href="enum.ParseError.html" title="enum tinystr::ParseError">ParseError</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#788-790">Source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-Hash-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut __H</a>)</h4></section></summary><div class='docblock'>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NicheBytes%3CN%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#36-39">Source</a><a href="#impl-NicheBytes%3CN%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="../zerovec/ule/niche/trait.NicheBytes.html" title="trait zerovec::ule::niche::NicheBytes">NicheBytes</a>&lt;N&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><section id="associatedconstant.NICHE_BIT_PATTERN" class="associatedconstant trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#38">Source</a><a href="#associatedconstant.NICHE_BIT_PATTERN" class="anchor">§</a><h4 class="code-header">const <a href="../zerovec/ule/niche/trait.NicheBytes.html#associatedconstant.NICHE_BIT_PATTERN" class="constant">NICHE_BIT_PATTERN</a>: [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">N</a>]</h4></section></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-Ord-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1012-1014">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1051-1053">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1077-1079">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#799-803">Source</a><a href="#impl-PartialEq%3C%26str%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#800-802">Source</a><a href="#method.eq-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CString%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#806-810">Source</a><a href="#impl-PartialEq%3CString%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#807-809">Source</a><a href="#method.eq-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-3" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CTinyAsciiStr%3CN%3E%3E-for-String" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#813-817">Source</a><a href="#impl-PartialEq%3CTinyAsciiStr%3CN%3E%3E-for-String" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;&gt; for <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#814-816">Source</a><a href="#method.eq-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-4" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#793-797">Source</a><a href="#impl-PartialEq%3Cstr%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#794-796">Source</a><a href="#method.eq-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-PartialEq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-PartialOrd-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1386">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1404">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1422">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1440">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ULE-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#21-34">Source</a><a href="#impl-ULE-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="../zerovec/ule/trait.ULE.html" title="trait zerovec::ule::ULE">ULE</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.validate_bytes" class="method trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#23-33">Source</a><a href="#method.validate_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="../zerovec/ule/trait.ULE.html#tymethod.validate_bytes" class="fn">validate_bytes</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../zerovec/ule/enum.UleError.html" title="enum zerovec::ule::UleError">UleError</a>&gt;</h4></section></summary><div class='docblock'>Validates a byte slice, <code>&amp;[u8]</code>. <a href="../zerovec/ule/trait.ULE.html#tymethod.validate_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.parse_bytes_to_slice" class="method trait-impl"><a class="src rightside" href="../src/zerovec/ule/mod.rs.html#101">Source</a><a href="#method.parse_bytes_to_slice" class="anchor">§</a><h4 class="code-header">fn <a href="../zerovec/ule/trait.ULE.html#method.parse_bytes_to_slice" class="fn">parse_bytes_to_slice</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;[Self], <a class="enum" href="../zerovec/ule/enum.UleError.html" title="enum zerovec::ule::UleError">UleError</a>&gt;</h4></section></summary><div class='docblock'>Parses a byte slice, <code>&amp;[u8]</code>, and return it as <code>&amp;[Self]</code> with the same lifetime. <a href="../zerovec/ule/trait.ULE.html#method.parse_bytes_to_slice">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.slice_from_bytes_unchecked" class="method trait-impl"><a class="src rightside" href="../src/zerovec/ule/mod.rs.html#132">Source</a><a href="#method.slice_from_bytes_unchecked" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../zerovec/ule/trait.ULE.html#method.slice_from_bytes_unchecked" class="fn">slice_from_bytes_unchecked</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; &amp;[Self]</h4></section></summary><div class='docblock'>Takes a byte slice, <code>&amp;[u8]</code>, and return it as <code>&amp;[Self]</code> with the same lifetime, assuming
that this byte slice has previously been run through <a href="../zerovec/ule/trait.ULE.html#method.parse_bytes_to_slice" title="associated function zerovec::ule::ULE::parse_bytes_to_slice::parse_bytes_to_slice"><code>Self::parse_bytes_to_slice()</code></a> with
success. <a href="../zerovec/ule/trait.ULE.html#method.slice_from_bytes_unchecked">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_bytes" class="method trait-impl"><a class="src rightside" href="../src/zerovec/ule/mod.rs.html#151">Source</a><a href="#method.slice_as_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="../zerovec/ule/trait.ULE.html#method.slice_as_bytes" class="fn">slice_as_bytes</a>(slice: &amp;[Self]) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class='docblock'>Given <code>&amp;[Self]</code>, returns a <code>&amp;[u8]</code> with the same lifetime. <a href="../zerovec/ule/trait.ULE.html#method.slice_as_bytes">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ZeroMapKV%3C'a%3E-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#56-61">Source</a><a href="#impl-ZeroMapKV%3C'a%3E-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a, const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="../zerovec/map/kv/trait.ZeroMapKV.html" title="trait zerovec::map::kv::ZeroMapKV">ZeroMapKV</a>&lt;'a&gt; for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Container" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#57">Source</a><a href="#associatedtype.Container" class="anchor">§</a><h4 class="code-header">type <a href="../zerovec/map/kv/trait.ZeroMapKV.html#associatedtype.Container" class="associatedtype">Container</a> = <a class="struct" href="../zerovec/zerovec/struct.ZeroVec.html" title="struct zerovec::zerovec::ZeroVec">ZeroVec</a>&lt;'a, <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;&gt;</h4></section></summary><div class='docblock'>The container that can be used with this type: <a href="../zerovec/zerovec/struct.ZeroVec.html" title="struct zerovec::zerovec::ZeroVec"><code>ZeroVec</code></a> or <a href="../zerovec/varzerovec/vec/struct.VarZeroVec.html" title="struct zerovec::varzerovec::vec::VarZeroVec"><code>VarZeroVec</code></a>.</div></details><section id="associatedtype.Slice" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#58">Source</a><a href="#associatedtype.Slice" class="anchor">§</a><h4 class="code-header">type <a href="../zerovec/map/kv/trait.ZeroMapKV.html#associatedtype.Slice" class="associatedtype">Slice</a> = <a class="struct" href="../zerovec/zerovec/slice/struct.ZeroSlice.html" title="struct zerovec::zerovec::slice::ZeroSlice">ZeroSlice</a>&lt;<a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;&gt;</h4></section><details class="toggle" open><summary><section id="associatedtype.GetType" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#59">Source</a><a href="#associatedtype.GetType" class="anchor">§</a><h4 class="code-header">type <a href="../zerovec/map/kv/trait.ZeroMapKV.html#associatedtype.GetType" class="associatedtype">GetType</a> = <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>The type produced by <code>Container::get()</code> <a href="../zerovec/map/kv/trait.ZeroMapKV.html#associatedtype.GetType">Read more</a></div></details><details class="toggle" open><summary><section id="associatedtype.OwnedType" class="associatedtype trait-impl"><a class="src rightside" href="../src/tinystr/ule.rs.html#60">Source</a><a href="#associatedtype.OwnedType" class="anchor">§</a><h4 class="code-header">type <a href="../zerovec/map/kv/trait.ZeroMapKV.html#associatedtype.OwnedType" class="associatedtype">OwnedType</a> = <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h4></section></summary><div class='docblock'>The type produced by <code>Container::replace()</code> and <code>Container::remove()</code>,
also used during deserialization. If <code>Self</code> is human readable serialized,
deserializing to <code>Self::OwnedType</code> should produce the same value once
passed through <code>Self::owned_as_self()</code> <a href="../zerovec/map/kv/trait.ZeroMapKV.html#associatedtype.OwnedType">Read more</a></div></details></div></details><section id="impl-Copy-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-Copy-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Eq-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-Eq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-StructuralPartialEq-for-TinyAsciiStr%3CN%3E" class="impl"><a class="src rightside" href="../src/tinystr/ascii.rs.html#14">Source</a><a href="#impl-StructuralPartialEq-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Freeze-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-RefUnwindSafe-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-RefUnwindSafe-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Send-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Send-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Sync-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Sync-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-Unpin-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-Unpin-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section><section id="impl-UnwindSafe-for-TinyAsciiStr%3CN%3E" class="impl"><a href="#impl-UnwindSafe-for-TinyAsciiStr%3CN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.TinyAsciiStr.html" title="struct tinystr::TinyAsciiStr">TinyAsciiStr</a>&lt;N&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#483">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#485">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#774">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#757-759">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Receiver-for-P" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/ops/deref.rs.html#380-382">Source</a><a href="#impl-Receiver-for-P" class="anchor">§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Receiver.html" title="trait core::ops::deref::Receiver">Receiver</a> for P<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt; + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/ops/deref.rs.html#384">Source</a><a href="#associatedtype.Target-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Receiver.html#associatedtype.Target" class="associatedtype">Target</a> = T</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>arbitrary_self_types</code>)</span></div></span><div class='docblock'>The target type on which the method may be called.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2806">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2808">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#813-815">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#817">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#820">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#798-800">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#802">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-ErasedDestructor-for-T" class="impl"><a class="src rightside" href="../src/yoke/erased.rs.html#22">Source</a><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../yoke/erased/trait.ErasedDestructor.html" title="trait yoke::erased::ErasedDestructor">ErasedDestructor</a> for T<div class="where">where
    T: 'static,</div></h3></section></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div>"}</script></section></div></main></body></html>