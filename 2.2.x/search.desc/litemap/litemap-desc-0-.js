searchState.loadedDescShard("litemap", 0, "<code>litemap</code>\nAn entry in a <code>LiteMap</code>, which may be either occupied or …\nA simple “flat” map based on a sorted vector\nA view into an occupied entry in a <code>LiteMap</code>.\nA view into a vacant entry in a <code>LiteMap</code>.\nProvides in-place mutable access to an occupied entry …\nBorrows the backing buffer of this <code>LiteMap</code> as its slice …\nBorrows this <code>LiteMap</code> as one of its slice type.\nRemove all elements from the <code>LiteMap</code>\nConst version of <code>LiteMap::get_indexed()</code> for a slice store.\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with a <code>&amp;[u8]</code> …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with an integer …\nConst function to get the value associated with a <code>&amp;str</code> …\nConst version of <code>LiteMap::is_empty()</code> for a slice store.\nConst version of <code>LiteMap::len()</code> for a slice store.\nReturns whether <code>key</code> is contained in this map\nGets the entry for the given key in the map for in-place …\nInsert all elements from <code>other</code> into this <code>LiteMap</code>.\nObtain the index for a given key, or if the key is not …\nGet the lowest-rank key/value pair from the <code>LiteMap</code>, if it …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a new <code>LiteMap</code> using the given values\nGets a reference to the value in the entry.\nGet the value associated with <code>key</code>, if it exists.\nBinary search the map with <code>predicate</code> to find a key, …\nGet the key-value pair residing at a particular index\nCreates a new <code>LiteMap</code> from a range of the current <code>LiteMap</code>.\nGets a mutable reference to the value in the entry.\nGet the value associated with <code>key</code>, if it exists, as a …\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nInsert <code>value</code> with <code>key</code>, returning the existing value if it …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the entry into a mutable reference to the value …\nConvert a <code>LiteMap</code> into a sorted <code>Vec&lt;(K, V)&gt;</code>.\nWhether the <code>LiteMap</code> is empty\nProduce an ordered iterator over key-value pairs\nProduce an ordered iterator over keys\nProduce an ordered mutable iterator over key-value pairs\nProduce an iterator over values, ordered by their keys\nGets a reference to the key in the entry.\nGets a reference to the key that would be used when …\nProduce an ordered iterator over keys\nGet the highest-rank key/value pair from the <code>LiteMap</code>, if …\nThe number of elements in the <code>LiteMap</code>\nCreate a new empty <code>LiteMap</code>\nConstruct a new <code>LiteMap</code> backed by Vec\nEnsures a value is in the entry by inserting the result of …\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nTakes the value out of the entry, and returns it.\nRemove the value at <code>key</code>, returning it if it exists.\nReserve capacity for <code>additional</code> more elements to be …\nRetains only the elements specified by the predicate.\nTraits for pluggable LiteMap backends.\nReturns a new <code>LiteMap</code> with keys borrowed from this one and …\nReturns a new <code>LiteMap</code> with keys and values borrowed from …\nReturns a new <code>LiteMap</code> with values borrowed from this one …\nReturns a new <code>LiteMap</code> with owned keys and cloned values.\nReturns a new <code>LiteMap</code> with owned keys and values.\nReturns a new <code>LiteMap</code> with cloned keys and owned values.\nAppends <code>value</code> with <code>key</code> to the end of the underlying …\nAttempts to insert a unique entry into the map.\nAttempts to insert a unique entry into the map.\nProduce an iterator over values, ordered by their keys\nConstruct a new <code>LiteMap</code> with a given capacity\nAn empty store\nTrait to enable pluggable backends for LiteMap.\nTrait to enable const construction of empty store.\nA store that can be built from a tuple iterator.\nIterator methods for the LiteMap store.\nSearches the store for a particular element with a …\nRemoves all items from the store.\nExtends this store with items from an iterator.\nAdds items from another store to the end of this store.\nAdds items from another store to the beginning of this …\nGets a key/value pair at the specified index.\nGets a key/value pair at the specified index, with a …\nInserts an item at a specific index in the store.\nReturns an iterator that moves every item from this store.\nReturns whether the store is empty (contains 0 elements).\nReturns an iterator over key/value pairs.\nReturns an iterator over key/value pairs, with a mutable …\nGets the last element in the store, or <code>None</code> if the store …\nReturns the number of elements in the store.\nPushes one additional item onto the store.\nRemoves an item at a specific index in the store.\nReserves additional capacity in the store.\nRetains items satisfying a predicate in this store.\nCreate a sorted store from <code>iter</code>.\nCreates a new store with the specified capacity hint.")