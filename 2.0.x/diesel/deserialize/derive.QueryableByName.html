<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implements `QueryableByName` for untyped sql queries, such as that one generated by `sql_query`"><title>QueryableByName in diesel::deserialize - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="diesel" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (7908a1d65 2023-04-17)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-1a524efa7bd4ab32.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../diesel/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../diesel/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In diesel::deserialize</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Derive Macro <a href="../index.html">diesel</a>::<wbr><a href="index.html">deserialize</a>::<wbr><a class="derive" href="#">QueryableByName</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/diesel_derives/lib.rs.html#800">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>#[derive(QueryableByName)]
{
    // Attributes available to this derive:
    #[diesel]
    #[table_name]
    #[column_name]
    #[sql_type]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implements <code>QueryableByName</code> for untyped sql queries, such as that one generated
by <code>sql_query</code></p>
<p>To derive this trait, Diesel needs to know the SQL type of each field. You
can do this by either annotating your struct with <code>#[diesel(table_name = some_table)]</code> (in which case the SQL type will be
<code>diesel::dsl::SqlTypeOf&lt;table_name::column_name&gt;</code>), or by annotating each
field with <code>#[diesel(sql_type = SomeType)]</code>.</p>
<p>If the name of a field on your struct is different than the column in your
<code>table!</code> declaration, or if you are deriving this trait on a tuple struct,
you can annotate the field with <code>#[diesel(column_name = some_column)]</code>. For tuple
structs, all fields must have this annotation.</p>
<p>If a field is another struct which implements <code>QueryableByName</code>,
instead of a column, you can annotate that struct with <code>#[diesel(embed)]</code>.
Then all fields contained by that inner struct are loaded into
the embedded struct.</p>
<p>To provide custom deserialization behavior for a field, you can use
<code>#[diesel(deserialize_as = SomeType)]</code>. If this attribute is present, Diesel
will deserialize the corresponding field into <code>SomeType</code>, rather than the
actual field type on your struct and then call <code>.into</code> to convert it to the
actual field type. This can be used to add custom behavior for a
single field, or use types that are otherwise unsupported by Diesel.</p>
<h2 id="attributes"><a href="#attributes">Attributes</a></h2><h3 id="optional-container-attributes"><a href="#optional-container-attributes">Optional container attributes</a></h3>
<ul>
<li><code>#[diesel(table_name = path::to::table)]</code>, to specify that this type contains
columns for the specified table. The path is relative to the current module.
If no field attributes are specified the derive will use the sql type of
the corresponding column.</li>
</ul>
<h3 id="optional-field-attributes"><a href="#optional-field-attributes">Optional field attributes</a></h3>
<ul>
<li><code>#[diesel(column_name = some_column)]</code>, overrides the column name for
a given field. If not set, the name of the field is used as column
name. This attribute is required on tuple structs, if
<code>#[diesel(table_name = some_table)]</code> is used, otherwise it’s optional.</li>
<li><code>#[diesel(sql_type = SomeType)]</code>, assumes <code>SomeType</code> as sql type of the
corresponding field. This attributes has precedence over all other
variants to specify the sql type.</li>
<li><code>#[diesel(deserialize_as = Type)]</code>, instead of deserializing directly
into the field type, the implementation will deserialize into <code>Type</code>.
Then <code>Type</code> is converted via <code>.into()</code> into the field type. By default
this derive will deserialize directly into the field type</li>
<li><code>#[diesel(embed)]</code>, specifies that the current field maps not only
single database column, but is a type that implements
<code>QueryableByName</code> on it’s own</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>If we just want to map a query to our struct, we can use <code>derive</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(QueryableByName, PartialEq, Debug)]
#[diesel(table_name = users)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}

<span class="kw">let </span>first_user = sql_query(<span class="string">&quot;SELECT * FROM users ORDER BY id LIMIT 1&quot;</span>)
    .get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User { id: <span class="number">1</span>, name: <span class="string">&quot;Sean&quot;</span>.into() };
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
<p>If we want to do additional work during deserialization, we can use
<code>deserialize_as</code> to use a different implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>LowercaseString(String);

<span class="kw">impl </span>Into&lt;String&gt; <span class="kw">for </span>LowercaseString {
    <span class="kw">fn </span>into(<span class="self">self</span>) -&gt; String {
        <span class="self">self</span>.<span class="number">0
    </span>}
}

<span class="kw">impl</span>&lt;DB, ST&gt; FromSql&lt;ST, DB&gt; <span class="kw">for </span>LowercaseString
<span class="kw">where
    </span>DB: Backend,
    String: FromSql&lt;ST, DB&gt;,
{
    <span class="kw">fn </span>from_sql(bytes: backend::RawValue&lt;DB&gt;) -&gt; deserialize::Result&lt;<span class="self">Self</span>&gt; {
        String::from_sql(bytes)
            .map(|s| LowercaseString(s.to_lowercase()))
    }
}

<span class="attr">#[derive(QueryableByName, PartialEq, Debug)]
#[diesel(table_name = users)]
</span><span class="kw">struct </span>User {
    id: i32,
    <span class="attr">#[diesel(deserialize_as = LowercaseString)]
    </span>name: String,
}

<span class="kw">let </span>first_user = sql_query(<span class="string">&quot;SELECT * FROM users ORDER BY id LIMIT 1&quot;</span>)
    .get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User { id: <span class="number">1</span>, name: <span class="string">&quot;sean&quot;</span>.into() };
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
<p>The custom derive generates impls similar to the follownig one</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(PartialEq, Debug)]
</span><span class="kw">struct </span>User {
    id: i32,
    name: String,
}

<span class="kw">impl</span>&lt;DB&gt; QueryableByName&lt;DB&gt; <span class="kw">for </span>User
<span class="kw">where
    </span>DB: Backend,
    i32: FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::id&gt;, DB&gt;,
    String: FromSql&lt;diesel::dsl::SqlTypeOf&lt;users::name&gt;, DB&gt;,
{
    <span class="kw">fn </span>build&lt;<span class="lifetime">&#39;a</span>&gt;(row: <span class="kw-2">&amp;</span><span class="kw">impl </span>NamedRow&lt;<span class="lifetime">&#39;a</span>, DB&gt;) -&gt; deserialize::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>id = NamedRow::get::&lt;diesel::dsl::SqlTypeOf&lt;users::id&gt;, <span class="kw">_</span>&gt;(row, <span class="string">&quot;id&quot;</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>name = NamedRow::get::&lt;diesel::dsl::SqlTypeOf&lt;users::name&gt;, <span class="kw">_</span>&gt;(row, <span class="string">&quot;name&quot;</span>)<span class="question-mark">?</span>;

        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{ id, name })
    }
}

<span class="kw">let </span>first_user = sql_query(<span class="string">&quot;SELECT * FROM users ORDER BY id LIMIT 1&quot;</span>)
    .get_result(connection)<span class="question-mark">?</span>;
<span class="kw">let </span>expected = User { id: <span class="number">1</span>, name: <span class="string">&quot;Sean&quot;</span>.into() };
<span class="macro">assert_eq!</span>(expected, first_user);</code></pre></div>
</div></details></section></div></main></body></html>